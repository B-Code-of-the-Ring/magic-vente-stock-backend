ff4e1d2052d4880576f1db5fcfdf4442
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
  }
  return to;
};
var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
  value: true
}), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  __DO_NOT_USE__ActionTypes: () => actionTypes_default,
  applyMiddleware: () => applyMiddleware,
  bindActionCreators: () => bindActionCreators,
  combineReducers: () => combineReducers,
  compose: () => compose,
  createStore: () => createStore,
  isAction: () => isAction,
  isPlainObject: () => isPlainObject,
  legacy_createStore: () => legacy_createStore
});
module.exports = __toCommonJS(src_exports);

// src/utils/formatProdErrorMessage.ts
function formatProdErrorMessage(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}

// src/utils/symbol-observable.ts
var $$observable = /* @__PURE__ */(() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;

// src/utils/actionTypes.ts
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;

// src/utils/isPlainObject.ts
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}

// src/utils/kindOf.ts
function miniKindOf(val) {
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      {
        return type;
      }
  }
  if (Array.isArray(val)) return "array";
  if (isDate(val)) return "date";
  if (isError(val)) return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (process.env.NODE_ENV !== "production") {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}

// src/createStore.ts
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach(listener => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function legacy_createStore(reducer, preloadedState, enhancer) {
  return createStore(reducer, preloadedState, enhancer);
}

// src/utils/warning.ts
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {}
}

// src/combineReducers.ts
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter(key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach(key => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE) return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(key => {
    const reducer = reducers[key];
    const initialState = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (process.env.NODE_ENV !== "production") {
      if (typeof reducers[key] === "undefined") {
        warning(`No reducer provided for key "${key}"`);
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (process.env.NODE_ENV !== "production") {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (process.env.NODE_ENV !== "production") {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

// src/bindActionCreators.ts
function bindActionCreator(actionCreator, dispatch) {
  return function (...args) {
    return dispatch(actionCreator.apply(this, args));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(16) : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

// src/compose.ts
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}

// src/applyMiddleware.ts
function applyMiddleware(...middlewares) {
  return createStore2 => (reducer, preloadedState) => {
    const store = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map(middleware => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}

// src/utils/isAction.ts
function isAction(action) {
  return isPlainObject(action) && "type" in action && typeof action.type === "string";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  __DO_NOT_USE__ActionTypes,
  applyMiddleware,
  bindActionCreators,
  combineReducers,
  compose,
  createStore,
  isAction,
  isPlainObject,
  legacy_createStore
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzcmNfZXhwb3J0cyIsIl9fZXhwb3J0IiwiX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcyIsImFjdGlvblR5cGVzX2RlZmF1bHQiLCJhcHBseU1pZGRsZXdhcmUiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlIiwiY3JlYXRlU3RvcmUiLCJpc0FjdGlvbiIsImlzUGxhaW5PYmplY3QiLCJsZWdhY3lfY3JlYXRlU3RvcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX190b0NvbW1vbkpTIiwiZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsImNvZGUiLCIkJG9ic2VydmFibGUiLCJTeW1ib2wiLCJvYnNlcnZhYmxlIiwic3ltYm9sX29ic2VydmFibGVfZGVmYXVsdCIsInJhbmRvbVN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInNwbGl0Iiwiam9pbiIsIkFjdGlvblR5cGVzIiwiSU5JVCIsIlJFUExBQ0UiLCJQUk9CRV9VTktOT1dOX0FDVElPTiIsIm9iaiIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJtaW5pS2luZE9mIiwidmFsIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImlzRGF0ZSIsImlzRXJyb3IiLCJjb25zdHJ1Y3Rvck5hbWUiLCJjdG9yTmFtZSIsInByb3RvdHlwZSIsImNhbGwiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkVycm9yIiwibWVzc2FnZSIsInN0YWNrVHJhY2VMaW1pdCIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJnZXREYXRlIiwic2V0RGF0ZSIsImtpbmRPZiIsInR5cGVPZlZhbCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiYXJndW1lbnRzIiwiY3VycmVudFJlZHVjZXIiLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50TGlzdGVuZXJzIiwiTWFwIiwibmV4dExpc3RlbmVycyIsImxpc3RlbmVySWRDb3VudGVyIiwiaXNEaXNwYXRjaGluZyIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJrZXkiLCJzZXQiLCJnZXRTdGF0ZSIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsImxpc3RlbmVySWQiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsImRpc3BhdGNoIiwiYWN0aW9uIiwibGlzdGVuZXJzIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIm91dGVyU3Vic2NyaWJlIiwib2JzZXJ2ZXIiLCJvYnNlcnZlU3RhdGUiLCJvYnNlcnZlckFzT2JzZXJ2ZXIiLCJuZXh0Iiwic3RvcmUiLCJ3YXJuaW5nIiwiY29uc29sZSIsImVycm9yIiwiZSIsImdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UiLCJpbnB1dFN0YXRlIiwicmVkdWNlcnMiLCJ1bmV4cGVjdGVkS2V5Q2FjaGUiLCJyZWR1Y2VyS2V5cyIsImtleXMiLCJhcmd1bWVudE5hbWUiLCJsZW5ndGgiLCJ1bmV4cGVjdGVkS2V5cyIsImZpbHRlciIsImhhc093blByb3BlcnR5IiwiYXNzZXJ0UmVkdWNlclNoYXBlIiwiaW5pdGlhbFN0YXRlIiwiZmluYWxSZWR1Y2VycyIsImkiLCJmaW5hbFJlZHVjZXJLZXlzIiwic2hhcGVBc3NlcnRpb25FcnJvciIsImNvbWJpbmF0aW9uIiwic3RhdGUiLCJ3YXJuaW5nTWVzc2FnZSIsImhhc0NoYW5nZWQiLCJuZXh0U3RhdGUiLCJwcmV2aW91c1N0YXRlRm9yS2V5IiwibmV4dFN0YXRlRm9yS2V5IiwiYWN0aW9uVHlwZSIsIlN0cmluZyIsImJpbmRBY3Rpb25DcmVhdG9yIiwiYWN0aW9uQ3JlYXRvciIsImFyZ3MiLCJhcHBseSIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsImZ1bmNzIiwiYXJnIiwicmVkdWNlIiwiYSIsImIiLCJtaWRkbGV3YXJlcyIsImNyZWF0ZVN0b3JlMiIsIm1pZGRsZXdhcmVBUEkiLCJjaGFpbiIsIm1hcCIsIm1pZGRsZXdhcmUiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiLCIuLi8uLi9zcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50cyIsIi4uLy4uL3NyYy91dGlscy9zeW1ib2wtb2JzZXJ2YWJsZS50cyIsIi4uLy4uL3NyYy91dGlscy9hY3Rpb25UeXBlcy50cyIsIi4uLy4uL3NyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzIiwiLi4vLi4vc3JjL3V0aWxzL2tpbmRPZi50cyIsIi4uLy4uL3NyYy9jcmVhdGVTdG9yZS50cyIsIi4uLy4uL3NyYy91dGlscy93YXJuaW5nLnRzIiwiLi4vLi4vc3JjL2NvbWJpbmVSZWR1Y2Vycy50cyIsIi4uLy4uL3NyYy9iaW5kQWN0aW9uQ3JlYXRvcnMudHMiLCIuLi8uLi9zcmMvY29tcG9zZS50cyIsIi4uLy4uL3NyYy9hcHBseU1pZGRsZXdhcmUudHMiLCIuLi8uLi9zcmMvdXRpbHMvaXNBY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zXG5pbXBvcnQgeyBjcmVhdGVTdG9yZSwgbGVnYWN5X2NyZWF0ZVN0b3JlIH0gZnJvbSAnLi9jcmVhdGVTdG9yZSc7XG5pbXBvcnQgY29tYmluZVJlZHVjZXJzIGZyb20gJy4vY29tYmluZVJlZHVjZXJzJztcbmltcG9ydCBiaW5kQWN0aW9uQ3JlYXRvcnMgZnJvbSAnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnO1xuaW1wb3J0IGFwcGx5TWlkZGxld2FyZSBmcm9tICcuL2FwcGx5TWlkZGxld2FyZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IGlzQWN0aW9uIGZyb20gJy4vdXRpbHMvaXNBY3Rpb24nO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi91dGlscy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCBfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzIGZyb20gJy4vdXRpbHMvYWN0aW9uVHlwZXMnO1xuXG4vLyB0eXBlc1xuLy8gc3RvcmVcbmV4cG9ydCB7IERpc3BhdGNoLCBVbnN1YnNjcmliZSwgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN0b3JlLCBTdG9yZUNyZWF0b3IsIFN0b3JlRW5oYW5jZXIsIFN0b3JlRW5oYW5jZXJTdG9yZUNyZWF0b3IgfSBmcm9tICcuL3R5cGVzL3N0b3JlJztcbi8vIHJlZHVjZXJzXG5leHBvcnQgeyBSZWR1Y2VyLCBSZWR1Y2Vyc01hcE9iamVjdCwgU3RhdGVGcm9tUmVkdWNlcnNNYXBPYmplY3QsIFJlZHVjZXJGcm9tUmVkdWNlcnNNYXBPYmplY3QsIEFjdGlvbkZyb21SZWR1Y2VyLCBBY3Rpb25Gcm9tUmVkdWNlcnNNYXBPYmplY3QsIFByZWxvYWRlZFN0YXRlU2hhcGVGcm9tUmVkdWNlcnNNYXBPYmplY3QgfSBmcm9tICcuL3R5cGVzL3JlZHVjZXJzJztcbi8vIGFjdGlvbiBjcmVhdG9yc1xuZXhwb3J0IHsgQWN0aW9uQ3JlYXRvciwgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QgfSBmcm9tICcuL3R5cGVzL2FjdGlvbnMnO1xuLy8gbWlkZGxld2FyZVxuZXhwb3J0IHsgTWlkZGxld2FyZUFQSSwgTWlkZGxld2FyZSB9IGZyb20gJy4vdHlwZXMvbWlkZGxld2FyZSc7XG4vLyBhY3Rpb25zXG5leHBvcnQgeyBBY3Rpb24sIFVua25vd25BY3Rpb24sIEFueUFjdGlvbiB9IGZyb20gJy4vdHlwZXMvYWN0aW9ucyc7XG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgbGVnYWN5X2NyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGJpbmRBY3Rpb25DcmVhdG9ycywgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlLCBpc0FjdGlvbiwgaXNQbGFpbk9iamVjdCwgX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcyB9OyIsIi8qKlxuICogQWRhcHRlZCBmcm9tIFJlYWN0OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UuanNcbiAqXG4gKiBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCB0aHJvdyBlcnJvciBjYWxscy4gVGhlc2UgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4gKiBkdXJpbmcgYnVpbGQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciBgICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59IiwiZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgU3ltYm9sQ29uc3RydWN0b3Ige1xuICAgIHJlYWRvbmx5IG9ic2VydmFibGU6IHN5bWJvbDtcbiAgfVxufVxuY29uc3QgJCRvYnNlcnZhYmxlID0gLyogI19fUFVSRV9fICovKCgpID0+IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZScpKCk7XG5leHBvcnQgZGVmYXVsdCAkJG9ic2VydmFibGU7IiwiLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cblxuY29uc3QgcmFuZG9tU3RyaW5nID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG5jb25zdCBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogYEBAcmVkdXgvSU5JVCR7LyogI19fUFVSRV9fICovcmFuZG9tU3RyaW5nKCl9YCxcbiAgUkVQTEFDRTogYEBAcmVkdXgvUkVQTEFDRSR7LyogI19fUFVSRV9fICovcmFuZG9tU3RyaW5nKCl9YCxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046ICgpID0+IGBAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OJHtyYW5kb21TdHJpbmcoKX1gXG59O1xuZXhwb3J0IGRlZmF1bHQgQWN0aW9uVHlwZXM7IiwiLyoqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqOiBhbnkpOiBvYmogaXMgb2JqZWN0IHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgcHJvdG8gPSBvYmo7XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG8gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG51bGw7XG59IiwiLy8gSW5saW5lZCAvIHNob3J0ZW5lZCB2ZXJzaW9uIG9mIGBraW5kT2ZgIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQva2luZC1vZlxuZXhwb3J0IGZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsOiBhbnkpOiBzdHJpbmcge1xuICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGN0b3JOYW1lKHZhbCk7XG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9XG5cbiAgLy8gb3RoZXJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59XG5mdW5jdGlvbiBjdG9yTmFtZSh2YWw6IGFueSk6IHN0cmluZyB8IG51bGwge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHZhbC5jb25zdHJ1Y3Rvci5uYW1lIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3IodmFsOiBhbnkpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0ID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWw6IGFueSkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5zZXREYXRlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGtpbmRPZih2YWw6IGFueSkge1xuICBsZXQgdHlwZU9mVmFsOiBzdHJpbmcgPSB0eXBlb2YgdmFsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuICByZXR1cm4gdHlwZU9mVmFsO1xufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMyB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTEyIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTEgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMCB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTkgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U4IH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNyB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1IH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgJCRvYnNlcnZhYmxlIGZyb20gJy4vdXRpbHMvc3ltYm9sLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgU3RvcmUsIFN0b3JlRW5oYW5jZXIsIERpc3BhdGNoLCBPYnNlcnZlciwgTGlzdGVuZXJDYWxsYmFjaywgVW5rbm93bklmTm9uU3BlY2lmaWMgfSBmcm9tICcuL3R5cGVzL3N0b3JlJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vdHlwZXMvYWN0aW9ucyc7XG5pbXBvcnQgeyBSZWR1Y2VyIH0gZnJvbSAnLi90eXBlcy9yZWR1Y2Vycyc7XG5pbXBvcnQgQWN0aW9uVHlwZXMgZnJvbSAnLi91dGlscy9hY3Rpb25UeXBlcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL3V0aWxzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHsga2luZE9mIH0gZnJvbSAnLi91dGlscy9raW5kT2YnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fT4ocmVkdWNlcjogUmVkdWNlcjxTLCBBPiwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dDtcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyB0aGUgYGNvbmZpZ3VyZVN0b3JlYCBtZXRob2RcbiAqIG9mIHRoZSBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgLlxuICpcbiAqIFJlZHV4IFRvb2xraXQgaXMgb3VyIHJlY29tbWVuZGVkIGFwcHJvYWNoIGZvciB3cml0aW5nIFJlZHV4IGxvZ2ljIHRvZGF5LFxuICogaW5jbHVkaW5nIHN0b3JlIHNldHVwLCByZWR1Y2VycywgZGF0YSBmZXRjaGluZywgYW5kIG1vcmUuXG4gKlxuICogKipGb3IgbW9yZSBkZXRhaWxzLCBwbGVhc2UgcmVhZCB0aGlzIFJlZHV4IGRvY3MgcGFnZToqKlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIFJlZHV4IFRvb2xraXQgaXMgYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBgY3JlYXRlU3RvcmVgIHRoYXRcbiAqIHNpbXBsaWZpZXMgc2V0dXAgYW5kIGhlbHBzIGF2b2lkIGNvbW1vbiBidWdzLlxuICpcbiAqIFlvdSBzaG91bGQgbm90IGJlIHVzaW5nIHRoZSBgcmVkdXhgIGNvcmUgcGFja2FnZSBieSBpdHNlbGYgdG9kYXksIGV4Y2VwdCBmb3IgbGVhcm5pbmcgcHVycG9zZXMuXG4gKiBUaGUgYGNyZWF0ZVN0b3JlYCBtZXRob2QgZnJvbSB0aGUgY29yZSBgcmVkdXhgIHBhY2thZ2Ugd2lsbCBub3QgYmUgcmVtb3ZlZCwgYnV0IHdlIGVuY291cmFnZVxuICogYWxsIHVzZXJzIHRvIG1pZ3JhdGUgdG8gdXNpbmcgUmVkdXggVG9vbGtpdCBmb3IgYWxsIFJlZHV4IGNvZGUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGBjcmVhdGVTdG9yZWAgd2l0aG91dCB0aGlzIHZpc3VhbCBkZXByZWNhdGlvbiB3YXJuaW5nLCB1c2VcbiAqIHRoZSBgbGVnYWN5X2NyZWF0ZVN0b3JlYCBpbXBvcnQgaW5zdGVhZDpcbiAqXG4gKiBgaW1wb3J0IHsgbGVnYWN5X2NyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlfSBmcm9tICdyZWR1eCdgXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RvcmU8UywgQSBleHRlbmRzIEFjdGlvbiwgRXh0IGV4dGVuZHMge30gPSB7fSwgU3RhdGVFeHQgZXh0ZW5kcyB7fSA9IHt9LCBQcmVsb2FkZWRTdGF0ZSA9IFM+KHJlZHVjZXI6IFJlZHVjZXI8UywgQSwgUHJlbG9hZGVkU3RhdGU+LCBwcmVsb2FkZWRTdGF0ZT86IFByZWxvYWRlZFN0YXRlIHwgdW5kZWZpbmVkLCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fSwgUHJlbG9hZGVkU3RhdGUgPSBTPihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEEsIFByZWxvYWRlZFN0YXRlPiwgcHJlbG9hZGVkU3RhdGU/OiBQcmVsb2FkZWRTdGF0ZSB8IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4gfCB1bmRlZmluZWQsIGVuaGFuY2VyPzogU3RvcmVFbmhhbmNlcjxFeHQsIFN0YXRlRXh0Pik6IFN0b3JlPFMsIEEsIFVua25vd25JZk5vblNwZWNpZmljPFN0YXRlRXh0Pj4gJiBFeHQge1xuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBgRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKHJlZHVjZXIpfSdgKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMCkgOiAnSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS4nKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IChwcmVsb2FkZWRTdGF0ZSBhcyBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMSkgOiBgRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YoZW5oYW5jZXIpfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCAocHJlbG9hZGVkU3RhdGUgYXMgUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQpKTtcbiAgfVxuICBsZXQgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICBsZXQgY3VycmVudFN0YXRlOiBTIHwgUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQgPSAocHJlbG9hZGVkU3RhdGUgYXMgUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQpO1xuICBsZXQgY3VycmVudExpc3RlbmVyczogTWFwPG51bWJlciwgTGlzdGVuZXJDYWxsYmFjaz4gfCBudWxsID0gbmV3IE1hcCgpO1xuICBsZXQgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIGxldCBsaXN0ZW5lcklkQ291bnRlciA9IDA7XG4gIGxldCBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWFrZXMgYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudExpc3RlbmVycyBzbyB3ZSBjYW4gdXNlXG4gICAqIG5leHRMaXN0ZW5lcnMgYXMgYSB0ZW1wb3JhcnkgbGlzdCB3aGlsZSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogVGhpcyBwcmV2ZW50cyBhbnkgYnVncyBhcm91bmQgY29uc3VtZXJzIGNhbGxpbmdcbiAgICogc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC5cbiAgICovXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBrZXkpID0+IHtcbiAgICAgICAgbmV4dExpc3RlbmVycy5zZXQoa2V5LCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCk6IFMge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0KDMpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiAnICsgJ1Bhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuJyk7XG4gICAgfVxuICAgIHJldHVybiAoY3VycmVudFN0YXRlIGFzIFMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXI6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDQpIDogYEV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGxpc3RlbmVyKX0nYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2KDUpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cbiAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgY29uc3QgbGlzdGVuZXJJZCA9IGxpc3RlbmVySWRDb3VudGVyKys7XG4gICAgbmV4dExpc3RlbmVycy5zZXQobGlzdGVuZXJJZCwgbGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoNikgOiAnWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVySWQpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb246IEEpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOCg3KSA6IGBBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbil9Jy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U5KDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTAoMTcpIDogYEFjdGlvbiBcInR5cGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnJHtraW5kT2YoYWN0aW9uLnR5cGUpfScuIFZhbHVlIHdhczogJyR7YWN0aW9uLnR5cGV9JyAoc3RyaW5naWZpZWQpYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMSg5KSA6ICdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXI6IFJlZHVjZXI8UywgQT4pOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMigxMCkgOiBgRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YobmV4dFJlZHVjZXIpfWApO1xuICAgIH1cbiAgICBjdXJyZW50UmVkdWNlciA9ICgobmV4dFJlZHVjZXIgYXMgdW5rbm93bikgYXMgUmVkdWNlcjxTLCBBLCBQcmVsb2FkZWRTdGF0ZT4pO1xuXG4gICAgLy8gVGhpcyBhY3Rpb24gaGFzIGEgc2ltaWxhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuICAgIGRpc3BhdGNoKCh7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5SRVBMQUNFXG4gICAgfSBhcyBBKSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgY29uc3Qgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmUob2JzZXJ2ZXI6IHVua25vd24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMygxMSkgOiBgRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihvYnNlcnZlcil9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBjb25zdCBvYnNlcnZlckFzT2JzZXJ2ZXIgPSAob2JzZXJ2ZXIgYXMgT2JzZXJ2ZXI8Uz4pO1xuICAgICAgICAgIGlmIChvYnNlcnZlckFzT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJBc09ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbJCRvYnNlcnZhYmxlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCgoe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSBhcyBBKSk7XG4gIGNvbnN0IHN0b3JlID0gKCh7XG4gICAgZGlzcGF0Y2g6IChkaXNwYXRjaCBhcyBEaXNwYXRjaDxBPiksXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyLFxuICAgIFskJG9ic2VydmFibGVdOiBvYnNlcnZhYmxlXG4gIH0gYXMgdW5rbm93bikgYXMgU3RvcmU8UywgQSwgU3RhdGVFeHQ+ICYgRXh0KTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICpcbiAqICoqV2UgcmVjb21tZW5kIHVzaW5nIGBjb25maWd1cmVTdG9yZWAgZnJvbSB0aGVcbiAqIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlKiosIHdoaWNoIHJlcGxhY2VzIGBjcmVhdGVTdG9yZWA6XG4gKiAqKmh0dHBzOi8vcmVkdXguanMub3JnL2ludHJvZHVjdGlvbi93aHktcnRrLWlzLXJlZHV4LXRvZGF5KipcbiAqXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfY3JlYXRlU3RvcmU8UywgQSBleHRlbmRzIEFjdGlvbiwgRXh0IGV4dGVuZHMge30gPSB7fSwgU3RhdGVFeHQgZXh0ZW5kcyB7fSA9IHt9PihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+LCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0O1xuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyBgY29uZmlndXJlU3RvcmVgIGZyb20gdGhlXG4gKiBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgOlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X2NyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fSwgUHJlbG9hZGVkU3RhdGUgPSBTPihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEEsIFByZWxvYWRlZFN0YXRlPiwgcHJlbG9hZGVkU3RhdGU/OiBQcmVsb2FkZWRTdGF0ZSB8IHVuZGVmaW5lZCwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dDtcbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfY3JlYXRlU3RvcmU8UywgQSBleHRlbmRzIEFjdGlvbiwgRXh0IGV4dGVuZHMge30gPSB7fSwgU3RhdGVFeHQgZXh0ZW5kcyB7fSA9IHt9LCBQcmVsb2FkZWRTdGF0ZSA9IFM+KHJlZHVjZXI6IFJlZHVjZXI8UywgQT4sIHByZWxvYWRlZFN0YXRlPzogUHJlbG9hZGVkU3RhdGUgfCBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+IHwgdW5kZWZpbmVkLCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0IHtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIChwcmVsb2FkZWRTdGF0ZSBhcyBhbnkpLCBlbmhhbmNlcik7XG59IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL3R5cGVzL2FjdGlvbnMnO1xuaW1wb3J0IHsgQWN0aW9uRnJvbVJlZHVjZXJzTWFwT2JqZWN0LCBQcmVsb2FkZWRTdGF0ZVNoYXBlRnJvbVJlZHVjZXJzTWFwT2JqZWN0LCBSZWR1Y2VyLCBTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdCB9IGZyb20gJy4vdHlwZXMvcmVkdWNlcnMnO1xuaW1wb3J0IEFjdGlvblR5cGVzIGZyb20gJy4vdXRpbHMvYWN0aW9uVHlwZXMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi91dGlscy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5pbXBvcnQgeyBraW5kT2YgfSBmcm9tICcuL3V0aWxzL2tpbmRPZic7XG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGU6IG9iamVjdCwgcmVkdWNlcnM6IHtcbiAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55Pjtcbn0sIGFjdGlvbjogQWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGU6IHtcbiAgW2tleTogc3RyaW5nXTogdHJ1ZTtcbn0pIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuSU5JVCA/ICdwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIGBUaGUgJHthcmd1bWVudE5hbWV9IGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCIke2tpbmRPZihpbnB1dFN0YXRlKX1cIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBgICsgYGtleXM6IFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cImA7XG4gIH1cbiAgY29uc3QgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoa2V5ID0+ICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5SRVBMQUNFKSByZXR1cm47XG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkICR7dW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknfSBgICsgYFwiJHt1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKX1cIiBmb3VuZCBpbiAke2FyZ3VtZW50TmFtZX0uIGAgKyBgRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiBgICsgYFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5gO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnM6IHtcbiAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55Pjtcbn0pIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gYCArIGBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgYCArIGBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IGAgKyBgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgYCArIGB5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDEzKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gYCArIGBEb24ndCB0cnkgdG8gaGFuZGxlICcke0FjdGlvblR5cGVzLklOSVR9JyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiIGAgKyBgbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgYCArIGBjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBgICsgYGluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBgICsgYGFjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLmApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEB0ZW1wbGF0ZSBTIENvbWJpbmVkIHN0YXRlIG9iamVjdCB0eXBlLlxuICpcbiAqIEBwYXJhbSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50IHJlZHVjZXJcbiAqICAgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXRcbiAqICAgaXMgdG8gdXNlIGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyXG4gKiAgIHJldHVybiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpclxuICogICBpbml0aWFsIHN0YXRlIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnRcbiAqICAgc3RhdGUgZm9yIGFueSB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlIHBhc3NlZFxuICogICBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzPE0+KHJlZHVjZXJzOiBNKTogTVtrZXlvZiBNXSBleHRlbmRzIFJlZHVjZXI8YW55LCBhbnksIGFueT4gfCB1bmRlZmluZWQgPyBSZWR1Y2VyPFN0YXRlRnJvbVJlZHVjZXJzTWFwT2JqZWN0PE0+LCBBY3Rpb25Gcm9tUmVkdWNlcnNNYXBPYmplY3Q8TT4sIFBhcnRpYWw8UHJlbG9hZGVkU3RhdGVTaGFwZUZyb21SZWR1Y2Vyc01hcE9iamVjdDxNPj4+IDogbmV2ZXI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnM6IHtcbiAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55Pjtcbn0pIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGZpbmFsUmVkdWNlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBSZWR1Y2VyPGFueSwgYW55LCBhbnk+O1xuICB9ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGBObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCIke2tleX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHdhcm4gYWJvdXQgdGhlIHNhbWVcbiAgLy8ga2V5cyBtdWx0aXBsZSB0aW1lcy5cbiAgbGV0IHVuZXhwZWN0ZWRLZXlDYWNoZToge1xuICAgIFtrZXk6IHN0cmluZ106IHRydWU7XG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cbiAgbGV0IHNoYXBlQXNzZXJ0aW9uRXJyb3I6IHVua25vd247XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlOiBTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdDx0eXBlb2YgcmVkdWNlcnM+ID0ge30sIGFjdGlvbjogQWN0aW9uKSB7XG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuZXh0U3RhdGU6IFN0YXRlRnJvbVJlZHVjZXJzTWFwT2JqZWN0PHR5cGVvZiByZWR1Y2Vycz4gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICBjb25zdCByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICBjb25zdCBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygxNCkgOiBgV2hlbiBjYWxsZWQgd2l0aCBhbiBhY3Rpb24gb2YgdHlwZSAke2FjdGlvblR5cGUgPyBgXCIke1N0cmluZyhhY3Rpb25UeXBlKX1cImAgOiAnKHVua25vd24gdHlwZSknfSwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC4gYCArIGBUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIGAgKyBgSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGg7XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBEaXNwYXRjaCB9IGZyb20gJy4vdHlwZXMvc3RvcmUnO1xuaW1wb3J0IHsgQWN0aW9uQ3JlYXRvciwgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIEFjdGlvbiB9IGZyb20gJy4vdHlwZXMvYWN0aW9ucyc7XG5pbXBvcnQgeyBraW5kT2YgfSBmcm9tICcuL3V0aWxzL2tpbmRPZic7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcjxBIGV4dGVuZHMgQWN0aW9uPihhY3Rpb25DcmVhdG9yOiBBY3Rpb25DcmVhdG9yPEE+LCBkaXNwYXRjaDogRGlzcGF0Y2g8QT4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJncykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFjdGlvbiBjcmVhdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBkaXNwYXRjaCB3cmFwcGVkIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnM8QSwgQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8QT4+KGFjdGlvbkNyZWF0b3I6IEMsIGRpc3BhdGNoOiBEaXNwYXRjaCk6IEM7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnM8QSBleHRlbmRzIEFjdGlvbkNyZWF0b3I8YW55PiwgQiBleHRlbmRzIEFjdGlvbkNyZWF0b3I8YW55Pj4oYWN0aW9uQ3JlYXRvcjogQSwgZGlzcGF0Y2g6IERpc3BhdGNoKTogQjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yczxBLCBNIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3Q8QT4+KGFjdGlvbkNyZWF0b3JzOiBNLCBkaXNwYXRjaDogRGlzcGF0Y2gpOiBNO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzPE0gZXh0ZW5kcyBBY3Rpb25DcmVhdG9yc01hcE9iamVjdCwgTiBleHRlbmRzIEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0PihhY3Rpb25DcmVhdG9yczogTSwgZGlzcGF0Y2g6IERpc3BhdGNoKTogTjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9yczogQWN0aW9uQ3JlYXRvcjxhbnk+IHwgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIGRpc3BhdGNoOiBEaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYpIDogYGJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYnV0IGluc3RlYWQgcmVjZWl2ZWQ6ICcke2tpbmRPZihhY3Rpb25DcmVhdG9ycyl9Jy4gYCArIGBEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiP2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnM6IEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufSIsInR5cGUgRnVuYzxUIGV4dGVuZHMgYW55W10sIFI+ID0gKC4uLmE6IFQpID0+IFI7XG5cbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvciB0aGVcbiAqIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodFxuICogICB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgYGNvbXBvc2UoZiwgZywgaClgIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogICBgKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSlgLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCk6IDxSPihhOiBSKSA9PiBSO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxGIGV4dGVuZHMgRnVuY3Rpb24+KGY6IEYpOiBGO1xuXG4vKiB0d28gZnVuY3Rpb25zICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPEEsIFQgZXh0ZW5kcyBhbnlbXSwgUj4oZjE6IChhOiBBKSA9PiBSLCBmMjogRnVuYzxULCBBPik6IEZ1bmM8VCwgUj47XG5cbi8qIHRocmVlIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxBLCBCLCBUIGV4dGVuZHMgYW55W10sIFI+KGYxOiAoYjogQikgPT4gUiwgZjI6IChhOiBBKSA9PiBCLCBmMzogRnVuYzxULCBBPik6IEZ1bmM8VCwgUj47XG5cbi8qIGZvdXIgZnVuY3Rpb25zICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPEEsIEIsIEMsIFQgZXh0ZW5kcyBhbnlbXSwgUj4oZjE6IChjOiBDKSA9PiBSLCBmMjogKGI6IEIpID0+IEMsIGYzOiAoYTogQSkgPT4gQiwgZjQ6IEZ1bmM8VCwgQT4pOiBGdW5jPFQsIFI+O1xuXG4vKiByZXN0ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPFI+KGYxOiAoYTogYW55KSA9PiBSLCAuLi5mdW5jczogRnVuY3Rpb25bXSk6ICguLi5hcmdzOiBhbnlbXSkgPT4gUjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2U8Uj4oLi4uZnVuY3M6IEZ1bmN0aW9uW10pOiAoLi4uYXJnczogYW55W10pID0+IFI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKC4uLmZ1bmNzOiBGdW5jdGlvbltdKSB7XG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBpbmZlciB0aGUgYXJndW1lbnQgdHlwZSBzbyBpdCBpcyB1c2FibGUgaW4gaW5mZXJlbmNlIGRvd24gdGhlIGxpbmVcbiAgICByZXR1cm4gPFQsPihhcmc6IFQpID0+IGFyZztcbiAgfVxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoKGEsIGIpID0+ICguLi5hcmdzOiBhbnkpID0+IGEoYiguLi5hcmdzKSkpO1xufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgeyBNaWRkbGV3YXJlLCBNaWRkbGV3YXJlQVBJIH0gZnJvbSAnLi90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IFN0b3JlRW5oYW5jZXIsIERpc3BhdGNoIH0gZnJvbSAnLi90eXBlcy9zdG9yZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKlxuICogQHRlbXBsYXRlIEV4dCBEaXNwYXRjaCBzaWduYXR1cmUgYWRkZWQgYnkgYSBtaWRkbGV3YXJlLlxuICogQHRlbXBsYXRlIFMgVGhlIHR5cGUgb2YgdGhlIHN0YXRlIHN1cHBvcnRlZCBieSBhIG1pZGRsZXdhcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpOiBTdG9yZUVuaGFuY2VyO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dDEsIFM+KG1pZGRsZXdhcmUxOiBNaWRkbGV3YXJlPEV4dDEsIFMsIGFueT4pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDE7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBFeHQyLCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+LCBtaWRkbGV3YXJlMjogTWlkZGxld2FyZTxFeHQyLCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxICYgRXh0Mjtcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dDEsIEV4dDIsIEV4dDMsIFM+KG1pZGRsZXdhcmUxOiBNaWRkbGV3YXJlPEV4dDEsIFMsIGFueT4sIG1pZGRsZXdhcmUyOiBNaWRkbGV3YXJlPEV4dDIsIFMsIGFueT4sIG1pZGRsZXdhcmUzOiBNaWRkbGV3YXJlPEV4dDMsIFMsIGFueT4pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDEgJiBFeHQyICYgRXh0Mztcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dDEsIEV4dDIsIEV4dDMsIEV4dDQsIFM+KG1pZGRsZXdhcmUxOiBNaWRkbGV3YXJlPEV4dDEsIFMsIGFueT4sIG1pZGRsZXdhcmUyOiBNaWRkbGV3YXJlPEV4dDIsIFMsIGFueT4sIG1pZGRsZXdhcmUzOiBNaWRkbGV3YXJlPEV4dDMsIFMsIGFueT4sIG1pZGRsZXdhcmU0OiBNaWRkbGV3YXJlPEV4dDQsIFMsIGFueT4pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDEgJiBFeHQyICYgRXh0MyAmIEV4dDQ7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBFeHQyLCBFeHQzLCBFeHQ0LCBFeHQ1LCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+LCBtaWRkbGV3YXJlMjogTWlkZGxld2FyZTxFeHQyLCBTLCBhbnk+LCBtaWRkbGV3YXJlMzogTWlkZGxld2FyZTxFeHQzLCBTLCBhbnk+LCBtaWRkbGV3YXJlNDogTWlkZGxld2FyZTxFeHQ0LCBTLCBhbnk+LCBtaWRkbGV3YXJlNTogTWlkZGxld2FyZTxFeHQ1LCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxICYgRXh0MiAmIEV4dDMgJiBFeHQ0ICYgRXh0NTtcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dCwgUyA9IGFueT4oLi4ubWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8YW55LCBTLCBhbnk+W10pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDtcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzOiBNaWRkbGV3YXJlW10pOiBTdG9yZUVuaGFuY2VyPGFueT4ge1xuICByZXR1cm4gY3JlYXRlU3RvcmUgPT4gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gICAgbGV0IGRpc3BhdGNoOiBEaXNwYXRjaCA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiAnRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgfTtcbiAgICBjb25zdCBtaWRkbGV3YXJlQVBJOiBNaWRkbGV3YXJlQVBJID0ge1xuICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IChhY3Rpb24sIC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbiwgLi4uYXJncylcbiAgICB9O1xuICAgIGNvbnN0IGNoYWluID0gbWlkZGxld2FyZXMubWFwKG1pZGRsZXdhcmUgPT4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKSk7XG4gICAgZGlzcGF0Y2ggPSBjb21wb3NlPHR5cGVvZiBkaXNwYXRjaD4oLi4uY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RvcmUsXG4gICAgICBkaXNwYXRjaFxuICAgIH07XG4gIH07XG59IiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMvYWN0aW9ucyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uOiB1bmtub3duKTogYWN0aW9uIGlzIEFjdGlvbjxzdHJpbmc+IHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJiAndHlwZScgaW4gYWN0aW9uICYmIHR5cGVvZiAoYWN0aW9uIGFzIFJlY29yZDwndHlwZScsIHVua25vd24+KS50eXBlID09PSAnc3RyaW5nJztcbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBQUEsV0FBQTtBQUFBQyxRQUFBLENBQUFELFdBQUE7RUFBQUUseUJBQUEsRUFBQUEsQ0FBQSxLQUFBQyxtQkFBQTtFQUFBQyxlQUFBLEVBQUFBLENBQUEsS0FBQUEsZUFBQTtFQUFBQyxrQkFBQSxFQUFBQSxDQUFBLEtBQUFBLGtCQUFBO0VBQUFDLGVBQUEsRUFBQUEsQ0FBQSxLQUFBQSxlQUFBO0VBQUFDLE9BQUEsRUFBQUEsQ0FBQSxLQUFBQSxPQUFBO0VBQUFDLFdBQUEsRUFBQUEsQ0FBQSxLQUFBQSxXQUFBO0VBQUFDLFFBQUEsRUFBQUEsQ0FBQSxLQUFBQSxRQUFBO0VBQUFDLGFBQUEsRUFBQUEsQ0FBQSxLQUFBQSxhQUFBO0VBQUFDLGtCQUFBLEVBQUFBLENBQUEsS0FBQUE7QUFBQTtBQUFBQyxNQUFBLENBQUFDLE9BQUEsR0FBQUMsWUFBQSxDQUFBZCxXQUFBOzs7QUNPTyxTQUFTZSx1QkFBdUJDLElBQUEsRUFBYztFQUNuRCxPQUFPLHlCQUF5QkEsSUFBSSw0Q0FBNENBLElBQUk7QUFDdEY7OztBQ0pBLElBQU1DLFlBQUEsR0FBK0Isc0JBQU0sT0FBT0MsTUFBQSxLQUFXLGNBQWNBLE1BQUEsQ0FBT0MsVUFBQSxJQUFjLGdCQUFnQjtBQUNoSCxJQUFPQyx5QkFBQSxHQUFRSCxZQUFBOzs7QUNDZixJQUFNSSxZQUFBLEdBQWVBLENBQUEsS0FBTUMsSUFBQSxDQUFLQyxNQUFBLENBQU8sRUFBRUMsUUFBQSxDQUFTLEVBQUUsRUFBRUMsU0FBQSxDQUFVLENBQUMsRUFBRUMsS0FBQSxDQUFNLEVBQUUsRUFBRUMsSUFBQSxDQUFLLEdBQUc7QUFDckYsSUFBTUMsV0FBQSxHQUFjO0VBQ2xCQyxJQUFBLEVBQU0sZUFBOEIsZUFBQVIsWUFBQSxDQUFhLENBQUM7RUFDbERTLE9BQUEsRUFBUyxrQkFBaUMsZUFBQVQsWUFBQSxDQUFhLENBQUM7RUFDeERVLG9CQUFBLEVBQXNCQSxDQUFBLEtBQU0sK0JBQStCVixZQUFBLENBQWEsQ0FBQztBQUMzRTtBQUNBLElBQU9sQixtQkFBQSxHQUFReUIsV0FBQTs7O0FDVEEsU0FBUmxCLGNBQStCc0IsR0FBQSxFQUF5QjtFQUM3RCxJQUFJLE9BQU9BLEdBQUEsS0FBUSxZQUFZQSxHQUFBLEtBQVEsTUFBTSxPQUFPO0VBQ3BELElBQUlDLEtBQUEsR0FBUUQsR0FBQTtFQUNaLE9BQU9FLE1BQUEsQ0FBT0MsY0FBQSxDQUFlRixLQUFLLE1BQU0sTUFBTTtJQUM1Q0EsS0FBQSxHQUFRQyxNQUFBLENBQU9DLGNBQUEsQ0FBZUYsS0FBSztFQUNyQztFQUNBLE9BQU9DLE1BQUEsQ0FBT0MsY0FBQSxDQUFlSCxHQUFHLE1BQU1DLEtBQUEsSUFBU0MsTUFBQSxDQUFPQyxjQUFBLENBQWVILEdBQUcsTUFBTTtBQUNoRjs7O0FDVk8sU0FBU0ksV0FBV0MsR0FBQSxFQUFrQjtFQUMzQyxJQUFJQSxHQUFBLEtBQVEsUUFBUSxPQUFPO0VBQzNCLElBQUlBLEdBQUEsS0FBUSxNQUFNLE9BQU87RUFDekIsTUFBTUMsSUFBQSxHQUFPLE9BQU9ELEdBQUE7RUFDcEIsUUFBUUMsSUFBQTtJQUNOLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO01BQ0g7UUFDRSxPQUFPQSxJQUFBO01BQ1Q7RUFDSjtFQUNBLElBQUlDLEtBQUEsQ0FBTUMsT0FBQSxDQUFRSCxHQUFHLEdBQUcsT0FBTztFQUMvQixJQUFJSSxNQUFBLENBQU9KLEdBQUcsR0FBRyxPQUFPO0VBQ3hCLElBQUlLLE9BQUEsQ0FBUUwsR0FBRyxHQUFHLE9BQU87RUFDekIsTUFBTU0sZUFBQSxHQUFrQkMsUUFBQSxDQUFTUCxHQUFHO0VBQ3BDLFFBQVFNLGVBQUE7SUFDTixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7TUFDSCxPQUFPQSxlQUFBO0VBQ1g7RUFHQSxPQUFPVCxNQUFBLENBQU9XLFNBQUEsQ0FBVXJCLFFBQUEsQ0FBU3NCLElBQUEsQ0FBS1QsR0FBRyxFQUFFVSxLQUFBLENBQU0sR0FBRyxFQUFFLEVBQUVDLFdBQUEsQ0FBWSxFQUFFQyxPQUFBLENBQVEsT0FBTyxFQUFFO0FBQ3pGO0FBQ0EsU0FBU0wsU0FBU1AsR0FBQSxFQUF5QjtFQUN6QyxPQUFPLE9BQU9BLEdBQUEsQ0FBSWEsV0FBQSxLQUFnQixhQUFhYixHQUFBLENBQUlhLFdBQUEsQ0FBWUMsSUFBQSxHQUFPO0FBQ3hFO0FBQ0EsU0FBU1QsUUFBUUwsR0FBQSxFQUFVO0VBQ3pCLE9BQU9BLEdBQUEsWUFBZWUsS0FBQSxJQUFTLE9BQU9mLEdBQUEsQ0FBSWdCLE9BQUEsS0FBWSxZQUFZaEIsR0FBQSxDQUFJYSxXQUFBLElBQWUsT0FBT2IsR0FBQSxDQUFJYSxXQUFBLENBQVlJLGVBQUEsS0FBb0I7QUFDbEk7QUFDQSxTQUFTYixPQUFPSixHQUFBLEVBQVU7RUFDeEIsSUFBSUEsR0FBQSxZQUFla0IsSUFBQSxFQUFNLE9BQU87RUFDaEMsT0FBTyxPQUFPbEIsR0FBQSxDQUFJbUIsWUFBQSxLQUFpQixjQUFjLE9BQU9uQixHQUFBLENBQUlvQixPQUFBLEtBQVksY0FBYyxPQUFPcEIsR0FBQSxDQUFJcUIsT0FBQSxLQUFZO0FBQy9HO0FBQ08sU0FBU0MsT0FBT3RCLEdBQUEsRUFBVTtFQUMvQixJQUFJdUIsU0FBQSxHQUFvQixPQUFPdkIsR0FBQTtFQUMvQixJQUFJd0IsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxjQUFjO0lBQ3pDSCxTQUFBLEdBQVl4QixVQUFBLENBQVdDLEdBQUc7RUFDNUI7RUFDQSxPQUFPdUIsU0FBQTtBQUNUOzs7QUN5Qk8sU0FBU3BELFlBQW9Hd0QsT0FBQSxFQUF3Q0MsY0FBQSxFQUE0RUMsUUFBQSxFQUE0RjtFQUNsVSxJQUFJLE9BQU9GLE9BQUEsS0FBWSxZQUFZO0lBQ2pDLE1BQU0sSUFBSVosS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF3QixDQUFDLElBQUksbUVBQW1FNEMsTUFBQSxDQUFPSyxPQUFPLENBQUMsR0FBRztFQUM1SztFQUNBLElBQUksT0FBT0MsY0FBQSxLQUFtQixjQUFjLE9BQU9DLFFBQUEsS0FBYSxjQUFjLE9BQU9BLFFBQUEsS0FBYSxjQUFjLE9BQU9DLFNBQUEsQ0FBVSxDQUFDLE1BQU0sWUFBWTtJQUNsSixNQUFNLElBQUlmLEtBQUEsQ0FBTVMsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxlQUFlaEQsc0JBQUEsQ0FBeUIsQ0FBQyxJQUFJLGtRQUE0UTtFQUNwVztFQUNBLElBQUksT0FBT2tELGNBQUEsS0FBbUIsY0FBYyxPQUFPQyxRQUFBLEtBQWEsYUFBYTtJQUMzRUEsUUFBQSxHQUFZRCxjQUFBO0lBQ1pBLGNBQUEsR0FBaUI7RUFDbkI7RUFDQSxJQUFJLE9BQU9DLFFBQUEsS0FBYSxhQUFhO0lBQ25DLElBQUksT0FBT0EsUUFBQSxLQUFhLFlBQVk7TUFDbEMsTUFBTSxJQUFJZCxLQUFBLENBQU1TLE9BQUEsQ0FBUUMsR0FBQSxDQUFJQyxRQUFBLEtBQWEsZUFBZWhELHNCQUFBLENBQXlCLENBQUMsSUFBSSwrREFBK0Q0QyxNQUFBLENBQU9PLFFBQVEsQ0FBQyxHQUFHO0lBQzFLO0lBQ0EsT0FBT0EsUUFBQSxDQUFTMUQsV0FBVyxFQUFFd0QsT0FBQSxFQUFVQyxjQUE2QztFQUN0RjtFQUNBLElBQUlHLGNBQUEsR0FBaUJKLE9BQUE7RUFDckIsSUFBSUssWUFBQSxHQUFnREosY0FBQTtFQUNwRCxJQUFJSyxnQkFBQSxHQUF5RCxtQkFBSUMsR0FBQSxDQUFJO0VBQ3JFLElBQUlDLGFBQUEsR0FBZ0JGLGdCQUFBO0VBQ3BCLElBQUlHLGlCQUFBLEdBQW9CO0VBQ3hCLElBQUlDLGFBQUEsR0FBZ0I7RUFTcEIsU0FBU0MsNkJBQUEsRUFBK0I7SUFDdEMsSUFBSUgsYUFBQSxLQUFrQkYsZ0JBQUEsRUFBa0I7TUFDdENFLGFBQUEsR0FBZ0IsbUJBQUlELEdBQUEsQ0FBSTtNQUN4QkQsZ0JBQUEsQ0FBaUJNLE9BQUEsQ0FBUSxDQUFDQyxRQUFBLEVBQVVDLEdBQUEsS0FBUTtRQUMxQ04sYUFBQSxDQUFjTyxHQUFBLENBQUlELEdBQUEsRUFBS0QsUUFBUTtNQUNqQyxDQUFDO0lBQ0g7RUFDRjtFQU9BLFNBQVNHLFNBQUEsRUFBYztJQUNyQixJQUFJTixhQUFBLEVBQWU7TUFDakIsTUFBTSxJQUFJdEIsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF5QixDQUFDLElBQUksc01BQWdOO0lBQ3hTO0lBQ0EsT0FBUXNELFlBQUE7RUFDVjtFQXlCQSxTQUFTWSxVQUFVSixRQUFBLEVBQXNCO0lBQ3ZDLElBQUksT0FBT0EsUUFBQSxLQUFhLFlBQVk7TUFDbEMsTUFBTSxJQUFJekIsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF5QixDQUFDLElBQUksK0RBQStENEMsTUFBQSxDQUFPa0IsUUFBUSxDQUFDLEdBQUc7SUFDMUs7SUFDQSxJQUFJSCxhQUFBLEVBQWU7TUFDakIsTUFBTSxJQUFJdEIsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF5QixDQUFDLElBQUksaVRBQWdVO0lBQ3haO0lBQ0EsSUFBSW1FLFlBQUEsR0FBZTtJQUNuQlAsNEJBQUEsQ0FBNkI7SUFDN0IsTUFBTVEsVUFBQSxHQUFhVixpQkFBQTtJQUNuQkQsYUFBQSxDQUFjTyxHQUFBLENBQUlJLFVBQUEsRUFBWU4sUUFBUTtJQUN0QyxPQUFPLFNBQVNPLFlBQUEsRUFBYztNQUM1QixJQUFJLENBQUNGLFlBQUEsRUFBYztRQUNqQjtNQUNGO01BQ0EsSUFBSVIsYUFBQSxFQUFlO1FBQ2pCLE1BQU0sSUFBSXRCLEtBQUEsQ0FBTVMsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxlQUFlaEQsc0JBQUEsQ0FBeUIsQ0FBQyxJQUFJLHNKQUEySjtNQUNuUDtNQUNBbUUsWUFBQSxHQUFlO01BQ2ZQLDRCQUFBLENBQTZCO01BQzdCSCxhQUFBLENBQWNhLE1BQUEsQ0FBT0YsVUFBVTtNQUMvQmIsZ0JBQUEsR0FBbUI7SUFDckI7RUFDRjtFQTJCQSxTQUFTZ0IsU0FBU0MsTUFBQSxFQUFXO0lBQzNCLElBQUksQ0FBQzdFLGFBQUEsQ0FBYzZFLE1BQU0sR0FBRztNQUMxQixNQUFNLElBQUluQyxLQUFBLENBQU1TLE9BQUEsQ0FBUUMsR0FBQSxDQUFJQyxRQUFBLEtBQWEsZUFBZWhELHNCQUFBLENBQXlCLENBQUMsSUFBSSxpRUFBaUU0QyxNQUFBLENBQU80QixNQUFNLENBQUMsNFVBQTRVO0lBQ25mO0lBQ0EsSUFBSSxPQUFPQSxNQUFBLENBQU9qRCxJQUFBLEtBQVMsYUFBYTtNQUN0QyxNQUFNLElBQUljLEtBQUEsQ0FBTVMsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxlQUFlaEQsc0JBQUEsQ0FBeUIsQ0FBQyxJQUFJLDRHQUE0RztJQUNwTTtJQUNBLElBQUksT0FBT3dFLE1BQUEsQ0FBT2pELElBQUEsS0FBUyxVQUFVO01BQ25DLE1BQU0sSUFBSWMsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUEwQixFQUFFLElBQUksMkVBQTJFNEMsTUFBQSxDQUFPNEIsTUFBQSxDQUFPakQsSUFBSSxDQUFDLGtCQUFrQmlELE1BQUEsQ0FBT2pELElBQUksaUJBQWlCO0lBQ3RPO0lBQ0EsSUFBSW9DLGFBQUEsRUFBZTtNQUNqQixNQUFNLElBQUl0QixLQUFBLENBQU1TLE9BQUEsQ0FBUUMsR0FBQSxDQUFJQyxRQUFBLEtBQWEsZUFBZWhELHNCQUFBLENBQTBCLENBQUMsSUFBSSxvQ0FBb0M7SUFDN0g7SUFDQSxJQUFJO01BQ0YyRCxhQUFBLEdBQWdCO01BQ2hCTCxZQUFBLEdBQWVELGNBQUEsQ0FBZUMsWUFBQSxFQUFja0IsTUFBTTtJQUNwRCxVQUFFO01BQ0FiLGFBQUEsR0FBZ0I7SUFDbEI7SUFDQSxNQUFNYyxTQUFBLEdBQVlsQixnQkFBQSxHQUFtQkUsYUFBQTtJQUNyQ2dCLFNBQUEsQ0FBVVosT0FBQSxDQUFRQyxRQUFBLElBQVk7TUFDNUJBLFFBQUEsQ0FBUztJQUNYLENBQUM7SUFDRCxPQUFPVSxNQUFBO0VBQ1Q7RUFXQSxTQUFTRSxlQUFlQyxXQUFBLEVBQWtDO0lBQ3hELElBQUksT0FBT0EsV0FBQSxLQUFnQixZQUFZO01BQ3JDLE1BQU0sSUFBSXRDLEtBQUEsQ0FBTVMsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxlQUFlaEQsc0JBQUEsQ0FBMEIsRUFBRSxJQUFJLGtFQUFrRTRDLE1BQUEsQ0FBTytCLFdBQVcsQ0FBQyxFQUFFO0lBQ2pMO0lBQ0F0QixjQUFBLEdBQW1Cc0IsV0FBQTtJQU1uQkosUUFBQSxDQUFVO01BQ1JoRCxJQUFBLEVBQU1uQyxtQkFBQSxDQUFZMkI7SUFDcEIsQ0FBTztFQUNUO0VBUUEsU0FBU1gsV0FBQSxFQUFhO0lBQ3BCLE1BQU13RSxjQUFBLEdBQWlCVixTQUFBO0lBQ3ZCLE9BQU87TUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO01BU0xBLFVBQVVXLFFBQUEsRUFBbUI7UUFDM0IsSUFBSSxPQUFPQSxRQUFBLEtBQWEsWUFBWUEsUUFBQSxLQUFhLE1BQU07VUFDckQsTUFBTSxJQUFJeEMsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUEwQixFQUFFLElBQUksOERBQThENEMsTUFBQSxDQUFPaUMsUUFBUSxDQUFDLEdBQUc7UUFDM0s7UUFDQSxTQUFTQyxhQUFBLEVBQWU7VUFDdEIsTUFBTUMsa0JBQUEsR0FBc0JGLFFBQUE7VUFDNUIsSUFBSUUsa0JBQUEsQ0FBbUJDLElBQUEsRUFBTTtZQUMzQkQsa0JBQUEsQ0FBbUJDLElBQUEsQ0FBS2YsUUFBQSxDQUFTLENBQUM7VUFDcEM7UUFDRjtRQUNBYSxZQUFBLENBQWE7UUFDYixNQUFNVCxXQUFBLEdBQWNPLGNBQUEsQ0FBZUUsWUFBWTtRQUMvQyxPQUFPO1VBQ0xUO1FBQ0Y7TUFDRjtNQUNBLENBQUNoRSx5QkFBWSxJQUFJO1FBQ2YsT0FBTztNQUNUO0lBQ0Y7RUFDRjtFQUtBa0UsUUFBQSxDQUFVO0lBQ1JoRCxJQUFBLEVBQU1uQyxtQkFBQSxDQUFZMEI7RUFDcEIsQ0FBTztFQUNQLE1BQU1tRSxLQUFBLEdBQVU7SUFDZFYsUUFBQTtJQUNBTCxTQUFBO0lBQ0FELFFBQUE7SUFDQVMsY0FBQTtJQUNBLENBQUNyRSx5QkFBWSxHQUFHRDtFQUNsQjtFQUNBLE9BQU82RSxLQUFBO0FBQ1Q7QUFnRU8sU0FBU3JGLG1CQUEyR3FELE9BQUEsRUFBd0JDLGNBQUEsRUFBNEVDLFFBQUEsRUFBNEY7RUFDelQsT0FBTzFELFdBQUEsQ0FBWXdELE9BQUEsRUFBVUMsY0FBQSxFQUF3QkMsUUFBUTtBQUMvRDs7O0FDMVdlLFNBQVIrQixRQUF5QjVDLE9BQUEsRUFBdUI7RUFFckQsSUFBSSxPQUFPNkMsT0FBQSxLQUFZLGVBQWUsT0FBT0EsT0FBQSxDQUFRQyxLQUFBLEtBQVUsWUFBWTtJQUN6RUQsT0FBQSxDQUFRQyxLQUFBLENBQU05QyxPQUFPO0VBQ3ZCO0VBRUEsSUFBSTtJQUlGLE1BQU0sSUFBSUQsS0FBQSxDQUFNQyxPQUFPO0VBQ3pCLFNBQVMrQyxDQUFBLEVBQUcsQ0FBQztBQUNmOzs7QUNSQSxTQUFTQyxzQ0FBc0NDLFVBQUEsRUFBb0JDLFFBQUEsRUFFaEVoQixNQUFBLEVBQWdCaUIsa0JBQUEsRUFFaEI7RUFDRCxNQUFNQyxXQUFBLEdBQWN2RSxNQUFBLENBQU93RSxJQUFBLENBQUtILFFBQVE7RUFDeEMsTUFBTUksWUFBQSxHQUFlcEIsTUFBQSxJQUFVQSxNQUFBLENBQU9qRCxJQUFBLEtBQVNuQyxtQkFBQSxDQUFZMEIsSUFBQSxHQUFPLGtEQUFrRDtFQUNwSCxJQUFJNEUsV0FBQSxDQUFZRyxNQUFBLEtBQVcsR0FBRztJQUM1QixPQUFPO0VBQ1Q7RUFDQSxJQUFJLENBQUNsRyxhQUFBLENBQWM0RixVQUFVLEdBQUc7SUFDOUIsT0FBTyxPQUFPSyxZQUFZLDRCQUE0QmhELE1BQUEsQ0FBTzJDLFVBQVUsQ0FBQyxrRUFBdUVHLFdBQUEsQ0FBWTlFLElBQUEsQ0FBSyxNQUFNLENBQUM7RUFDeks7RUFDQSxNQUFNa0YsY0FBQSxHQUFpQjNFLE1BQUEsQ0FBT3dFLElBQUEsQ0FBS0osVUFBVSxFQUFFUSxNQUFBLENBQU9oQyxHQUFBLElBQU8sQ0FBQ3lCLFFBQUEsQ0FBU1EsY0FBQSxDQUFlakMsR0FBRyxLQUFLLENBQUMwQixrQkFBQSxDQUFtQjFCLEdBQUcsQ0FBQztFQUN0SCtCLGNBQUEsQ0FBZWpDLE9BQUEsQ0FBUUUsR0FBQSxJQUFPO0lBQzVCMEIsa0JBQUEsQ0FBbUIxQixHQUFHLElBQUk7RUFDNUIsQ0FBQztFQUNELElBQUlTLE1BQUEsSUFBVUEsTUFBQSxDQUFPakQsSUFBQSxLQUFTbkMsbUJBQUEsQ0FBWTJCLE9BQUEsRUFBUztFQUNuRCxJQUFJK0UsY0FBQSxDQUFlRCxNQUFBLEdBQVMsR0FBRztJQUM3QixPQUFPLGNBQWNDLGNBQUEsQ0FBZUQsTUFBQSxHQUFTLElBQUksU0FBUyxLQUFLLEtBQVVDLGNBQUEsQ0FBZWxGLElBQUEsQ0FBSyxNQUFNLENBQUMsY0FBY2dGLFlBQVksOERBQXdFRixXQUFBLENBQVk5RSxJQUFBLENBQUssTUFBTSxDQUFDO0VBQ2hPO0FBQ0Y7QUFDQSxTQUFTcUYsbUJBQW1CVCxRQUFBLEVBRXpCO0VBQ0RyRSxNQUFBLENBQU93RSxJQUFBLENBQUtILFFBQVEsRUFBRTNCLE9BQUEsQ0FBUUUsR0FBQSxJQUFPO0lBQ25DLE1BQU1kLE9BQUEsR0FBVXVDLFFBQUEsQ0FBU3pCLEdBQUc7SUFDNUIsTUFBTW1DLFlBQUEsR0FBZWpELE9BQUEsQ0FBUSxRQUFXO01BQ3RDMUIsSUFBQSxFQUFNbkMsbUJBQUEsQ0FBWTBCO0lBQ3BCLENBQUM7SUFDRCxJQUFJLE9BQU9vRixZQUFBLEtBQWlCLGFBQWE7TUFDdkMsTUFBTSxJQUFJN0QsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF3QixFQUFFLElBQUksOEJBQThCK0QsR0FBRyw4UUFBa1M7SUFDM1o7SUFDQSxJQUFJLE9BQU9kLE9BQUEsQ0FBUSxRQUFXO01BQzVCMUIsSUFBQSxFQUFNbkMsbUJBQUEsQ0FBWTRCLG9CQUFBLENBQXFCO0lBQ3pDLENBQUMsTUFBTSxhQUFhO01BQ2xCLE1BQU0sSUFBSXFCLEtBQUEsQ0FBTVMsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxlQUFlaEQsc0JBQUEsQ0FBeUIsRUFBRSxJQUFJLDhCQUE4QitELEdBQUcsNkVBQWtGM0UsbUJBQUEsQ0FBWTBCLElBQUksOFNBQWtVO0lBQzloQjtFQUNGLENBQUM7QUFDSDtBQXFCZSxTQUFSdkIsZ0JBQWlDaUcsUUFBQSxFQUVyQztFQUNELE1BQU1FLFdBQUEsR0FBY3ZFLE1BQUEsQ0FBT3dFLElBQUEsQ0FBS0gsUUFBUTtFQUN4QyxNQUFNVyxhQUFBLEdBRUYsQ0FBQztFQUNMLFNBQVNDLENBQUEsR0FBSSxHQUFHQSxDQUFBLEdBQUlWLFdBQUEsQ0FBWUcsTUFBQSxFQUFRTyxDQUFBLElBQUs7SUFDM0MsTUFBTXJDLEdBQUEsR0FBTTJCLFdBQUEsQ0FBWVUsQ0FBQztJQUN6QixJQUFJdEQsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxjQUFjO01BQ3pDLElBQUksT0FBT3dDLFFBQUEsQ0FBU3pCLEdBQUcsTUFBTSxhQUFhO1FBQ3hDbUIsT0FBQSxDQUFRLGdDQUFnQ25CLEdBQUcsR0FBRztNQUNoRDtJQUNGO0lBQ0EsSUFBSSxPQUFPeUIsUUFBQSxDQUFTekIsR0FBRyxNQUFNLFlBQVk7TUFDdkNvQyxhQUFBLENBQWNwQyxHQUFHLElBQUl5QixRQUFBLENBQVN6QixHQUFHO0lBQ25DO0VBQ0Y7RUFDQSxNQUFNc0MsZ0JBQUEsR0FBbUJsRixNQUFBLENBQU93RSxJQUFBLENBQUtRLGFBQWE7RUFJbEQsSUFBSVYsa0JBQUE7RUFHSixJQUFJM0MsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxjQUFjO0lBQ3pDeUMsa0JBQUEsR0FBcUIsQ0FBQztFQUN4QjtFQUNBLElBQUlhLG1CQUFBO0VBQ0osSUFBSTtJQUNGTCxrQkFBQSxDQUFtQkUsYUFBYTtFQUNsQyxTQUFTZCxDQUFBLEVBQUc7SUFDVmlCLG1CQUFBLEdBQXNCakIsQ0FBQTtFQUN4QjtFQUNBLE9BQU8sU0FBU2tCLFlBQVlDLEtBQUEsR0FBcUQsQ0FBQyxHQUFHaEMsTUFBQSxFQUFnQjtJQUNuRyxJQUFJOEIsbUJBQUEsRUFBcUI7TUFDdkIsTUFBTUEsbUJBQUE7SUFDUjtJQUNBLElBQUl4RCxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGNBQWM7TUFDekMsTUFBTXlELGNBQUEsR0FBaUJuQixxQ0FBQSxDQUFzQ2tCLEtBQUEsRUFBT0wsYUFBQSxFQUFlM0IsTUFBQSxFQUFRaUIsa0JBQWtCO01BQzdHLElBQUlnQixjQUFBLEVBQWdCO1FBQ2xCdkIsT0FBQSxDQUFRdUIsY0FBYztNQUN4QjtJQUNGO0lBQ0EsSUFBSUMsVUFBQSxHQUFhO0lBQ2pCLE1BQU1DLFNBQUEsR0FBeUQsQ0FBQztJQUNoRSxTQUFTUCxDQUFBLEdBQUksR0FBR0EsQ0FBQSxHQUFJQyxnQkFBQSxDQUFpQlIsTUFBQSxFQUFRTyxDQUFBLElBQUs7TUFDaEQsTUFBTXJDLEdBQUEsR0FBTXNDLGdCQUFBLENBQWlCRCxDQUFDO01BQzlCLE1BQU1uRCxPQUFBLEdBQVVrRCxhQUFBLENBQWNwQyxHQUFHO01BQ2pDLE1BQU02QyxtQkFBQSxHQUFzQkosS0FBQSxDQUFNekMsR0FBRztNQUNyQyxNQUFNOEMsZUFBQSxHQUFrQjVELE9BQUEsQ0FBUTJELG1CQUFBLEVBQXFCcEMsTUFBTTtNQUMzRCxJQUFJLE9BQU9xQyxlQUFBLEtBQW9CLGFBQWE7UUFDMUMsTUFBTUMsVUFBQSxHQUFhdEMsTUFBQSxJQUFVQSxNQUFBLENBQU9qRCxJQUFBO1FBQ3BDLE1BQU0sSUFBSWMsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF5QixFQUFFLElBQUksc0NBQXNDOEcsVUFBQSxHQUFhLElBQUlDLE1BQUEsQ0FBT0QsVUFBVSxDQUFDLE1BQU0sZ0JBQWdCLGdDQUFnQy9DLEdBQUcsZ0xBQTBMO01BQ3JaO01BQ0E0QyxTQUFBLENBQVU1QyxHQUFHLElBQUk4QyxlQUFBO01BQ2pCSCxVQUFBLEdBQWFBLFVBQUEsSUFBY0csZUFBQSxLQUFvQkQsbUJBQUE7SUFDakQ7SUFDQUYsVUFBQSxHQUFhQSxVQUFBLElBQWNMLGdCQUFBLENBQWlCUixNQUFBLEtBQVcxRSxNQUFBLENBQU93RSxJQUFBLENBQUthLEtBQUssRUFBRVgsTUFBQTtJQUMxRSxPQUFPYSxVQUFBLEdBQWFDLFNBQUEsR0FBWUgsS0FBQTtFQUNsQztBQUNGOzs7QUM5SEEsU0FBU1Esa0JBQW9DQyxhQUFBLEVBQWlDMUMsUUFBQSxFQUF1QjtFQUNuRyxPQUFPLGFBQXdCMkMsSUFBQSxFQUFhO0lBQzFDLE9BQU8zQyxRQUFBLENBQVMwQyxhQUFBLENBQWNFLEtBQUEsQ0FBTSxNQUFNRCxJQUFJLENBQUM7RUFDakQ7QUFDRjtBQTJCZSxTQUFSNUgsbUJBQW9DOEgsY0FBQSxFQUE4RDdDLFFBQUEsRUFBb0I7RUFDM0gsSUFBSSxPQUFPNkMsY0FBQSxLQUFtQixZQUFZO0lBQ3hDLE9BQU9KLGlCQUFBLENBQWtCSSxjQUFBLEVBQWdCN0MsUUFBUTtFQUNuRDtFQUNBLElBQUksT0FBTzZDLGNBQUEsS0FBbUIsWUFBWUEsY0FBQSxLQUFtQixNQUFNO0lBQ2pFLE1BQU0sSUFBSS9FLEtBQUEsQ0FBTVMsT0FBQSxDQUFRQyxHQUFBLENBQUlDLFFBQUEsS0FBYSxlQUFlaEQsc0JBQUEsQ0FBd0IsRUFBRSxJQUFJLCtFQUErRTRDLE1BQUEsQ0FBT3dFLGNBQWMsQ0FBQyw2RkFBa0c7RUFDL1I7RUFDQSxNQUFNQyxtQkFBQSxHQUErQyxDQUFDO0VBQ3RELFdBQVd0RCxHQUFBLElBQU9xRCxjQUFBLEVBQWdCO0lBQ2hDLE1BQU1ILGFBQUEsR0FBZ0JHLGNBQUEsQ0FBZXJELEdBQUc7SUFDeEMsSUFBSSxPQUFPa0QsYUFBQSxLQUFrQixZQUFZO01BQ3ZDSSxtQkFBQSxDQUFvQnRELEdBQUcsSUFBSWlELGlCQUFBLENBQWtCQyxhQUFBLEVBQWUxQyxRQUFRO0lBQ3RFO0VBQ0Y7RUFDQSxPQUFPOEMsbUJBQUE7QUFDVDs7O0FDdkJlLFNBQVI3SCxRQUFBLEdBQTRCOEgsS0FBQSxFQUFtQjtFQUNwRCxJQUFJQSxLQUFBLENBQU16QixNQUFBLEtBQVcsR0FBRztJQUV0QixPQUFZMEIsR0FBQSxJQUFXQSxHQUFBO0VBQ3pCO0VBQ0EsSUFBSUQsS0FBQSxDQUFNekIsTUFBQSxLQUFXLEdBQUc7SUFDdEIsT0FBT3lCLEtBQUEsQ0FBTSxDQUFDO0VBQ2hCO0VBQ0EsT0FBT0EsS0FBQSxDQUFNRSxNQUFBLENBQU8sQ0FBQ0MsQ0FBQSxFQUFHQyxDQUFBLEtBQU0sSUFBSVIsSUFBQSxLQUFjTyxDQUFBLENBQUVDLENBQUEsQ0FBRSxHQUFHUixJQUFJLENBQUMsQ0FBQztBQUMvRDs7O0FDT2UsU0FBUjdILGdCQUFBLEdBQW9Dc0ksV0FBQSxFQUErQztFQUN4RixPQUFPQyxZQUFBLElBQWUsQ0FBQzNFLE9BQUEsRUFBU0MsY0FBQSxLQUFtQjtJQUNqRCxNQUFNK0IsS0FBQSxHQUFRMkMsWUFBQSxDQUFZM0UsT0FBQSxFQUFTQyxjQUFjO0lBQ2pELElBQUlxQixRQUFBLEdBQXFCQSxDQUFBLEtBQU07TUFDN0IsTUFBTSxJQUFJbEMsS0FBQSxDQUFNUyxPQUFBLENBQVFDLEdBQUEsQ0FBSUMsUUFBQSxLQUFhLGVBQWVoRCxzQkFBQSxDQUF3QixFQUFFLElBQUksd0hBQTZIO0lBQ3JOO0lBQ0EsTUFBTTZILGFBQUEsR0FBK0I7TUFDbkM1RCxRQUFBLEVBQVVnQixLQUFBLENBQU1oQixRQUFBO01BQ2hCTSxRQUFBLEVBQVVBLENBQUNDLE1BQUEsS0FBVzBDLElBQUEsS0FBUzNDLFFBQUEsQ0FBU0MsTUFBQSxFQUFRLEdBQUcwQyxJQUFJO0lBQ3pEO0lBQ0EsTUFBTVksS0FBQSxHQUFRSCxXQUFBLENBQVlJLEdBQUEsQ0FBSUMsVUFBQSxJQUFjQSxVQUFBLENBQVdILGFBQWEsQ0FBQztJQUNyRXRELFFBQUEsR0FBVy9FLE9BQUEsQ0FBeUIsR0FBR3NJLEtBQUssRUFBRTdDLEtBQUEsQ0FBTVYsUUFBUTtJQUM1RCxPQUFPO01BQ0wsR0FBR1UsS0FBQTtNQUNIVjtJQUNGO0VBQ0Y7QUFDRjs7O0FDMURlLFNBQVI3RSxTQUEwQjhFLE1BQUEsRUFBMkM7RUFDMUUsT0FBTzdFLGFBQUEsQ0FBYzZFLE1BQU0sS0FBSyxVQUFVQSxNQUFBLElBQVUsT0FBUUEsTUFBQSxDQUFtQ2pELElBQUEsS0FBUztBQUMxRyIsImlnbm9yZUxpc3QiOltdfQ==