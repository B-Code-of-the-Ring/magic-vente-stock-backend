3a82d77f208b37b675f2375dbeda80bf
/**
 * @popperjs/core v2.11.8 - MIT License
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    isShadowRoot(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback
  );
}
function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function getVariation(placement) {
  return placement.split('-')[1];
}
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          effect = _ref.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var passive = {
  passive: true
};
function effect$2(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules

var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
    y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules

var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};
function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};
var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules

var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? top : left;
    var _altSide = mainAxis === 'x' ? bottom : right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};
var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules

var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules

var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.applyStyles = applyStyles$1;
exports.arrow = arrow$1;
exports.computeStyles = computeStyles$1;
exports.createPopper = createPopper;
exports.createPopperLite = createPopper$1;
exports.defaultModifiers = defaultModifiers;
exports.detectOverflow = detectOverflow;
exports.eventListeners = eventListeners;
exports.flip = flip$1;
exports.hide = hide$1;
exports.offset = offset$1;
exports.popperGenerator = popperGenerator;
exports.popperOffsets = popperOffsets$1;
exports.preventOverflow = preventOverflow$1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRXaW5kb3ciLCJub2RlIiwid2luZG93IiwidG9TdHJpbmciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJtYXgiLCJNYXRoIiwibWluIiwicm91bmQiLCJnZXRVQVN0cmluZyIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJicmFuZHMiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJpdGVtIiwiYnJhbmQiLCJ2ZXJzaW9uIiwiam9pbiIsInVzZXJBZ2VudCIsImlzTGF5b3V0Vmlld3BvcnQiLCJ0ZXN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxlbWVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsImNsaWVudFJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaGVpZ2h0IiwiX3JlZiIsInZpc3VhbFZpZXdwb3J0IiwiYWRkVmlzdWFsT2Zmc2V0cyIsIngiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsInkiLCJ0b3AiLCJvZmZzZXRUb3AiLCJyaWdodCIsImJvdHRvbSIsImdldFdpbmRvd1Njcm9sbCIsIndpbiIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImlzRWxlbWVudFNjYWxlZCIsInJlY3QiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJvZmZzZXRQYXJlbnQiLCJpc0ZpeGVkIiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsInNjcm9sbCIsIm9mZnNldHMiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwiZ2V0TGF5b3V0UmVjdCIsImFicyIsImdldFBhcmVudE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldFNjcm9sbFBhcmVudCIsImluZGV4T2YiLCJib2R5IiwibGlzdFNjcm9sbFBhcmVudHMiLCJsaXN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwic2Nyb2xsUGFyZW50IiwiaXNCb2R5IiwidGFyZ2V0IiwiY29uY2F0IiwidXBkYXRlZExpc3QiLCJpc1RhYmxlRWxlbWVudCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJwb3NpdGlvbiIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiZ2V0T2Zmc2V0UGFyZW50IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJlbmQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInJlZmVyZW5jZSIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJvcmRlciIsIm1vZGlmaWVycyIsIk1hcCIsInZpc2l0ZWQiLCJTZXQiLCJyZXN1bHQiLCJmb3JFYWNoIiwibW9kaWZpZXIiLCJzZXQiLCJuYW1lIiwic29ydCIsImFkZCIsInJlcXVpcmVzIiwicmVxdWlyZXNJZkV4aXN0cyIsImRlcCIsImhhcyIsImRlcE1vZGlmaWVyIiwiZ2V0IiwicHVzaCIsIm9yZGVyTW9kaWZpZXJzIiwib3JkZXJlZE1vZGlmaWVycyIsInBoYXNlIiwiZGVib3VuY2UiLCJmbiIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJ1bmRlZmluZWQiLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIk9iamVjdCIsImFzc2lnbiIsIm9wdGlvbnMiLCJkYXRhIiwia2V5cyIsImtleSIsImdldFZpZXdwb3J0UmVjdCIsInN0cmF0ZWd5IiwiaHRtbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibGF5b3V0Vmlld3BvcnQiLCJnZXREb2N1bWVudFJlY3QiLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImNvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwibmV4dCIsImlzU2FtZU5vZGUiLCJyZWN0VG9DbGllbnRSZWN0IiwiZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiZ2V0QmFzZVBsYWNlbWVudCIsInNwbGl0IiwiZ2V0VmFyaWF0aW9uIiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IiwiY29tcHV0ZU9mZnNldHMiLCJiYXNlUGxhY2VtZW50IiwidmFyaWF0aW9uIiwiY29tbW9uWCIsImNvbW1vblkiLCJtYWluQXhpcyIsImxlbiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJ2YWx1ZSIsImhhc2hNYXAiLCJkZXRlY3RPdmVyZmxvdyIsInN0YXRlIiwiX29wdGlvbnMiLCJfb3B0aW9ucyRwbGFjZW1lbnQiLCJfb3B0aW9ucyRzdHJhdGVneSIsIl9vcHRpb25zJGJvdW5kYXJ5IiwiX29wdGlvbnMkcm9vdEJvdW5kYXJ5IiwiX29wdGlvbnMkZWxlbWVudENvbnRlIiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9ucyRhbHRCb3VuZGFyeSIsImFsdEJvdW5kYXJ5IiwiX29wdGlvbnMkcGFkZGluZyIsInBhZGRpbmciLCJhbHRDb250ZXh0IiwicG9wcGVyUmVjdCIsInJlY3RzIiwiZWxlbWVudHMiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJPZmZzZXRzIiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm1vZGlmaWVyc0RhdGEiLCJvZmZzZXQiLCJtdWx0aXBseSIsImF4aXMiLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJfa2V5Iiwic29tZSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJhdHRyaWJ1dGVzIiwic3R5bGVzIiwiZWZmZWN0Q2xlYW51cEZucyIsImlzRGVzdHJveWVkIiwiaW5zdGFuY2UiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJzY3JvbGxQYXJlbnRzIiwibSIsImVuYWJsZWQiLCJydW5Nb2RpZmllckVmZmVjdHMiLCJ1cGRhdGUiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsInJlc2V0IiwiaW5kZXgiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmJG9wdGlvbnMiLCJlZmZlY3QiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJwYXNzaXZlIiwiZWZmZWN0JDIiLCJfb3B0aW9ucyRzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TGlzdGVuZXJzIiwicG9wcGVyT2Zmc2V0cyQxIiwidW5zZXRTaWRlcyIsInJvdW5kT2Zmc2V0c0J5RFBSIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1hcFRvU3R5bGVzIiwiX3JlZjIiLCJfT2JqZWN0JGFzc2lnbjIiLCJncHVBY2NlbGVyYXRpb24iLCJhZGFwdGl2ZSIsInJvdW5kT2Zmc2V0cyIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzT3duUHJvcGVydHkiLCJoYXNZIiwic2lkZVgiLCJzaWRlWSIsImhlaWdodFByb3AiLCJ3aWR0aFByb3AiLCJvZmZzZXRZIiwib2Zmc2V0WCIsImNvbW1vblN0eWxlcyIsIl9yZWY0IiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjUiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsImFycm93IiwiY29tcHV0ZVN0eWxlcyQxIiwiYXBwbHlTdHlsZXMiLCJzdHlsZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImVmZmVjdCQxIiwiaW5pdGlhbFN0eWxlcyIsIm1hcmdpbiIsInN0eWxlUHJvcGVydGllcyIsInByb3BlcnR5IiwiYXR0cmlidXRlIiwiYXBwbHlTdHlsZXMkMSIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50Iiwib2Zmc2V0JDEiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsInBsYWNlbWVudHMkMSIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwiYSIsImIiLCJnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZmxpcCIsIl9za2lwIiwiX29wdGlvbnMkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX29wdGlvbnMkYWx0QXhpcyIsImFsdEF4aXMiLCJjaGVja0FsdEF4aXMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJfb3B0aW9ucyRmbGlwVmFyaWF0aW8iLCJwcmVmZXJyZWRQbGFjZW1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJyZWZlcmVuY2VSZWN0IiwiY2hlY2tzTWFwIiwibWFrZUZhbGxiYWNrQ2hlY2tzIiwiZmlyc3RGaXR0aW5nUGxhY2VtZW50IiwiaSIsIl9iYXNlUGxhY2VtZW50IiwiaXNTdGFydFZhcmlhdGlvbiIsImlzVmVydGljYWwiLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsIl9pIiwiZml0dGluZ1BsYWNlbWVudCIsImZpbmQiLCJzbGljZSIsIl9yZXQiLCJmbGlwJDEiLCJnZXRBbHRBeGlzIiwid2l0aGluIiwibWluJDEiLCJtYXgkMSIsIndpdGhpbk1heENsYW1wIiwidiIsInByZXZlbnRPdmVyZmxvdyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlIiwib2Zmc2V0TW9kaWZpZXJTdGF0ZSIsIl9vZmZzZXRNb2RpZmllclN0YXRlJCIsIm1haW5TaWRlIiwiYWx0U2lkZSIsImFkZGl0aXZlIiwibWluTGVuIiwibWF4TGVuIiwiYXJyb3dFbGVtZW50IiwiYXJyb3dSZWN0IiwiYXJyb3dQYWRkaW5nT2JqZWN0IiwiYXJyb3dQYWRkaW5nTWluIiwiYXJyb3dQYWRkaW5nTWF4IiwiYXJyb3dMZW4iLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIiwiX21haW5TaWRlIiwiX2FsdFNpZGUiLCJfb2Zmc2V0IiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwidG9QYWRkaW5nT2JqZWN0IiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJfb3B0aW9ucyRlbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImFycm93JDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzaWRlIiwiaGlkZSIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGVmYXVsdE1vZGlmaWVycyQxIiwiY3JlYXRlUG9wcGVyJDEiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsIi4uLy4uL3NyYy91dGlscy9tYXRoLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3VzZXJBZ2VudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIi4uLy4uL3NyYy9lbnVtcy5qcyIsIi4uLy4uL3NyYy91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIi4uLy4uL3NyYy91dGlscy9kZWJvdW5jZS5qcyIsIi4uLy4uL3NyYy91dGlscy9tZXJnZUJ5TmFtZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCIuLi8uLi9zcmMvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCIuLi8uLi9zcmMvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIi4uLy4uL3NyYy91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCIuLi8uLi9zcmMvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCIuLi8uLi9zcmMvY3JlYXRlUG9wcGVyLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCIuLi8uLi9zcmMvbW9kaWZpZXJzL29mZnNldC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvZmxpcC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRBbHRBeGlzLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3dpdGhpbi5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9hcnJvdy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvaGlkZS5qcyIsIi4uLy4uL3NyYy9wb3BwZXItbGl0ZS5qcyIsIi4uLy4uL3NyYy9wb3BwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuZGVjbGFyZSBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZTogTm9kZSB8IFdpbmRvdyk6IFdpbmRvdztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuXG5kZWNsYXJlIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgRWxlbWVudCk7XG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBIVE1MRWxlbWVudCk7XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIFNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTtcbiIsIi8vIEBmbG93XG5leHBvcnQgY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgY29uc3QgbWluID0gTWF0aC5taW47XG5leHBvcnQgY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuIiwiLy8gQGZsb3dcbnR5cGUgTmF2aWdhdG9yID0gTmF2aWdhdG9yICYgeyB1c2VyQWdlbnREYXRhPzogTmF2aWdhdG9yVUFEYXRhIH07XG5cbmludGVyZmFjZSBOYXZpZ2F0b3JVQURhdGEge1xuICBicmFuZHM6IEFycmF5PHsgYnJhbmQ6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nIH0+O1xuICBtb2JpbGU6IGJvb2xlYW47XG4gIHBsYXRmb3JtOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCk6IHN0cmluZyB7XG4gIGNvbnN0IHVhRGF0YSA9IChuYXZpZ2F0b3I6IE5hdmlnYXRvcikudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhPy5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzXG4gICAgICAubWFwKChpdGVtKSA9PiBgJHtpdGVtLmJyYW5kfS8ke2l0ZW0udmVyc2lvbn1gKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tICcuLi91dGlscy91c2VyQWdlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDbGllbnRSZWN0T2JqZWN0LCBWaXJ0dWFsRWxlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzL21hdGgnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tICcuL2lzTGF5b3V0Vmlld3BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGVsZW1lbnQ6IEVsZW1lbnQgfCBWaXJ0dWFsRWxlbWVudCxcbiAgaW5jbHVkZVNjYWxlOiBib29sZWFuID0gZmFsc2UsXG4gIGlzRml4ZWRTdHJhdGVneTogYm9vbGVhbiA9IGZhbHNlXG4pOiBDbGllbnRSZWN0T2JqZWN0IHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGxldCBzY2FsZVggPSAxO1xuICBsZXQgc2NhbGVZID0gMTtcblxuICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBzY2FsZVggPVxuICAgICAgKGVsZW1lbnQ6IEhUTUxFbGVtZW50KS5vZmZzZXRXaWR0aCA+IDBcbiAgICAgICAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0V2lkdGggfHwgMVxuICAgICAgICA6IDE7XG4gICAgc2NhbGVZID1cbiAgICAgIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0SGVpZ2h0ID4gMFxuICAgICAgICA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0SGVpZ2h0IHx8IDFcbiAgICAgICAgOiAxO1xuICB9XG5cbiAgY29uc3QgeyB2aXN1YWxWaWV3cG9ydCB9ID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93O1xuICBjb25zdCBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG5cbiAgY29uc3QgeCA9XG4gICAgKGNsaWVudFJlY3QubGVmdCArXG4gICAgICAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgL1xuICAgIHNjYWxlWDtcbiAgY29uc3QgeSA9XG4gICAgKGNsaWVudFJlY3QudG9wICtcbiAgICAgIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC9cbiAgICBzY2FsZVk7XG4gIGNvbnN0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgY29uc3QgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeCxcbiAgICB5LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlOiBOb2RlIHwgV2luZG93KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuXG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3AsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGwnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tICcuL2dldEhUTUxFbGVtZW50U2Nyb2xsJztcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGU6IE5vZGUgfCBXaW5kb3cpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQ6ID9Ob2RlIHwgV2luZG93KTogP3N0cmluZyB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KFxuICBlbGVtZW50OiBFbGVtZW50IHwgV2luZG93XG4pOiBIVE1MRWxlbWVudCB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuIChcbiAgICAoaXNFbGVtZW50KGVsZW1lbnQpXG4gICAgICA/IGVsZW1lbnQub3duZXJEb2N1bWVudFxuICAgICAgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50XG4gICkuZG9jdW1lbnRFbGVtZW50O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gJy4vZ2V0V2luZG93U2Nyb2xsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50OiBFbGVtZW50KTogbnVtYmVyIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiAoXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArXG4gICAgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnRcbiAgKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShcbiAgZWxlbWVudDogRWxlbWVudFxuKTogQ1NTU3R5bGVEZWNsYXJhdGlvbiB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIGNvbnN0IHsgb3ZlcmZsb3csIG92ZXJmbG93WCwgb3ZlcmZsb3dZIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QsIFZpcnR1YWxFbGVtZW50LCBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gJy4vZ2V0Tm9kZVNjcm9sbCc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gJy4vZ2V0V2luZG93U2Nyb2xsQmFyWCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tICcuL2lzU2Nyb2xsUGFyZW50JztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIGNvbnN0IHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG5cbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59XG5cbi8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoXG4gIGVsZW1lbnRPclZpcnR1YWxFbGVtZW50OiBFbGVtZW50IHwgVmlydHVhbEVsZW1lbnQsXG4gIG9mZnNldFBhcmVudDogRWxlbWVudCB8IFdpbmRvdyxcbiAgaXNGaXhlZDogYm9vbGVhbiA9IGZhbHNlXG4pOiBSZWN0IHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IG9mZnNldFBhcmVudElzU2NhbGVkID1cbiAgICBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KFxuICAgIGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LFxuICAgIG9mZnNldFBhcmVudElzU2NhbGVkLFxuICAgIGlzRml4ZWRcbiAgKTtcblxuICBsZXQgc2Nyb2xsID0geyBzY3JvbGxMZWZ0OiAwLCBzY3JvbGxUb3A6IDAgfTtcbiAgbGV0IG9mZnNldHMgPSB7IHg6IDAsIHk6IDAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgKCFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkpIHtcbiAgICBpZiAoXG4gICAgICBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KVxuICAgICkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcblxuLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBSZWN0IHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcblxuICAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG4gIGxldCB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQ6IE5vZGUgfCBTaGFkb3dSb290KTogTm9kZSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG4gICk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tICcuL2lzU2Nyb2xsUGFyZW50JztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZTogTm9kZSk6IEhUTUxFbGVtZW50IHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tICcuL2dldFNjcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgdHlwZSB7IFdpbmRvdywgVmlzdWFsVmlld3BvcnQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSAnLi9pc1Njcm9sbFBhcmVudCc7XG5cbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoXG4gIGVsZW1lbnQ6IE5vZGUsXG4gIGxpc3Q6IEFycmF5PEVsZW1lbnQgfCBXaW5kb3c+ID0gW11cbik6IEFycmF5PEVsZW1lbnQgfCBXaW5kb3cgfCBWaXN1YWxWaWV3cG9ydD4ge1xuICBjb25zdCBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gZWxlbWVudC5vd25lckRvY3VtZW50Py5ib2R5O1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgY29uc3QgdGFyZ2V0ID0gaXNCb2R5XG4gICAgPyBbd2luXS5jb25jYXQoXG4gICAgICAgIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSxcbiAgICAgICAgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdXG4gICAgICApXG4gICAgOiBzY3JvbGxQYXJlbnQ7XG4gIGNvbnN0IHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcblxuICByZXR1cm4gaXNCb2R5XG4gICAgPyB1cGRhdGVkTGlzdFxuICAgIDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gICAgICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogYm9vbGVhbiB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZ2V0Q29tcHV0ZWRTdHlsZSc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gJy4vaXNUYWJsZUVsZW1lbnQnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tICcuLi91dGlscy91c2VyQWdlbnQnO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiA/RWxlbWVudCB7XG4gIGlmIChcbiAgICAhaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gICAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJ1xuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn1cblxuLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgY29uc3QgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICBjb25zdCBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgY29uc3QgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoXG4gICAgaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiZcbiAgICBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDBcbiAgKSB7XG4gICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG5cbiAgICAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gICAgaWYgKFxuICAgICAgY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8XG4gICAgICBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fFxuICAgICAgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHxcbiAgICAgIFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8XG4gICAgICAoaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJykgfHxcbiAgICAgIChpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50OiBFbGVtZW50KSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcblxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAoXG4gICAgb2Zmc2V0UGFyZW50ICYmXG4gICAgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJlxuICAgIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYydcbiAgKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKFxuICAgIG9mZnNldFBhcmVudCAmJlxuICAgIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHxcbiAgICAgIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiZcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpXG4gICkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGNvbnN0IHRvcDogJ3RvcCcgPSAndG9wJztcbmV4cG9ydCBjb25zdCBib3R0b206ICdib3R0b20nID0gJ2JvdHRvbSc7XG5leHBvcnQgY29uc3QgcmlnaHQ6ICdyaWdodCcgPSAncmlnaHQnO1xuZXhwb3J0IGNvbnN0IGxlZnQ6ICdsZWZ0JyA9ICdsZWZ0JztcbmV4cG9ydCBjb25zdCBhdXRvOiAnYXV0bycgPSAnYXV0byc7XG5leHBvcnQgdHlwZSBCYXNlUGxhY2VtZW50ID1cbiAgfCB0eXBlb2YgdG9wXG4gIHwgdHlwZW9mIGJvdHRvbVxuICB8IHR5cGVvZiByaWdodFxuICB8IHR5cGVvZiBsZWZ0O1xuZXhwb3J0IGNvbnN0IGJhc2VQbGFjZW1lbnRzOiBBcnJheTxCYXNlUGxhY2VtZW50PiA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuXG5leHBvcnQgY29uc3Qgc3RhcnQ6ICdzdGFydCcgPSAnc3RhcnQnO1xuZXhwb3J0IGNvbnN0IGVuZDogJ2VuZCcgPSAnZW5kJztcbmV4cG9ydCB0eXBlIFZhcmlhdGlvbiA9IHR5cGVvZiBzdGFydCB8IHR5cGVvZiBlbmQ7XG5cbmV4cG9ydCBjb25zdCBjbGlwcGluZ1BhcmVudHM6ICdjbGlwcGluZ1BhcmVudHMnID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgY29uc3Qgdmlld3BvcnQ6ICd2aWV3cG9ydCcgPSAndmlld3BvcnQnO1xuZXhwb3J0IHR5cGUgQm91bmRhcnkgPSBFbGVtZW50IHwgQXJyYXk8RWxlbWVudD4gfCB0eXBlb2YgY2xpcHBpbmdQYXJlbnRzO1xuZXhwb3J0IHR5cGUgUm9vdEJvdW5kYXJ5ID0gdHlwZW9mIHZpZXdwb3J0IHwgJ2RvY3VtZW50JztcblxuZXhwb3J0IGNvbnN0IHBvcHBlcjogJ3BvcHBlcicgPSAncG9wcGVyJztcbmV4cG9ydCBjb25zdCByZWZlcmVuY2U6ICdyZWZlcmVuY2UnID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdHlwZSBDb250ZXh0ID0gdHlwZW9mIHBvcHBlciB8IHR5cGVvZiByZWZlcmVuY2U7XG5cbmV4cG9ydCB0eXBlIFZhcmlhdGlvblBsYWNlbWVudCA9XG4gIHwgJ3RvcC1zdGFydCdcbiAgfCAndG9wLWVuZCdcbiAgfCAnYm90dG9tLXN0YXJ0J1xuICB8ICdib3R0b20tZW5kJ1xuICB8ICdyaWdodC1zdGFydCdcbiAgfCAncmlnaHQtZW5kJ1xuICB8ICdsZWZ0LXN0YXJ0J1xuICB8ICdsZWZ0LWVuZCc7XG5leHBvcnQgdHlwZSBBdXRvUGxhY2VtZW50ID0gJ2F1dG8nIHwgJ2F1dG8tc3RhcnQnIHwgJ2F1dG8tZW5kJztcbmV4cG9ydCB0eXBlIENvbXB1dGVkUGxhY2VtZW50ID0gVmFyaWF0aW9uUGxhY2VtZW50IHwgQmFzZVBsYWNlbWVudDtcbmV4cG9ydCB0eXBlIFBsYWNlbWVudCA9IEF1dG9QbGFjZW1lbnQgfCBCYXNlUGxhY2VtZW50IHwgVmFyaWF0aW9uUGxhY2VtZW50O1xuXG5leHBvcnQgY29uc3QgdmFyaWF0aW9uUGxhY2VtZW50czogQXJyYXk8VmFyaWF0aW9uUGxhY2VtZW50PiA9IGJhc2VQbGFjZW1lbnRzLnJlZHVjZShcbiAgKGFjYzogQXJyYXk8VmFyaWF0aW9uUGxhY2VtZW50PiwgcGxhY2VtZW50OiBCYXNlUGxhY2VtZW50KSA9PlxuICAgIGFjYy5jb25jYXQoWyhgJHtwbGFjZW1lbnR9LSR7c3RhcnR9YDogYW55KSwgKGAke3BsYWNlbWVudH0tJHtlbmR9YDogYW55KV0pLFxuICBbXVxuKTtcbmV4cG9ydCBjb25zdCBwbGFjZW1lbnRzOiBBcnJheTxQbGFjZW1lbnQ+ID0gWy4uLmJhc2VQbGFjZW1lbnRzLCBhdXRvXS5yZWR1Y2UoXG4gIChcbiAgICBhY2M6IEFycmF5PFBsYWNlbWVudD4sXG4gICAgcGxhY2VtZW50OiBCYXNlUGxhY2VtZW50IHwgdHlwZW9mIGF1dG9cbiAgKTogQXJyYXk8UGxhY2VtZW50PiA9PlxuICAgIGFjYy5jb25jYXQoW1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgKGAke3BsYWNlbWVudH0tJHtzdGFydH1gOiBhbnkpLFxuICAgICAgKGAke3BsYWNlbWVudH0tJHtlbmR9YDogYW55KSxcbiAgICBdKSxcbiAgW11cbik7XG5cbi8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5leHBvcnQgY29uc3QgYmVmb3JlUmVhZDogJ2JlZm9yZVJlYWQnID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IGNvbnN0IHJlYWQ6ICdyZWFkJyA9ICdyZWFkJztcbmV4cG9ydCBjb25zdCBhZnRlclJlYWQ6ICdhZnRlclJlYWQnID0gJ2FmdGVyUmVhZCc7XG4vLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuZXhwb3J0IGNvbnN0IGJlZm9yZU1haW46ICdiZWZvcmVNYWluJyA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCBjb25zdCBtYWluOiAnbWFpbicgPSAnbWFpbic7XG5leHBvcnQgY29uc3QgYWZ0ZXJNYWluOiAnYWZ0ZXJNYWluJyA9ICdhZnRlck1haW4nO1xuLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuZXhwb3J0IGNvbnN0IGJlZm9yZVdyaXRlOiAnYmVmb3JlV3JpdGUnID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCBjb25zdCB3cml0ZTogJ3dyaXRlJyA9ICd3cml0ZSc7XG5leHBvcnQgY29uc3QgYWZ0ZXJXcml0ZTogJ2FmdGVyV3JpdGUnID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IGNvbnN0IG1vZGlmaWVyUGhhc2VzOiBBcnJheTxNb2RpZmllclBoYXNlcz4gPSBbXG4gIGJlZm9yZVJlYWQsXG4gIHJlYWQsXG4gIGFmdGVyUmVhZCxcbiAgYmVmb3JlTWFpbixcbiAgbWFpbixcbiAgYWZ0ZXJNYWluLFxuICBiZWZvcmVXcml0ZSxcbiAgd3JpdGUsXG4gIGFmdGVyV3JpdGUsXG5dO1xuXG5leHBvcnQgdHlwZSBNb2RpZmllclBoYXNlcyA9XG4gIHwgdHlwZW9mIGJlZm9yZVJlYWRcbiAgfCB0eXBlb2YgcmVhZFxuICB8IHR5cGVvZiBhZnRlclJlYWRcbiAgfCB0eXBlb2YgYmVmb3JlTWFpblxuICB8IHR5cGVvZiBtYWluXG4gIHwgdHlwZW9mIGFmdGVyTWFpblxuICB8IHR5cGVvZiBiZWZvcmVXcml0ZVxuICB8IHR5cGVvZiB3cml0ZVxuICB8IHR5cGVvZiBhZnRlcldyaXRlO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gJy4uL2VudW1zJztcblxuLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4ge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTtcblxuICAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXI6IE1vZGlmaWVyPGFueSwgYW55Pikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuXG4gICAgY29uc3QgcmVxdWlyZXMgPSBbXG4gICAgICAuLi4obW9kaWZpZXIucmVxdWlyZXMgfHwgW10pLFxuICAgICAgLi4uKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pLFxuICAgIF07XG5cbiAgICByZXF1aXJlcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgY29uc3QgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMoXG4gIG1vZGlmaWVyczogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PlxuKTogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PiB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICBjb25zdCBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTtcblxuICAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKChhY2MsIHBoYXNlKSA9PiB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihtb2RpZmllciA9PiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2UpXG4gICAgKTtcbiAgfSwgW10pO1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2U8VD4oZm46IEZ1bmN0aW9uKTogKCkgPT4gUHJvbWlzZTxUPiB7XG4gIGxldCBwZW5kaW5nO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlPFQ+KHJlc29sdmUgPT4ge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUoXG4gIG1vZGlmaWVyczogQXJyYXk8JFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+XG4pOiBBcnJheTwkU2hhcGU8TW9kaWZpZXI8YW55LCBhbnk+Pj4ge1xuICBjb25zdCBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKChtZXJnZWQsIGN1cnJlbnQpID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmdcbiAgICAgID8ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICAgIC4uLmN1cnJlbnQsXG4gICAgICAgICAgb3B0aW9uczogeyAuLi5leGlzdGluZy5vcHRpb25zLCAuLi5jdXJyZW50Lm9wdGlvbnMgfSxcbiAgICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nLmRhdGEsIC4uLmN1cnJlbnQuZGF0YSB9LFxuICAgICAgICB9XG4gICAgICA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pO1xuXG4gIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChrZXkgPT4gbWVyZ2VkW2tleV0pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSAnLi9pc0xheW91dFZpZXdwb3J0JztcbmltcG9ydCB0eXBlIHsgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG5cbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcblxuICAgIGNvbnN0IGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICghbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeSxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZ2V0Q29tcHV0ZWRTdHlsZSc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbCc7XG5pbXBvcnQgeyBtYXggfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogUmVjdCB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudD8uYm9keTtcblxuICBjb25zdCB3aWR0aCA9IG1heChcbiAgICBodG1sLnNjcm9sbFdpZHRoLFxuICAgIGh0bWwuY2xpZW50V2lkdGgsXG4gICAgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLFxuICAgIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMFxuICApO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoXG4gICAgaHRtbC5zY3JvbGxIZWlnaHQsXG4gICAgaHRtbC5jbGllbnRIZWlnaHQsXG4gICAgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCxcbiAgICBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwXG4gICk7XG5cbiAgbGV0IHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudDogRWxlbWVudCwgY2hpbGQ6IEVsZW1lbnQpIHtcbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICBkbyB7XG4gICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH0gd2hpbGUgKG5leHQpO1xuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBSZWN0LCBDbGllbnRSZWN0T2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3Q6IFJlY3QpOiBDbGllbnRSZWN0T2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2xpZW50UmVjdE9iamVjdCwgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgQm91bmRhcnksIFJvb3RCb3VuZGFyeSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tICcuL2dldFZpZXdwb3J0UmVjdCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gJy4vZ2V0RG9jdW1lbnRSZWN0JztcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tICcuL2xpc3RTY3JvbGxQYXJlbnRzJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBjb250YWlucyBmcm9tICcuL2NvbnRhaW5zJztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QnO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIHN0cmF0ZWd5OiBQb3NpdGlvbmluZ1N0cmF0ZWd5XG4pIHtcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuXG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcblxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNsaXBwaW5nUGFyZW50OiBFbGVtZW50IHwgUm9vdEJvdW5kYXJ5LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKTogQ2xpZW50UmVjdE9iamVjdCB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnRcbiAgICA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSlcbiAgICA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudClcbiAgICA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSlcbiAgICA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50OiBFbGVtZW50KTogQXJyYXk8RWxlbWVudD4ge1xuICBjb25zdCBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgY29uc3QgY2FuRXNjYXBlQ2xpcHBpbmcgPVxuICAgIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIGNvbnN0IGNsaXBwZXJFbGVtZW50ID1cbiAgICBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpXG4gICAgICA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KVxuICAgICAgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKFxuICAgIChjbGlwcGluZ1BhcmVudCkgPT5cbiAgICAgIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiZcbiAgICAgIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiZcbiAgICAgIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknXG4gICk7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgYm91bmRhcnk6IEJvdW5kYXJ5LFxuICByb290Qm91bmRhcnk6IFJvb3RCb3VuZGFyeSxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3lcbik6IENsaWVudFJlY3RPYmplY3Qge1xuICBjb25zdCBtYWluQ2xpcHBpbmdQYXJlbnRzID1cbiAgICBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cydcbiAgICAgID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpXG4gICAgICA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nUGFyZW50cyA9IFsuLi5tYWluQ2xpcHBpbmdQYXJlbnRzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuXG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG5cbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuXG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG5cbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuXG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdHlwZSBCYXNlUGxhY2VtZW50LCB0eXBlIFBsYWNlbWVudCwgYXV0byB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnQgfCB0eXBlb2YgYXV0b1xuKTogQmFzZVBsYWNlbWVudCB7XG4gIHJldHVybiAocGxhY2VtZW50LnNwbGl0KCctJylbMF06IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdHlwZSBWYXJpYXRpb24sIHR5cGUgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50OiBQbGFjZW1lbnQpOiA/VmFyaWF0aW9uIHtcbiAgcmV0dXJuIChwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTogYW55KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudFxuKTogJ3gnIHwgJ3knIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4vZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4vZ2V0VmFyaWF0aW9uJztcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSAnLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQnO1xuaW1wb3J0IHR5cGUge1xuICBSZWN0LFxuICBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBPZmZzZXRzLFxuICBDbGllbnRSZWN0T2JqZWN0LFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQsIHR5cGUgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh7XG4gIHJlZmVyZW5jZSxcbiAgZWxlbWVudCxcbiAgcGxhY2VtZW50LFxufToge1xuICByZWZlcmVuY2U6IFJlY3QgfCBDbGllbnRSZWN0T2JqZWN0LFxuICBlbGVtZW50OiBSZWN0IHwgQ2xpZW50UmVjdE9iamVjdCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIHBsYWNlbWVudD86IFBsYWNlbWVudCxcbn0pOiBPZmZzZXRzIHtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIGNvbnN0IHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcblxuICBsZXQgb2Zmc2V0cztcbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWSxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vblksXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueSxcbiAgICAgIH07XG4gIH1cblxuICBjb25zdCBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnRcbiAgICA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KVxuICAgIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPVxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9XG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFNpZGVPYmplY3QgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTaWRlT2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tICcuL2dldEZyZXNoU2lkZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChcbiAgcGFkZGluZ09iamVjdDogJFNoYXBlPFNpZGVPYmplY3Q+XG4pOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5nZXRGcmVzaFNpZGVPYmplY3QoKSxcbiAgICAuLi5wYWRkaW5nT2JqZWN0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwPFxuICBUOiBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuLFxuICBLOiBzdHJpbmdcbj4odmFsdWU6IFQsIGtleXM6IEFycmF5PEs+KTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGhhc2hNYXAsIGtleSkgPT4ge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSwgU2lkZU9iamVjdCwgUGFkZGluZywgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50LCBCb3VuZGFyeSwgUm9vdEJvdW5kYXJ5LCBDb250ZXh0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gJy4vY29tcHV0ZU9mZnNldHMnO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSAnLi9yZWN0VG9DbGllbnRSZWN0JztcbmltcG9ydCB7XG4gIGNsaXBwaW5nUGFyZW50cyxcbiAgcmVmZXJlbmNlLFxuICBwb3BwZXIsXG4gIGJvdHRvbSxcbiAgdG9wLFxuICByaWdodCxcbiAgYmFzZVBsYWNlbWVudHMsXG4gIHZpZXdwb3J0LFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gJy4vbWVyZ2VQYWRkaW5nT2JqZWN0JztcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSAnLi9leHBhbmRUb0hhc2hNYXAnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIGVsZW1lbnRDb250ZXh0OiBDb250ZXh0LFxuICBhbHRCb3VuZGFyeTogYm9vbGVhbixcbiAgcGFkZGluZzogUGFkZGluZyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KFxuICBzdGF0ZTogU3RhdGUsXG4gIG9wdGlvbnM6ICRTaGFwZTxPcHRpb25zPiA9IHt9XG4pOiBTaWRlT2JqZWN0IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9IHN0YXRlLnBsYWNlbWVudCxcbiAgICBzdHJhdGVneSA9IHN0YXRlLnN0cmF0ZWd5LFxuICAgIGJvdW5kYXJ5ID0gY2xpcHBpbmdQYXJlbnRzLFxuICAgIHJvb3RCb3VuZGFyeSA9IHZpZXdwb3J0LFxuICAgIGVsZW1lbnRDb250ZXh0ID0gcG9wcGVyLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDAsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QoXG4gICAgdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInXG4gICAgICA/IHBhZGRpbmdcbiAgICAgIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKVxuICApO1xuXG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuXG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG5cbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KFxuICAgIGlzRWxlbWVudChlbGVtZW50KVxuICAgICAgPyBlbGVtZW50XG4gICAgICA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gICk7XG5cbiAgY29uc3QgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuXG4gIGNvbnN0IHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50LFxuICB9KTtcblxuICBjb25zdCBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgLi4ucG9wcGVyUmVjdCxcbiAgICAuLi5wb3BwZXJPZmZzZXRzLFxuICB9KTtcblxuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9XG4gICAgZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0O1xuXG4gIC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuICBjb25zdCBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOlxuICAgICAgZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC1cbiAgICAgIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gK1xuICAgICAgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OlxuICAgICAgZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0LFxuICB9O1xuXG4gIGNvbnN0IG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG5cbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICBjb25zdCBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIFN0YXRlLFxuICBPcHRpb25zR2VuZXJpYyxcbiAgTW9kaWZpZXIsXG4gIEluc3RhbmNlLFxuICBWaXJ0dWFsRWxlbWVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tICcuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0JztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4vZG9tLXV0aWxzL2dldExheW91dFJlY3QnO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gJy4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tICcuL3V0aWxzL29yZGVyTW9kaWZpZXJzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tICcuL3V0aWxzL21lcmdlQnlOYW1lJztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuL3V0aWxzL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vZG9tLXV0aWxzL2luc3RhbmNlT2YnO1xuXG5jb25zdCBERUZBVUxUX09QVElPTlM6IE9wdGlvbnNHZW5lcmljPGFueT4gPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxufTtcblxudHlwZSBQb3BwZXJHZW5lcmF0b3JBcmdzID0ge1xuICBkZWZhdWx0TW9kaWZpZXJzPzogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PixcbiAgZGVmYXVsdE9wdGlvbnM/OiAkU2hhcGU8T3B0aW9uc0dlbmVyaWM8YW55Pj4sXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKC4uLmFyZ3M6IEFycmF5PGFueT4pOiBib29sZWFuIHtcbiAgcmV0dXJuICFhcmdzLnNvbWUoXG4gICAgKGVsZW1lbnQpID0+XG4gICAgICAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnM6IFBvcHBlckdlbmVyYXRvckFyZ3MgPSB7fSkge1xuICBjb25zdCB7IGRlZmF1bHRNb2RpZmllcnMgPSBbXSwgZGVmYXVsdE9wdGlvbnMgPSBERUZBVUxUX09QVElPTlMgfSA9XG4gICAgZ2VuZXJhdG9yT3B0aW9ucztcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyPFRNb2RpZmllcjogJFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+KFxuICAgIHJlZmVyZW5jZTogRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50LFxuICAgIHBvcHBlcjogSFRNTEVsZW1lbnQsXG4gICAgb3B0aW9uczogJFNoYXBlPE9wdGlvbnNHZW5lcmljPFRNb2RpZmllcj4+ID0gZGVmYXVsdE9wdGlvbnNcbiAgKTogSW5zdGFuY2Uge1xuICAgIGxldCBzdGF0ZTogJFNoYXBlPFN0YXRlPiA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5kZWZhdWx0T3B0aW9ucyB9LFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcixcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgfTtcblxuICAgIGxldCBlZmZlY3RDbGVhbnVwRm5zOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICAgIGxldCBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICBjb25zdCBvcHRpb25zID1cbiAgICAgICAgICB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpXG4gICAgICAgICAgICA6IHNldE9wdGlvbnNBY3Rpb247XG5cbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuXG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtleHBvbmVudGlhbC1zcHJlYWRdXG4gICAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgICAgLi4uc3RhdGUub3B0aW9ucyxcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKVxuICAgICAgICAgICAgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpXG4gICAgICAgICAgICA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudFxuICAgICAgICAgICAgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpXG4gICAgICAgICAgICA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICBjb25zdCBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMoXG4gICAgICAgICAgbWVyZ2VCeU5hbWUoWy4uLmRlZmF1bHRNb2RpZmllcnMsIC4uLnN0YXRlLm9wdGlvbnMubW9kaWZpZXJzXSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcigobSkgPT4gbS5lbmFibGVkKTtcblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyByZWZlcmVuY2UsIHBvcHBlciB9ID0gc3RhdGUuZWxlbWVudHM7XG5cbiAgICAgICAgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QoXG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSxcbiAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgICAgICAgICApLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKFxuICAgICAgICAgIChtb2RpZmllcikgPT5cbiAgICAgICAgICAgIChzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0ge1xuICAgICAgICAgICAgICAuLi5tb2RpZmllci5kYXRhLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBmbiwgb3B0aW9ucyA9IHt9LCBuYW1lIH0gPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSwgaW5zdGFuY2UgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZTwkU2hhcGU8U3RhdGU+PihcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICBuZXcgUHJvbWlzZTwkU2hhcGU8U3RhdGU+PigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICAgIH0pXG4gICAgICApLFxuXG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKCh7IG5hbWUsIG9wdGlvbnMgPSB7fSwgZWZmZWN0IH0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlZmZlY3QoeyBzdGF0ZSwgbmFtZSwgaW5zdGFuY2UsIG9wdGlvbnMgfSk7XG4gICAgICAgICAgY29uc3Qgbm9vcEZuID0gKCkgPT4ge307XG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUG9wcGVyID0gcG9wcGVyR2VuZXJhdG9yKCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4uL2RvbS11dGlscy9nZXRXaW5kb3cnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBzY3JvbGw6IGJvb2xlYW4sXG4gIHJlc2l6ZTogYm9vbGVhbixcbn07XG5cbmNvbnN0IHBhc3NpdmUgPSB7IHBhc3NpdmU6IHRydWUgfTtcblxuZnVuY3Rpb24gZWZmZWN0KHsgc3RhdGUsIGluc3RhbmNlLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IHsgc2Nyb2xsID0gdHJ1ZSwgcmVzaXplID0gdHJ1ZSB9ID0gb3B0aW9ucztcblxuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgY29uc3Qgc2Nyb2xsUGFyZW50cyA9IFtcbiAgICAuLi5zdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSxcbiAgICAuLi5zdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcixcbiAgXTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKHNjcm9sbFBhcmVudCA9PiB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKHNjcm9sbFBhcmVudCA9PiB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBFdmVudExpc3RlbmVyc01vZGlmaWVyID0gTW9kaWZpZXI8J2V2ZW50TGlzdGVuZXJzJywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46ICgpID0+IHt9LFxuICBlZmZlY3QsXG4gIGRhdGE6IHt9LFxufTogRXZlbnRMaXN0ZW5lcnNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSAnLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMnO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKHsgc3RhdGUsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50LFxuICB9KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgUG9wcGVyT2Zmc2V0c01vZGlmaWVyID0gTW9kaWZpZXI8J3BvcHBlck9mZnNldHMnLCB7fHx9PjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9LFxufTogUG9wcGVyT2Zmc2V0c01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIE9mZnNldHMsXG4gIE1vZGlmaWVyLFxuICBNb2RpZmllckFyZ3VtZW50cyxcbiAgUmVjdCxcbiAgV2luZG93LFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICB0eXBlIEJhc2VQbGFjZW1lbnQsXG4gIHR5cGUgVmFyaWF0aW9uLFxuICB0b3AsXG4gIGxlZnQsXG4gIHJpZ2h0LFxuICBib3R0b20sXG4gIGVuZCxcbn0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi4vZG9tLXV0aWxzL2dldFdpbmRvdyc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSAnLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4uL3V0aWxzL2dldFZhcmlhdGlvbic7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzL21hdGgnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBSb3VuZE9mZnNldHMgPSAoXG4gIG9mZnNldHM6ICRTaGFwZTx7IHg6IG51bWJlciwgeTogbnVtYmVyLCBjZW50ZXJPZmZzZXQ6IG51bWJlciB9PlxuKSA9PiBPZmZzZXRzO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBncHVBY2NlbGVyYXRpb246IGJvb2xlYW4sXG4gIGFkYXB0aXZlOiBib29sZWFuLFxuICByb3VuZE9mZnNldHM/OiBib29sZWFuIHwgUm91bmRPZmZzZXRzLFxufTtcblxuY29uc3QgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bycsXG59O1xuXG4vLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoeyB4LCB5IH0sIHdpbjogV2luZG93KTogT2Zmc2V0cyB7XG4gIGNvbnN0IGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDAsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyh7XG4gIHBvcHBlcixcbiAgcG9wcGVyUmVjdCxcbiAgcGxhY2VtZW50LFxuICB2YXJpYXRpb24sXG4gIG9mZnNldHMsXG4gIHBvc2l0aW9uLFxuICBncHVBY2NlbGVyYXRpb24sXG4gIGFkYXB0aXZlLFxuICByb3VuZE9mZnNldHMsXG4gIGlzRml4ZWQsXG59OiB7XG4gIHBvcHBlcjogSFRNTEVsZW1lbnQsXG4gIHBvcHBlclJlY3Q6IFJlY3QsXG4gIHBsYWNlbWVudDogQmFzZVBsYWNlbWVudCxcbiAgdmFyaWF0aW9uOiA/VmFyaWF0aW9uLFxuICBvZmZzZXRzOiAkU2hhcGU8eyB4OiBudW1iZXIsIHk6IG51bWJlciwgY2VudGVyT2Zmc2V0OiBudW1iZXIgfT4sXG4gIHBvc2l0aW9uOiBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBncHVBY2NlbGVyYXRpb246IGJvb2xlYW4sXG4gIGFkYXB0aXZlOiBib29sZWFuLFxuICByb3VuZE9mZnNldHM6IGJvb2xlYW4gfCBSb3VuZE9mZnNldHMsXG4gIGlzRml4ZWQ6IGJvb2xlYW4sXG59KSB7XG4gIGxldCB7IHggPSAwLCB5ID0gMCB9ID0gb2Zmc2V0cztcblxuICAoeyB4LCB5IH0gPVxuICAgIHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoeyB4LCB5IH0pIDogeyB4LCB5IH0pO1xuXG4gIGNvbnN0IGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIGNvbnN0IGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG5cbiAgbGV0IHNpZGVYOiBzdHJpbmcgPSBsZWZ0O1xuICBsZXQgc2lkZVk6IHN0cmluZyA9IHRvcDtcblxuICBjb25zdCB3aW46IFdpbmRvdyA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgbGV0IGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICBsZXQgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKFxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmXG4gICAgICAgIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnXG4gICAgICApIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuICAgIG9mZnNldFBhcmVudCA9IChvZmZzZXRQYXJlbnQ6IEVsZW1lbnQpO1xuXG4gICAgaWYgKFxuICAgICAgcGxhY2VtZW50ID09PSB0b3AgfHxcbiAgICAgICgocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKVxuICAgICkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICBjb25zdCBvZmZzZXRZID1cbiAgICAgICAgaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnRcbiAgICAgICAgICA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHRcbiAgICAgICAgICA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwbGFjZW1lbnQgPT09IGxlZnQgfHxcbiAgICAgICgocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKVxuICAgICkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIGNvbnN0IG9mZnNldFggPVxuICAgICAgICBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydFxuICAgICAgICAgID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoXG4gICAgICAgICAgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbW1vblN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbixcbiAgICAuLi4oYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyksXG4gIH07XG5cbiAgKHsgeCwgeSB9ID1cbiAgICByb3VuZE9mZnNldHMgPT09IHRydWVcbiAgICAgID8gcm91bmRPZmZzZXRzQnlEUFIoeyB4LCB5IH0sIGdldFdpbmRvdyhwb3BwZXIpKVxuICAgICAgOiB7IHgsIHkgfSk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICBbc2lkZVldOiBoYXNZID8gJzAnIDogJycsXG4gICAgICBbc2lkZVhdOiBoYXNYID8gJzAnIDogJycsXG4gICAgICAvLyBMYXllciBhY2NlbGVyYXRpb24gY2FuIGRpc2FibGUgc3VicGl4ZWwgcmVuZGVyaW5nIHdoaWNoIGNhdXNlcyBzbGlnaHRseVxuICAgICAgLy8gYmx1cnJ5IHRleHQgb24gbG93IFBQSSBkaXNwbGF5cywgc28gd2Ugd2FudCB0byB1c2UgMkQgdHJhbnNmb3Jtc1xuICAgICAgLy8gaW5zdGVhZFxuICAgICAgdHJhbnNmb3JtOlxuICAgICAgICAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMVxuICAgICAgICAgID8gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgXG4gICAgICAgICAgOiBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgW3NpZGVZXTogaGFzWSA/IGAke3l9cHhgIDogJycsXG4gICAgW3NpZGVYXTogaGFzWCA/IGAke3h9cHhgIDogJycsXG4gICAgdHJhbnNmb3JtOiAnJyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyh7IHN0YXRlLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IHtcbiAgICBncHVBY2NlbGVyYXRpb24gPSB0cnVlLFxuICAgIGFkYXB0aXZlID0gdHJ1ZSxcbiAgICAvLyBkZWZhdWx0cyB0byB1c2UgYnVpbHRpbiBgcm91bmRPZmZzZXRzQnlEUFJgXG4gICAgcm91bmRPZmZzZXRzID0gdHJ1ZSxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnLFxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSB7XG4gICAgICAuLi5zdGF0ZS5zdHlsZXMucG9wcGVyLFxuICAgICAgLi4ubWFwVG9TdHlsZXMoe1xuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIGFkYXB0aXZlLFxuICAgICAgICByb3VuZE9mZnNldHMsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IHtcbiAgICAgIC4uLnN0YXRlLnN0eWxlcy5hcnJvdyxcbiAgICAgIC4uLm1hcFRvU3R5bGVzKHtcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgICByb3VuZE9mZnNldHMsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSB7XG4gICAgLi4uc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsXG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudCxcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgQ29tcHV0ZVN0eWxlc01vZGlmaWVyID0gTW9kaWZpZXI8J2NvbXB1dGVTdHlsZXMnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fSxcbn06IENvbXB1dGVTdHlsZXNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciwgTW9kaWZpZXJBcmd1bWVudHMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5cbi8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKHsgc3RhdGUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcblxuICAgIC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSB9OiBNb2RpZmllckFyZ3VtZW50czx7fHx9Pikge1xuICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnLFxuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fSxcbiAgfTtcblxuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG5cbiAgICAgIGNvbnN0IHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKFxuICAgICAgICBzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICA/IHN0YXRlLnN0eWxlc1tuYW1lXVxuICAgICAgICAgIDogaW5pdGlhbFN0eWxlc1tuYW1lXVxuICAgICAgKTtcblxuICAgICAgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cbiAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZSgoc3R5bGUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBBcHBseVN0eWxlc01vZGlmaWVyID0gTW9kaWZpZXI8J2FwcGx5U3R5bGVzJywge3x8fT47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXSxcbn06IEFwcGx5U3R5bGVzTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIsIFJlY3QsIE9mZnNldHMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tICcuLi9lbnVtcyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9mZnNldHNGdW5jdGlvbiA9ICh7XG4gIHBvcHBlcjogUmVjdCxcbiAgcmVmZXJlbmNlOiBSZWN0LFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbn0pID0+IFs/bnVtYmVyLCA/bnVtYmVyXTtcblxudHlwZSBPZmZzZXQgPSBPZmZzZXRzRnVuY3Rpb24gfCBbP251bWJlciwgP251bWJlcl07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIG9mZnNldDogT2Zmc2V0LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgcmVjdHM6IHsgcG9wcGVyOiBSZWN0LCByZWZlcmVuY2U6IFJlY3QgfSxcbiAgb2Zmc2V0OiBPZmZzZXRcbik6IE9mZnNldHMge1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICBsZXQgW3NraWRkaW5nLCBkaXN0YW5jZV0gPVxuICAgIHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gb2Zmc2V0KHtcbiAgICAgICAgICAuLi5yZWN0cyxcbiAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIH0pXG4gICAgICA6IG9mZnNldDtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG5cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwXG4gICAgPyB7IHg6IGRpc3RhbmNlLCB5OiBza2lkZGluZyB9XG4gICAgOiB7IHg6IHNraWRkaW5nLCB5OiBkaXN0YW5jZSB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7IG9mZnNldCA9IFswLCAwXSB9ID0gb3B0aW9ucztcblxuICBjb25zdCBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoKGFjYywgcGxhY2VtZW50KSA9PiB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBjb25zdCB7IHgsIHkgfSA9IGRhdGFbc3RhdGUucGxhY2VtZW50XTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT2Zmc2V0TW9kaWZpZXIgPSBNb2RpZmllcjwnb2Zmc2V0JywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0LFxufTogT2Zmc2V0TW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5jb25zdCBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudDogUGxhY2VtZW50KTogUGxhY2VtZW50IHtcbiAgcmV0dXJuIChwbGFjZW1lbnQucmVwbGFjZShcbiAgICAvbGVmdHxyaWdodHxib3R0b218dG9wL2csXG4gICAgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdXG4gICk6IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5cbmNvbnN0IGhhc2ggPSB7IHN0YXJ0OiAnZW5kJywgZW5kOiAnc3RhcnQnIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudFxuKTogUGxhY2VtZW50IHtcbiAgcmV0dXJuIChwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIG1hdGNoZWQgPT4gaGFzaFttYXRjaGVkXSk6IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSwgUGFkZGluZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgUGxhY2VtZW50LFxuICBDb21wdXRlZFBsYWNlbWVudCxcbiAgQm91bmRhcnksXG4gIFJvb3RCb3VuZGFyeSxcbn0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuL2dldFZhcmlhdGlvbic7XG5pbXBvcnQge1xuICB2YXJpYXRpb25QbGFjZW1lbnRzLFxuICBiYXNlUGxhY2VtZW50cyxcbiAgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzLFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi9kZXRlY3RPdmVyZmxvdyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuL2dldEJhc2VQbGFjZW1lbnQnO1xuXG50eXBlIE9wdGlvbnMgPSB7XG4gIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICBwYWRkaW5nOiBQYWRkaW5nLFxuICBib3VuZGFyeTogQm91bmRhcnksXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICBmbGlwVmFyaWF0aW9uczogYm9vbGVhbixcbiAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzPzogQXJyYXk8UGxhY2VtZW50Pixcbn07XG5cbnR5cGUgT3ZlcmZsb3dzTWFwID0geyBbQ29tcHV0ZWRQbGFjZW1lbnRdOiBudW1iZXIgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoXG4gIHN0YXRlOiAkU2hhcGU8U3RhdGU+LFxuICBvcHRpb25zOiBPcHRpb25zID0ge31cbik6IEFycmF5PENvbXB1dGVkUGxhY2VtZW50PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmcsXG4gICAgZmxpcFZhcmlhdGlvbnMsXG4gICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gYWxsUGxhY2VtZW50cyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG5cbiAgY29uc3QgcGxhY2VtZW50cyA9IHZhcmlhdGlvblxuICAgID8gZmxpcFZhcmlhdGlvbnNcbiAgICAgID8gdmFyaWF0aW9uUGxhY2VtZW50c1xuICAgICAgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihcbiAgICAgICAgICAocGxhY2VtZW50KSA9PiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uXG4gICAgICAgIClcbiAgICA6IGJhc2VQbGFjZW1lbnRzO1xuXG4gIGxldCBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKFxuICAgIChwbGFjZW1lbnQpID0+IGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMFxuICApO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIH1cblxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuICBjb25zdCBvdmVyZmxvd3M6IE92ZXJmbG93c01hcCA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZSgoYWNjLCBwbGFjZW1lbnQpID0+IHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcsXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KChhLCBiKSA9PiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl0pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50LCBCb3VuZGFyeSwgUm9vdEJvdW5kYXJ5IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIsIFBhZGRpbmcgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQnO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQnO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gJy4uL3V0aWxzL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tICcuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudCc7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRWYXJpYXRpb24nO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBtYWluQXhpczogYm9vbGVhbixcbiAgYWx0QXhpczogYm9vbGVhbixcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBBcnJheTxQbGFjZW1lbnQ+LFxuICBwYWRkaW5nOiBQYWRkaW5nLFxuICBib3VuZGFyeTogQm91bmRhcnksXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICBhbHRCb3VuZGFyeTogYm9vbGVhbixcbiAgZmxpcFZhcmlhdGlvbnM6IGJvb2xlYW4sXG4gIGFsbG93ZWRBdXRvUGxhY2VtZW50czogQXJyYXk8UGxhY2VtZW50Pixcbn07XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudDogUGxhY2VtZW50KTogQXJyYXk8UGxhY2VtZW50PiB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgcmV0dXJuIFtcbiAgICBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLFxuICAgIG9wcG9zaXRlUGxhY2VtZW50LFxuICAgIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gZmxpcCh7IHN0YXRlLCBvcHRpb25zLCBuYW1lIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICBhbHRBeGlzOiBjaGVja0FsdEF4aXMgPSB0cnVlLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgIHBhZGRpbmcsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIGFsdEJvdW5kYXJ5LFxuICAgIGZsaXBWYXJpYXRpb25zID0gdHJ1ZSxcbiAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG5cbiAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID1cbiAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHxcbiAgICAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9uc1xuICAgICAgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV1cbiAgICAgIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG5cbiAgY29uc3QgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c10ucmVkdWNlKFxuICAgIChhY2MsIHBsYWNlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoXG4gICAgICAgIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0b1xuICAgICAgICAgID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgcm9vdEJvdW5kYXJ5LFxuICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgICBmbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHBsYWNlbWVudFxuICAgICAgKTtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3QgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3QgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcblxuICBjb25zdCBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIGxldCBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICBsZXQgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuICAgIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgY29uc3QgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIGNvbnN0IG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nLFxuICAgIH0pO1xuXG4gICAgbGV0IG1haW5WYXJpYXRpb25TaWRlOiBhbnkgPSBpc1ZlcnRpY2FsXG4gICAgICA/IGlzU3RhcnRWYXJpYXRpb25cbiAgICAgICAgPyByaWdodFxuICAgICAgICA6IGxlZnRcbiAgICAgIDogaXNTdGFydFZhcmlhdGlvblxuICAgICAgPyBib3R0b21cbiAgICAgIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYWx0VmFyaWF0aW9uU2lkZTogYW55ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuXG4gICAgY29uc3QgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2goXG4gICAgICAgIG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLFxuICAgICAgICBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoKGNoZWNrKSA9PiBjaGVjaykpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgY29uc3QgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgZm9yIChsZXQgaSA9IG51bWJlck9mQ2hlY2tzOyBpID4gMDsgaS0tKSB7XG4gICAgICBjb25zdCBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKChwbGFjZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBpKS5ldmVyeSgoY2hlY2spID0+IGNoZWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgRmxpcE1vZGlmaWVyID0gTW9kaWZpZXI8J2ZsaXAnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHsgX3NraXA6IGZhbHNlIH0sXG59OiBGbGlwTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzOiAneCcgfCAneScpOiAneCcgfCAneScge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gJy4vbWF0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluOiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBjb25zdCB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQsIEJvdW5kYXJ5LCBSb290Qm91bmRhcnkgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgdHlwZSB7IFJlY3QsIE1vZGlmaWVyQXJndW1lbnRzLCBNb2RpZmllciwgUGFkZGluZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQnO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSAnLi4vdXRpbHMvZ2V0QWx0QXhpcyc7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSAnLi4vdXRpbHMvd2l0aGluJztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0JztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudCc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRWYXJpYXRpb24nO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tICcuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QnO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbnR5cGUgVGV0aGVyT2Zmc2V0ID1cbiAgfCAoKHtcbiAgICAgIHBvcHBlcjogUmVjdCxcbiAgICAgIHJlZmVyZW5jZTogUmVjdCxcbiAgICAgIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICAgIH0pID0+IG51bWJlciB8IHsgbWFpbkF4aXM6IG51bWJlciwgYWx0QXhpczogbnVtYmVyIH0pXG4gIHwgbnVtYmVyXG4gIHwgeyBtYWluQXhpczogbnVtYmVyLCBhbHRBeGlzOiBudW1iZXIgfTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgLyogUHJldmVudHMgYm91bmRhcmllcyBvdmVyZmxvdyBvbiB0aGUgbWFpbiBheGlzICovXG4gIG1haW5BeGlzOiBib29sZWFuLFxuICAvKiBQcmV2ZW50cyBib3VuZGFyaWVzIG92ZXJmbG93IG9uIHRoZSBhbHRlcm5hdGUgYXhpcyAqL1xuICBhbHRBeGlzOiBib29sZWFuLFxuICAvKiBUaGUgYXJlYSB0byBjaGVjayB0aGUgcG9wcGVyIGlzIG92ZXJmbG93aW5nIGluICovXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgLyogSWYgdGhlIHBvcHBlciBpcyBub3Qgb3ZlcmZsb3dpbmcgdGhlIG1haW4gYXJlYSwgZmFsbGJhY2sgdG8gdGhpcyBvbmUgKi9cbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIC8qIFVzZSB0aGUgcmVmZXJlbmNlJ3MgXCJjbGlwcGluZ1BhcmVudHNcIiBib3VuZGFyeSBjb250ZXh0ICovXG4gIGFsdEJvdW5kYXJ5OiBib29sZWFuLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSBwb3BwZXIgdG8gb3ZlcmZsb3cgZnJvbSBpdHMgYm91bmRhcmllcyB0byBrZWVwIGl0IG5lYXIgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqL1xuICB0ZXRoZXI6IGJvb2xlYW4sXG4gIC8qIE9mZnNldHMgd2hlbiB0aGUgYHRldGhlcmAgb3B0aW9uIHNob3VsZCBhY3RpdmF0ZSAqL1xuICB0ZXRoZXJPZmZzZXQ6IFRldGhlck9mZnNldCxcbiAgLyogU2V0cyBhIHBhZGRpbmcgdG8gdGhlIHByb3ZpZGVkIGJvdW5kYXJ5ICovXG4gIHBhZGRpbmc6IFBhZGRpbmcsXG59O1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7XG4gICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgIGFsdEF4aXM6IGNoZWNrQWx0QXhpcyA9IGZhbHNlLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBhbHRCb3VuZGFyeSxcbiAgICBwYWRkaW5nLFxuICAgIHRldGhlciA9IHRydWUsXG4gICAgdGV0aGVyT2Zmc2V0ID0gMCxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5LFxuICB9KTtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgY29uc3QgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICBjb25zdCBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIGNvbnN0IHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIGNvbnN0IHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIGNvbnN0IHRldGhlck9mZnNldFZhbHVlID1cbiAgICB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRldGhlck9mZnNldCh7XG4gICAgICAgICAgLi4uc3RhdGUucmVjdHMsXG4gICAgICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnQsXG4gICAgICAgIH0pXG4gICAgICA6IHRldGhlck9mZnNldDtcbiAgY29uc3Qgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID1cbiAgICB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInXG4gICAgICA/IHsgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLCBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSB9XG4gICAgICA6IHsgbWFpbkF4aXM6IDAsIGFsdEF4aXM6IDAsIC4uLnRldGhlck9mZnNldFZhbHVlIH07XG4gIGNvbnN0IG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFxuICAgID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVxuICAgIDogbnVsbDtcblxuICBjb25zdCBkYXRhID0geyB4OiAwLCB5OiAwIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICBjb25zdCBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIGNvbnN0IGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICBjb25zdCBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcblxuICAgIGNvbnN0IG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICBjb25zdCBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcblxuICAgIGNvbnN0IGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuXG4gICAgY29uc3QgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICBjb25zdCBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07XG5cbiAgICAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcbiAgICBjb25zdCBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICBjb25zdCBhcnJvd1JlY3QgPVxuICAgICAgdGV0aGVyICYmIGFycm93RWxlbWVudFxuICAgICAgICA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KVxuICAgICAgICA6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIGNvbnN0IGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXVxuICAgICAgPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZ1xuICAgICAgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICBjb25zdCBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIGNvbnN0IGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcbiAgICBjb25zdCBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcblxuICAgIGNvbnN0IG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudFxuICAgICAgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC1cbiAgICAgICAgYWRkaXRpdmUgLVxuICAgICAgICBhcnJvd0xlbiAtXG4gICAgICAgIGFycm93UGFkZGluZ01pbiAtXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpc1xuICAgICAgOiBtaW5MZW4gLVxuICAgICAgICBhcnJvd0xlbiAtXG4gICAgICAgIGFycm93UGFkZGluZ01pbiAtXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICBjb25zdCBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnRcbiAgICAgID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgK1xuICAgICAgICBhZGRpdGl2ZSArXG4gICAgICAgIGFycm93TGVuICtcbiAgICAgICAgYXJyb3dQYWRkaW5nTWF4ICtcbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzXG4gICAgICA6IG1heExlbiArXG4gICAgICAgIGFycm93TGVuICtcbiAgICAgICAgYXJyb3dQYWRkaW5nTWF4ICtcbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuXG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPVxuICAgICAgc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICBjb25zdCBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudFxuICAgICAgPyBtYWluQXhpcyA9PT0gJ3knXG4gICAgICAgID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDBcbiAgICAgICAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDBcbiAgICAgIDogMDtcblxuICAgIGNvbnN0IG9mZnNldE1vZGlmaWVyVmFsdWUgPSBvZmZzZXRNb2RpZmllclN0YXRlPy5bbWFpbkF4aXNdID8/IDA7XG4gICAgY29uc3QgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICBjb25zdCB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuXG4gICAgY29uc3QgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKFxuICAgICAgdGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heFxuICAgICk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICBjb25zdCBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuICAgIGNvbnN0IGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIGNvbnN0IGxlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIGNvbnN0IG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICBjb25zdCBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcblxuICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgY29uc3Qgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IG9mZnNldE1vZGlmaWVyU3RhdGU/LlthbHRBeGlzXSA/PyAwO1xuICAgIGNvbnN0IHRldGhlck1pbiA9IGlzT3JpZ2luU2lkZVxuICAgICAgPyBtaW5cbiAgICAgIDogb2Zmc2V0IC1cbiAgICAgICAgcmVmZXJlbmNlUmVjdFtsZW5dIC1cbiAgICAgICAgcG9wcGVyUmVjdFtsZW5dIC1cbiAgICAgICAgb2Zmc2V0TW9kaWZpZXJWYWx1ZSArXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuICAgIGNvbnN0IHRldGhlck1heCA9IGlzT3JpZ2luU2lkZVxuICAgICAgPyBvZmZzZXQgK1xuICAgICAgICByZWZlcmVuY2VSZWN0W2xlbl0gK1xuICAgICAgICBwb3BwZXJSZWN0W2xlbl0gLVxuICAgICAgICBvZmZzZXRNb2RpZmllclZhbHVlIC1cbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXNcbiAgICAgIDogbWF4O1xuXG4gICAgY29uc3QgcHJldmVudGVkT2Zmc2V0ID1cbiAgICAgIHRldGhlciAmJiBpc09yaWdpblNpZGVcbiAgICAgICAgPyB3aXRoaW5NYXhDbGFtcCh0ZXRoZXJNaW4sIG9mZnNldCwgdGV0aGVyTWF4KVxuICAgICAgICA6IHdpdGhpbih0ZXRoZXIgPyB0ZXRoZXJNaW4gOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gdGV0aGVyTWF4IDogbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBQcmV2ZW50T3ZlcmZsb3dNb2RpZmllciA9IE1vZGlmaWVyPCdwcmV2ZW50T3ZlcmZsb3cnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxufTogUHJldmVudE92ZXJmbG93TW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXIsIE1vZGlmaWVyQXJndW1lbnRzLCBQYWRkaW5nLCBSZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0JztcbmltcG9ydCBjb250YWlucyBmcm9tICcuLi9kb20tdXRpbHMvY29udGFpbnMnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50JztcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gJy4uL3V0aWxzL3dpdGhpbic7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gJy4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdCc7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gJy4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcCc7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSAnLi4vZW51bXMnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBlbGVtZW50OiBIVE1MRWxlbWVudCB8IHN0cmluZyB8IG51bGwsXG4gIHBhZGRpbmc6XG4gICAgfCBQYWRkaW5nXG4gICAgfCAoKHt8XG4gICAgICAgIHBvcHBlcjogUmVjdCxcbiAgICAgICAgcmVmZXJlbmNlOiBSZWN0LFxuICAgICAgICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgICAgIHx9KSA9PiBQYWRkaW5nKSxcbn07XG5cbmNvbnN0IHRvUGFkZGluZ09iamVjdCA9IChwYWRkaW5nLCBzdGF0ZSkgPT4ge1xuICBwYWRkaW5nID1cbiAgICB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwYWRkaW5nKHsgLi4uc3RhdGUucmVjdHMsIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50IH0pXG4gICAgICA6IHBhZGRpbmc7XG5cbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdChcbiAgICB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcidcbiAgICAgID8gcGFkZGluZ1xuICAgICAgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpXG4gICk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyh7IHN0YXRlLCBuYW1lLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICBjb25zdCBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICBjb25zdCBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIGNvbnN0IGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICBjb25zdCBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIGNvbnN0IG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICBjb25zdCBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgY29uc3QgZW5kRGlmZiA9XG4gICAgc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gK1xuICAgIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtXG4gICAgcG9wcGVyT2Zmc2V0c1theGlzXSAtXG4gICAgc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIGNvbnN0IHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG5cbiAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgY29uc3QgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50XG4gICAgPyBheGlzID09PSAneSdcbiAgICAgID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDBcbiAgICAgIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMFxuICAgIDogMDtcblxuICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcbiAgY29uc3QgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpO1xuXG4gIC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cbiAgY29uc3QgYXhpc1Byb3A6IHN0cmluZyA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgW2F4aXNQcm9wXTogb2Zmc2V0LFxuICAgIGNlbnRlck9mZnNldDogb2Zmc2V0IC0gY2VudGVyLFxuICB9O1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSwgb3B0aW9ucyB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBsZXQgeyBlbGVtZW50OiBhcnJvd0VsZW1lbnQgPSAnW2RhdGEtcG9wcGVyLWFycm93XScgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIEFycm93TW9kaWZpZXIgPSBNb2RpZmllcjwnYXJyb3cnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG59OiBBcnJvd01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIE1vZGlmaWVyQXJndW1lbnRzLFxuICBNb2RpZmllcixcbiAgUmVjdCxcbiAgU2lkZU9iamVjdCxcbiAgT2Zmc2V0cyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gJy4uL3V0aWxzL2RldGVjdE92ZXJmbG93JztcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMoXG4gIG92ZXJmbG93OiBTaWRlT2JqZWN0LFxuICByZWN0OiBSZWN0LFxuICBwcmV2ZW50ZWRPZmZzZXRzOiBPZmZzZXRzID0geyB4OiAwLCB5OiAwIH1cbik6IFNpZGVPYmplY3Qge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54LFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3c6IFNpZGVPYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoKHNpZGUpID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuXG5mdW5jdGlvbiBoaWRlKHsgc3RhdGUsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgY29uc3QgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3QgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgY29uc3QgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuXG4gIGNvbnN0IHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZScsXG4gIH0pO1xuICBjb25zdCBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWUsXG4gIH0pO1xuXG4gIGNvbnN0IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKFxuICAgIHJlZmVyZW5jZU92ZXJmbG93LFxuICAgIHJlZmVyZW5jZVJlY3RcbiAgKTtcbiAgY29uc3QgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKFxuICAgIHBvcHBlckFsdE92ZXJmbG93LFxuICAgIHBvcHBlclJlY3QsXG4gICAgcHJldmVudGVkT2Zmc2V0c1xuICApO1xuXG4gIGNvbnN0IGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIGNvbnN0IGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkLFxuICB9O1xuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge1xuICAgIC4uLnN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLFxuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkLFxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBIaWRlTW9kaWZpZXIgPSBNb2RpZmllcjwnaGlkZScsIHt8fH0+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZSxcbn06IEhpZGVNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJy4vY3JlYXRlUG9wcGVyJztcblxuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gJy4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gJy4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMnO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcyc7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMnO1xuXG5leHBvcnQgdHlwZSAqIGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0TW9kaWZpZXJzID0gW1xuICBldmVudExpc3RlbmVycyxcbiAgcG9wcGVyT2Zmc2V0cyxcbiAgY29tcHV0ZVN0eWxlcyxcbiAgYXBwbHlTdHlsZXMsXG5dO1xuXG5jb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoeyBkZWZhdWx0TW9kaWZpZXJzIH0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSAnLi9jcmVhdGVQb3BwZXInO1xuXG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSAnLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cyc7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tICcuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzJztcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tICcuL21vZGlmaWVycy9hcHBseVN0eWxlcyc7XG5pbXBvcnQgb2Zmc2V0IGZyb20gJy4vbW9kaWZpZXJzL29mZnNldCc7XG5pbXBvcnQgZmxpcCBmcm9tICcuL21vZGlmaWVycy9mbGlwJztcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSAnLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93JztcbmltcG9ydCBhcnJvdyBmcm9tICcuL21vZGlmaWVycy9hcnJvdyc7XG5pbXBvcnQgaGlkZSBmcm9tICcuL21vZGlmaWVycy9oaWRlJztcblxuZXhwb3J0IHR5cGUgKiBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZGVmYXVsdE1vZGlmaWVycyA9IFtcbiAgZXZlbnRMaXN0ZW5lcnMsXG4gIHBvcHBlck9mZnNldHMsXG4gIGNvbXB1dGVTdHlsZXMsXG4gIGFwcGx5U3R5bGVzLFxuICBvZmZzZXQsXG4gIGZsaXAsXG4gIHByZXZlbnRPdmVyZmxvdyxcbiAgYXJyb3csXG4gIGhpZGUsXG5dO1xuXG5jb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoeyBkZWZhdWx0TW9kaWZpZXJzIH0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSAnLi9wb3BwZXItbGl0ZSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgKiBmcm9tICcuL21vZGlmaWVycyc7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUllLFNBQVNBLFNBQVRBLENBQW1CQyxJQUFuQixFQUF5QjtFQUN0QyxJQUFJQSxJQUFJLElBQUksSUFBWixFQUFrQjtJQUNoQixPQUFPQyxNQUFQO0VBQ0Q7RUFFRCxJQUFJRCxJQUFJLENBQUNFLFFBQUwsT0FBb0IsaUJBQXhCLEVBQTJDO0lBQ3pDLElBQU1DLGFBQWEsR0FBR0gsSUFBSSxDQUFDRyxhQUEzQjtJQUNBLE9BQU9BLGFBQWEsR0FBR0EsYUFBYSxDQUFDQyxXQUFkLElBQTZCSCxNQUFoQyxH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