0d2299e2136ea47c58bf7992dd77d88f
/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('react-router'), require('@remix-run/router')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'react-router', '@remix-run/router'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouterDOM = {}, global.React, global.ReactDOM, global.ReactRouter, global.RemixRouter));
})(this, function (exports, React, ReactDOM, reactRouter, router) {
  'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var React__namespace = /*#__PURE__*/_interopNamespace(React);
  var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  const defaultMethod = "get";
  const defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object) {
    return object != null && typeof object.tagName === "string";
  }
  function isButtonElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
  }
  function isFormElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
  }
  function isInputElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function shouldProcessLinkClick(event, target) {
    return event.button === 0 && (
    // Ignore everything but left clicks
    !target || target === "_self") &&
    // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ;
  }

  /**
   * Creates a URLSearchParams object using the given initializer.
   *
   * This is identical to `new URLSearchParams(init)` except it also
   * supports arrays as values in the object form of the initializer
   * instead of just strings. This is convenient when you need multiple
   * values for a given key, but don't want to use an array initializer.
   *
   * For example, instead of:
   *
   *   let searchParams = new URLSearchParams([
   *     ['sort', 'name'],
   *     ['sort', 'price']
   *   ]);
   *
   * you can do:
   *
   *   let searchParams = createSearchParams({
   *     sort: ['name', 'price']
   *   });
   */
  function createSearchParams(init) {
    if (init === void 0) {
      init = "";
    }
    return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
      let value = init[key];
      return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
    }, []));
  }
  function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
    let searchParams = createSearchParams(locationSearch);
    if (defaultSearchParams) {
      // Use `defaultSearchParams.forEach(...)` here instead of iterating of
      // `defaultSearchParams.keys()` to work-around a bug in Firefox related to
      // web extensions. Relevant Bugzilla tickets:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984
      defaultSearchParams.forEach((_, key) => {
        if (!searchParams.has(key)) {
          defaultSearchParams.getAll(key).forEach(value => {
            searchParams.append(key, value);
          });
        }
      });
    }
    return searchParams;
  }

  // Thanks https://github.com/sindresorhus/type-fest!

  // One-time check for submitter support
  let _formDataSupportsSubmitter = null;
  function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null) {
      try {
        new FormData(document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0);
        _formDataSupportsSubmitter = false;
      } catch (e) {
        _formDataSupportsSubmitter = true;
      }
    }
    return _formDataSupportsSubmitter;
  }
  const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
  function getFormEncType(encType) {
    if (encType != null && !supportedFormEncTypes.has(encType)) {
      router.UNSAFE_warning(false, "\"" + encType + "\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` " + ("and will default to \"" + defaultEncType + "\""));
      return null;
    }
    return encType;
  }
  function getFormSubmissionInfo(target, basename) {
    let method;
    let action;
    let encType;
    let formData;
    let body;
    if (isFormElement(target)) {
      // When grabbing the action from the element, it will have had the basename
      // prefixed to ensure non-JS scenarios work, so strip it since we'll
      // re-prefix in the router
      let attr = target.getAttribute("action");
      action = attr ? router.stripBasename(attr, basename) : null;
      method = target.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(target);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
      }

      // <button>/<input type="submit"> may override attributes of <form>

      // When grabbing the action from the element, it will have had the basename
      // prefixed to ensure non-JS scenarios work, so strip it since we'll
      // re-prefix in the router
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? router.stripBasename(attr, basename) : null;
      method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;

      // Build a FormData object populated from a form and submitter
      formData = new FormData(form, target);

      // If this browser doesn't support the `FormData(el, submitter)` format,
      // then tack on the submitter value at the end.  This is a lightweight
      // solution that is not 100% spec compliant.  For complete support in older
      // browsers, consider using the `formdata-submitter-polyfill` package
      if (!isFormDataSubmitterSupported()) {
        let {
          name,
          type,
          value
        } = target;
        if (type === "image") {
          let prefix = name ? name + "." : "";
          formData.append(prefix + "x", "0");
          formData.append(prefix + "y", "0");
        } else if (name) {
          formData.append(name, value);
        }
      }
    } else if (isHtmlElement(target)) {
      throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
    } else {
      method = defaultMethod;
      action = null;
      encType = defaultEncType;
      body = target;
    }

    // Send body for <Form encType="text/plain" so we encode it into text
    if (formData && encType === "text/plain") {
      body = formData;
      formData = undefined;
    }
    return {
      action,
      method: method.toLowerCase(),
      encType,
      formData,
      body
    };
  }
  const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"],
    _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"],
    _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"];
  //#endregion
  // HEY YOU! DON'T TOUCH THIS VARIABLE!
  //
  // It is replaced with the proper version at build time via a babel plugin in
  // the rollup config.
  //
  // Export a global property onto the window for React Router detection by the
  // Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`
  // to detect and properly classify live websites as being built with React Router:
  // https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json
  const REACT_ROUTER_VERSION = "6";
  try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION;
  } catch (e) {
    // no-op
  }

  ////////////////////////////////////////////////////////////////////////////////
  //#region Routers
  ////////////////////////////////////////////////////////////////////////////////
  function createBrowserRouter(routes, opts) {
    return router.createRouter({
      basename: opts == null ? void 0 : opts.basename,
      future: _extends({}, opts == null ? void 0 : opts.future, {
        v7_prependBasename: true
      }),
      history: router.createBrowserHistory({
        window: opts == null ? void 0 : opts.window
      }),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes,
      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,
      unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,
      window: opts == null ? void 0 : opts.window
    }).initialize();
  }
  function createHashRouter(routes, opts) {
    return router.createRouter({
      basename: opts == null ? void 0 : opts.basename,
      future: _extends({}, opts == null ? void 0 : opts.future, {
        v7_prependBasename: true
      }),
      history: router.createHashHistory({
        window: opts == null ? void 0 : opts.window
      }),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes,
      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,
      unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,
      window: opts == null ? void 0 : opts.window
    }).initialize();
  }
  function parseHydrationData() {
    var _window;
    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
    if (state && state.errors) {
      state = _extends({}, state, {
        errors: deserializeErrors(state.errors)
      });
    }
    return state;
  }
  function deserializeErrors(errors) {
    if (!errors) return null;
    let entries = Object.entries(errors);
    let serialized = {};
    for (let [key, val] of entries) {
      // Hey you!  If you change this, please change the corresponding logic in
      // serializeErrors in react-router-dom/server.tsx :)
      if (val && val.__type === "RouteErrorResponse") {
        serialized[key] = new router.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
      } else if (val && val.__type === "Error") {
        // Attempt to reconstruct the right type of Error (i.e., ReferenceError)
        if (val.__subType) {
          let ErrorConstructor = window[val.__subType];
          if (typeof ErrorConstructor === "function") {
            try {
              // @ts-expect-error
              let error = new ErrorConstructor(val.message);
              // Wipe away the client-side stack trace.  Nothing to fill it in with
              // because we don't serialize SSR stack traces for security reasons
              error.stack = "";
              serialized[key] = error;
            } catch (e) {
              // no-op - fall through and create a normal Error
            }
          }
        }
        if (serialized[key] == null) {
          let error = new Error(val.message);
          // Wipe away the client-side stack trace.  Nothing to fill it in with
          // because we don't serialize SSR stack traces for security reasons
          error.stack = "";
          serialized[key] = error;
        }
      } else {
        serialized[key] = val;
      }
    }
    return serialized;
  }

  //#endregion

  ////////////////////////////////////////////////////////////////////////////////
  //#region Contexts
  ////////////////////////////////////////////////////////////////////////////////
  const ViewTransitionContext = /*#__PURE__*/React__namespace.createContext({
    isTransitioning: false
  });
  {
    ViewTransitionContext.displayName = "ViewTransition";
  }

  // TODO: (v7) Change the useFetcher data from `any` to `unknown`

  const FetchersContext = /*#__PURE__*/React__namespace.createContext(new Map());
  {
    FetchersContext.displayName = "Fetchers";
  }

  //#endregion

  ////////////////////////////////////////////////////////////////////////////////
  //#region Components
  ////////////////////////////////////////////////////////////////////////////////

  /**
    Webpack + React 17 fails to compile on any of the following because webpack
    complains that `startTransition` doesn't exist in `React`:
    * import { startTransition } from "react"
    * import * as React from from "react";
      "startTransition" in React ? React.startTransition(() => setState()) : setState()
    * import * as React from from "react";
      "startTransition" in React ? React["startTransition"](() => setState()) : setState()
     Moving it to a constant such as the following solves the Webpack/React 17 issue:
    * import * as React from from "react";
      const START_TRANSITION = "startTransition";
      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()
     However, that introduces webpack/terser minification issues in production builds
    in React 18 where minification/obfuscation ends up removing the call of
    React.startTransition entirely from the first half of the ternary.  Grabbing
    this exported reference once up front resolves that issue.
     See https://github.com/remix-run/react-router/issues/10579
  */
  const START_TRANSITION = "startTransition";
  const startTransitionImpl = React__namespace[START_TRANSITION];
  const FLUSH_SYNC = "flushSync";
  const flushSyncImpl = ReactDOM__namespace[FLUSH_SYNC];
  const USE_ID = "useId";
  const useIdImpl = React__namespace[USE_ID];
  function startTransitionSafe(cb) {
    if (startTransitionImpl) {
      startTransitionImpl(cb);
    } else {
      cb();
    }
  }
  function flushSyncSafe(cb) {
    if (flushSyncImpl) {
      flushSyncImpl(cb);
    } else {
      cb();
    }
  }
  class Deferred {
    // @ts-expect-error - no initializer

    // @ts-expect-error - no initializer

    constructor() {
      this.status = "pending";
      this.promise = new Promise((resolve, reject) => {
        this.resolve = value => {
          if (this.status === "pending") {
            this.status = "resolved";
            resolve(value);
          }
        };
        this.reject = reason => {
          if (this.status === "pending") {
            this.status = "rejected";
            reject(reason);
          }
        };
      });
    }
  }

  /**
   * Given a Remix Router instance, render the appropriate UI
   */
  function RouterProvider(_ref) {
    let {
      fallbackElement,
      router: router$1,
      future
    } = _ref;
    let [state, setStateImpl] = React__namespace.useState(router$1.state);
    let [pendingState, setPendingState] = React__namespace.useState();
    let [vtContext, setVtContext] = React__namespace.useState({
      isTransitioning: false
    });
    let [renderDfd, setRenderDfd] = React__namespace.useState();
    let [transition, setTransition] = React__namespace.useState();
    let [interruption, setInterruption] = React__namespace.useState();
    let fetcherData = React__namespace.useRef(new Map());
    let {
      v7_startTransition
    } = future || {};
    let optInStartTransition = React__namespace.useCallback(cb => {
      if (v7_startTransition) {
        startTransitionSafe(cb);
      } else {
        cb();
      }
    }, [v7_startTransition]);
    let setState = React__namespace.useCallback((newState, _ref2) => {
      let {
        deletedFetchers,
        unstable_flushSync: flushSync,
        unstable_viewTransitionOpts: viewTransitionOpts
      } = _ref2;
      deletedFetchers.forEach(key => fetcherData.current.delete(key));
      newState.fetchers.forEach((fetcher, key) => {
        if (fetcher.data !== undefined) {
          fetcherData.current.set(key, fetcher.data);
        }
      });
      let isViewTransitionUnavailable = router$1.window == null || router$1.window.document == null || typeof router$1.window.document.startViewTransition !== "function";

      // If this isn't a view transition or it's not available in this browser,
      // just update and be done with it
      if (!viewTransitionOpts || isViewTransitionUnavailable) {
        if (flushSync) {
          flushSyncSafe(() => setStateImpl(newState));
        } else {
          optInStartTransition(() => setStateImpl(newState));
        }
        return;
      }

      // flushSync + startViewTransition
      if (flushSync) {
        // Flush through the context to mark DOM elements as transition=ing
        flushSyncSafe(() => {
          // Cancel any pending transitions
          if (transition) {
            renderDfd && renderDfd.resolve();
            transition.skipTransition();
          }
          setVtContext({
            isTransitioning: true,
            flushSync: true,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        });

        // Update the DOM
        let t = router$1.window.document.startViewTransition(() => {
          flushSyncSafe(() => setStateImpl(newState));
        });

        // Clean up after the animation completes
        t.finished.finally(() => {
          flushSyncSafe(() => {
            setRenderDfd(undefined);
            setTransition(undefined);
            setPendingState(undefined);
            setVtContext({
              isTransitioning: false
            });
          });
        });
        flushSyncSafe(() => setTransition(t));
        return;
      }

      // startTransition + startViewTransition
      if (transition) {
        // Interrupting an in-progress transition, cancel and let everything flush
        // out, and then kick off a new transition from the interruption state
        renderDfd && renderDfd.resolve();
        transition.skipTransition();
        setInterruption({
          state: newState,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      } else {
        // Completed navigation update with opted-in view transitions, let 'er rip
        setPendingState(newState);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      }
    }, [router$1.window, transition, renderDfd, fetcherData, optInStartTransition]);

    // Need to use a layout effect here so we are subscribed early enough to
    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)
    React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);

    // When we start a view transition, create a Deferred we can use for the
    // eventual "completed" render
    React__namespace.useEffect(() => {
      if (vtContext.isTransitioning && !vtContext.flushSync) {
        setRenderDfd(new Deferred());
      }
    }, [vtContext]);

    // Once the deferred is created, kick off startViewTransition() to update the
    // DOM and then wait on the Deferred to resolve (indicating the DOM update has
    // happened)
    React__namespace.useEffect(() => {
      if (renderDfd && pendingState && router$1.window) {
        let newState = pendingState;
        let renderPromise = renderDfd.promise;
        let transition = router$1.window.document.startViewTransition(async () => {
          optInStartTransition(() => setStateImpl(newState));
          await renderPromise;
        });
        transition.finished.finally(() => {
          setRenderDfd(undefined);
          setTransition(undefined);
          setPendingState(undefined);
          setVtContext({
            isTransitioning: false
          });
        });
        setTransition(transition);
      }
    }, [optInStartTransition, pendingState, renderDfd, router$1.window]);

    // When the new location finally renders and is committed to the DOM, this
    // effect will run to resolve the transition
    React__namespace.useEffect(() => {
      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
        renderDfd.resolve();
      }
    }, [renderDfd, transition, state.location, pendingState]);

    // If we get interrupted with a new navigation during a transition, we skip
    // the active transition, let it cleanup, then kick it off again here
    React__namespace.useEffect(() => {
      if (!vtContext.isTransitioning && interruption) {
        setPendingState(interruption.state);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: interruption.currentLocation,
          nextLocation: interruption.nextLocation
        });
        setInterruption(undefined);
      }
    }, [vtContext.isTransitioning, interruption]);
    React__namespace.useEffect(() => {
      router.UNSAFE_warning(fallbackElement == null || !router$1.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using " + "`v7_partialHydration`, use a `HydrateFallback` component instead");
      // Only log this once on initial mount
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    let navigator = React__namespace.useMemo(() => {
      return {
        createHref: router$1.createHref,
        encodeLocation: router$1.encodeLocation,
        go: n => router$1.navigate(n),
        push: (to, state, opts) => router$1.navigate(to, {
          state,
          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
        }),
        replace: (to, state, opts) => router$1.navigate(to, {
          replace: true,
          state,
          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
        })
      };
    }, [router$1]);
    let basename = router$1.basename || "/";
    let dataRouterContext = React__namespace.useMemo(() => ({
      router: router$1,
      navigator,
      static: false,
      basename
    }), [router$1, navigator, basename]);

    // The fragment and {null} here are important!  We need them to keep React 18's
    // useId happy when we are server-rendering since we may have a <script> here
    // containing the hydrated server-side staticContext (from StaticRouterProvider).
    // useId relies on the component tree structure to generate deterministic id's
    // so we need to ensure it remains the same on the client even though
    // we don't need the <script> tag
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(reactRouter.UNSAFE_DataRouterContext.Provider, {
      value: dataRouterContext
    }, /*#__PURE__*/React__namespace.createElement(reactRouter.UNSAFE_DataRouterStateContext.Provider, {
      value: state
    }, /*#__PURE__*/React__namespace.createElement(FetchersContext.Provider, {
      value: fetcherData.current
    }, /*#__PURE__*/React__namespace.createElement(ViewTransitionContext.Provider, {
      value: vtContext
    }, /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {
      basename: basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: navigator,
      future: {
        v7_relativeSplatPath: router$1.future.v7_relativeSplatPath
      }
    }, state.initialized || router$1.future.v7_partialHydration ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {
      routes: router$1.routes,
      future: router$1.future,
      state: state
    }) : fallbackElement))))), null);
  }
  function DataRoutes(_ref3) {
    let {
      routes,
      future,
      state
    } = _ref3;
    return reactRouter.UNSAFE_useRoutesImpl(routes, undefined, state, future);
  }
  /**
   * A `<Router>` for use in web browsers. Provides the cleanest URLs.
   */
  function BrowserRouter(_ref4) {
    let {
      basename,
      children,
      future,
      window
    } = _ref4;
    let historyRef = React__namespace.useRef();
    if (historyRef.current == null) {
      historyRef.current = router.createBrowserHistory({
        window,
        v5Compat: true
      });
    }
    let history = historyRef.current;
    let [state, setStateImpl] = React__namespace.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback(newState => {
      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future: future
    });
  }
  /**
   * A `<Router>` for use in web browsers. Stores the location in the hash
   * portion of the URL so it is not sent to the server.
   */
  function HashRouter(_ref5) {
    let {
      basename,
      children,
      future,
      window
    } = _ref5;
    let historyRef = React__namespace.useRef();
    if (historyRef.current == null) {
      historyRef.current = router.createHashHistory({
        window,
        v5Compat: true
      });
    }
    let history = historyRef.current;
    let [state, setStateImpl] = React__namespace.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback(newState => {
      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future: future
    });
  }
  /**
   * A `<Router>` that accepts a pre-instantiated history object. It's important
   * to note that using your own history object is highly discouraged and may add
   * two versions of the history library to your bundles unless you use the same
   * version of the history library that React Router uses internally.
   */
  function HistoryRouter(_ref6) {
    let {
      basename,
      children,
      future,
      history
    } = _ref6;
    let [state, setStateImpl] = React__namespace.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback(newState => {
      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future: future
    });
  }
  {
    HistoryRouter.displayName = "unstable_HistoryRouter";
  }
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;

  /**
   * The public API for rendering a history-aware `<a>`.
   */
  const Link = /*#__PURE__*/React__namespace.forwardRef(function LinkWithRef(_ref7, ref) {
    let {
        onClick,
        relative,
        reloadDocument,
        replace,
        state,
        target,
        to,
        preventScrollReset,
        unstable_viewTransition
      } = _ref7,
      rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);

    // Rendered into <a href> for absolute URLs
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
      // Render the absolute href server- and client-side
      absoluteHref = to;

      // Only check for external origins client-side
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = router.stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            // Strip the protocol/origin/basename for same-origin absolute URLs
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          // We can't do external URL detection without a valid URL
          router.UNSAFE_warning(false, "<Link to=\"" + to + "\"> contains an invalid URL which will probably break " + "when clicked - please update to a valid URL path.");
        }
      }
    }

    // Rendered into <a href> for relative URLs
    let href = reactRouter.useHref(to, {
      relative
    });
    let internalOnClick = useLinkClickHandler(to, {
      replace,
      state,
      target,
      preventScrollReset,
      relative,
      unstable_viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    return /*#__PURE__*/(
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      React__namespace.createElement("a", _extends({}, rest, {
        href: absoluteHref || href,
        onClick: isExternal || reloadDocument ? onClick : handleClick,
        ref: ref,
        target: target
      }))
    );
  });
  {
    Link.displayName = "Link";
  }
  /**
   * A `<Link>` wrapper that knows if it's "active" or not.
   */
  const NavLink = /*#__PURE__*/React__namespace.forwardRef(function NavLinkWithRef(_ref8, ref) {
    let {
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = false,
        className: classNameProp = "",
        end = false,
        style: styleProp,
        to,
        unstable_viewTransition,
        children
      } = _ref8,
      rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);
    let path = reactRouter.useResolvedPath(to, {
      relative: rest.relative
    });
    let location = reactRouter.useLocation();
    let routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
    let {
      navigator,
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let isTransitioning = routerState != null &&
    // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && unstable_viewTransition === true;
    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = router.stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }

    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,
    // we're looking for a slash _after_ what's in `to`.  For example:
    //
    // <NavLink to="/users"> and <NavLink to="/users/">
    // both want to look for a / at index 6 to match URL `/users/matt`
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : undefined;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      // If the className prop is not a function, we use a default `active`
      // class for <NavLink />s that are active. In v5 `active` was the default
      // value for `activeClassName`, but we are removing that API and can still
      // use the old default behavior for a cleaner upgrade path and keep the
      // simple styling rules working as they currently do.
      className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /*#__PURE__*/React__namespace.createElement(Link, _extends({}, rest, {
      "aria-current": ariaCurrent,
      className: className,
      ref: ref,
      style: style,
      to: to,
      unstable_viewTransition: unstable_viewTransition
    }), typeof children === "function" ? children(renderProps) : children);
  });
  {
    NavLink.displayName = "NavLink";
  }
  /**
   * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
   * that the interaction with the server is with `fetch` instead of new document
   * requests, allowing components to add nicer UX to the page as the form is
   * submitted and returns with data.
   */
  const Form = /*#__PURE__*/React__namespace.forwardRef((_ref9, forwardedRef) => {
    let {
        fetcherKey,
        navigate,
        reloadDocument,
        replace,
        state,
        method = defaultMethod,
        action,
        onSubmit,
        relative,
        preventScrollReset,
        unstable_viewTransition
      } = _ref9,
      props = _objectWithoutPropertiesLoose(_ref9, _excluded3);
    let submit = useSubmit();
    let formAction = useFormAction(action, {
      relative
    });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let submitHandler = event => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace,
        state,
        relative,
        preventScrollReset,
        unstable_viewTransition
      });
    };
    return /*#__PURE__*/React__namespace.createElement("form", _extends({
      ref: forwardedRef,
      method: formMethod,
      action: formAction,
      onSubmit: reloadDocument ? onSubmit : submitHandler
    }, props));
  });
  {
    Form.displayName = "Form";
  }
  /**
   * This component will emulate the browser's scroll restoration on location
   * changes.
   */
  function ScrollRestoration(_ref10) {
    let {
      getKey,
      storageKey
    } = _ref10;
    useScrollRestoration({
      getKey,
      storageKey
    });
    return null;
  }
  {
    ScrollRestoration.displayName = "ScrollRestoration";
  }
  //#endregion

  ////////////////////////////////////////////////////////////////////////////////
  //#region Hooks
  ////////////////////////////////////////////////////////////////////////////////
  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {
    DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
    DataRouterHook["UseSubmit"] = "useSubmit";
    DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";
    DataRouterHook["UseFetcher"] = "useFetcher";
    DataRouterHook["useViewTransitionState"] = "useViewTransitionState";
    return DataRouterHook;
  }(DataRouterHook || {});
  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {
    DataRouterStateHook["UseFetcher"] = "useFetcher";
    DataRouterStateHook["UseFetchers"] = "useFetchers";
    DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
    return DataRouterStateHook;
  }(DataRouterStateHook || {}); // Internal hooks
  function getDataRouterConsoleError(hookName) {
    return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
  }
  function useDataRouterContext(hookName) {
    let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);
    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
    return state;
  }

  // External hooks

  /**
   * Handles the click behavior for router `<Link>` components. This is useful if
   * you need to create custom `<Link>` components with the same click behavior we
   * use in our exported `<Link>`.
   */
  function useLinkClickHandler(to, _temp) {
    let {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      unstable_viewTransition
    } = _temp === void 0 ? {} : _temp;
    let navigate = reactRouter.useNavigate();
    let location = reactRouter.useLocation();
    let path = reactRouter.useResolvedPath(to, {
      relative
    });
    return React__namespace.useCallback(event => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();

        // If the URL hasn't changed, a regular <a> will do a replace instead of
        // a push, so do the same here unless the replace prop is explicitly set
        let replace = replaceProp !== undefined ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);
        navigate(to, {
          replace,
          state,
          preventScrollReset,
          relative,
          unstable_viewTransition
        });
      }
    }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
  }

  /**
   * A convenient wrapper for reading and writing search parameters via the
   * URLSearchParams interface.
   */
  function useSearchParams(defaultInit) {
    router.UNSAFE_warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params\n\n" + "If you're unsure how to load polyfills, we recommend you check out " + "https://polyfill.io/v3/ which provides some recommendations about how " + "to load polyfills only for users that need them, instead of for every " + "user.");
    let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit));
    let hasSetSearchParamsRef = React__namespace.useRef(false);
    let location = reactRouter.useLocation();
    let searchParams = React__namespace.useMemo(() =>
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
    let navigate = reactRouter.useNavigate();
    let setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => {
      const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
      hasSetSearchParamsRef.current = true;
      navigate("?" + newSearchParams, navigateOptions);
    }, [navigate, searchParams]);
    return [searchParams, setSearchParams];
  }

  /**
   * Submits a HTML `<form>` to the server without reloading the page.
   */

  /**
   * Submits a fetcher `<form>` to the server without reloading the page.
   */

  function validateClientSideSubmission() {
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
    }
  }
  let fetcherId = 0;
  let getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";

  /**
   * Returns a function that may be used to programmatically submit a form (or
   * some arbitrary data) to the server.
   */
  function useSubmit() {
    let {
      router
    } = useDataRouterContext(DataRouterHook.UseSubmit);
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let currentRouteId = reactRouter.UNSAFE_useRouteId();
    return React__namespace.useCallback(function (target, options) {
      if (options === void 0) {
        options = {};
      }
      validateClientSideSubmission();
      let {
        action,
        method,
        encType,
        formData,
        body
      } = getFormSubmissionInfo(target, basename);
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          unstable_flushSync: options.unstable_flushSync
        });
      } else {
        router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          unstable_flushSync: options.unstable_flushSync,
          unstable_viewTransition: options.unstable_viewTransition
        });
      }
    }, [router, basename, currentRouteId]);
  }

  // v7: Eventually we should deprecate this entirely in favor of using the
  // router method directly?
  function useFormAction(action, _temp2) {
    let {
      relative
    } = _temp2 === void 0 ? {} : _temp2;
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
    !routeContext ? router.UNSAFE_invariant(false, "useFormAction must be used inside a RouteContext") : void 0;
    let [match] = routeContext.matches.slice(-1);
    // Shallow clone path so we can modify it below, otherwise we modify the
    // object referenced by useMemo inside useResolvedPath
    let path = _extends({}, reactRouter.useResolvedPath(action ? action : ".", {
      relative
    }));

    // If no action was specified, browsers will persist current search params
    // when determining the path, so match that behavior
    // https://github.com/remix-run/remix/issues/927
    let location = reactRouter.useLocation();
    if (action == null) {
      // Safe to write to this directly here since if action was undefined, we
      // would have called useResolvedPath(".") which will never include a search
      path.search = location.search;

      // When grabbing search params from the URL, remove any included ?index param
      // since it might not apply to our contextual route.  We add it back based
      // on match.route.index below
      let params = new URLSearchParams(path.search);
      if (params.has("index") && params.get("index") === "") {
        params.delete("index");
        path.search = params.toString() ? "?" + params.toString() : "";
      }
    }
    if ((!action || action === ".") && match.route.index) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    }

    // If we're operating within a basename, prepend it to the pathname prior
    // to creating the form action.  If this is a root navigation, then just use
    // the raw basename which allows the basename to have full control over the
    // presence of a trailing slash on root actions
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname]);
    }
    return reactRouter.createPath(path);
  }
  // TODO: (v7) Change the useFetcher generic default from `any` to `unknown`
  /**
   * Interacts with route loaders and actions without causing a navigation. Great
   * for any interaction that stays on the same page.
   */
  function useFetcher(_temp3) {
    var _route$matches;
    let {
      key
    } = _temp3 === void 0 ? {} : _temp3;
    let {
      router: router$1
    } = useDataRouterContext(DataRouterHook.UseFetcher);
    let state = useDataRouterState(DataRouterStateHook.UseFetcher);
    let fetcherData = React__namespace.useContext(FetchersContext);
    let route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
    !fetcherData ? router.UNSAFE_invariant(false, "useFetcher must be used inside a FetchersContext") : void 0;
    !route ? router.UNSAFE_invariant(false, "useFetcher must be used inside a RouteContext") : void 0;
    !(routeId != null) ? router.UNSAFE_invariant(false, "useFetcher can only be used on routes that contain a unique \"id\"") : void 0;

    // Fetcher key handling
    // OK to call conditionally to feature detect `useId`
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let defaultKey = useIdImpl ? useIdImpl() : "";
    let [fetcherKey, setFetcherKey] = React__namespace.useState(key || defaultKey);
    if (key && key !== fetcherKey) {
      setFetcherKey(key);
    } else if (!fetcherKey) {
      // We will only fall through here when `useId` is not available
      setFetcherKey(getUniqueFetcherId());
    }

    // Registration/cleanup
    React__namespace.useEffect(() => {
      router$1.getFetcher(fetcherKey);
      return () => {
        // Tell the router we've unmounted - if v7_fetcherPersist is enabled this
        // will not delete immediately but instead queue up a delete after the
        // fetcher returns to an `idle` state
        router$1.deleteFetcher(fetcherKey);
      };
    }, [router$1, fetcherKey]);

    // Fetcher additions
    let load = React__namespace.useCallback((href, opts) => {
      !routeId ? router.UNSAFE_invariant(false, "No routeId available for fetcher.load()") : void 0;
      router$1.fetch(fetcherKey, routeId, href, opts);
    }, [fetcherKey, routeId, router$1]);
    let submitImpl = useSubmit();
    let submit = React__namespace.useCallback((target, opts) => {
      submitImpl(target, _extends({}, opts, {
        navigate: false,
        fetcherKey
      }));
    }, [fetcherKey, submitImpl]);
    let FetcherForm = React__namespace.useMemo(() => {
      let FetcherForm = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
        return /*#__PURE__*/React__namespace.createElement(Form, _extends({}, props, {
          navigate: false,
          fetcherKey: fetcherKey,
          ref: ref
        }));
      });
      {
        FetcherForm.displayName = "fetcher.Form";
      }
      return FetcherForm;
    }, [fetcherKey]);

    // Exposed FetcherWithComponents
    let fetcher = state.fetchers.get(fetcherKey) || router.IDLE_FETCHER;
    let data = fetcherData.get(fetcherKey);
    let fetcherWithComponents = React__namespace.useMemo(() => _extends({
      Form: FetcherForm,
      submit,
      load
    }, fetcher, {
      data
    }), [FetcherForm, submit, load, fetcher, data]);
    return fetcherWithComponents;
  }

  /**
   * Provides all fetchers currently on the page. Useful for layouts and parent
   * routes that need to provide pending/optimistic UI regarding the fetch.
   */
  function useFetchers() {
    let state = useDataRouterState(DataRouterStateHook.UseFetchers);
    return Array.from(state.fetchers.entries()).map(_ref11 => {
      let [key, fetcher] = _ref11;
      return _extends({}, fetcher, {
        key
      });
    });
  }
  const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  let savedScrollPositions = {};

  /**
   * When rendered inside a RouterProvider, will restore scroll positions on navigations
   */
  function useScrollRestoration(_temp4) {
    let {
      getKey,
      storageKey
    } = _temp4 === void 0 ? {} : _temp4;
    let {
      router: router$1
    } = useDataRouterContext(DataRouterHook.UseScrollRestoration);
    let {
      restoreScrollPosition,
      preventScrollReset
    } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let location = reactRouter.useLocation();
    let matches = reactRouter.useMatches();
    let navigation = reactRouter.useNavigation();

    // Trigger manual scroll restoration while we're active
    React__namespace.useEffect(() => {
      window.history.scrollRestoration = "manual";
      return () => {
        window.history.scrollRestoration = "auto";
      };
    }, []);

    // Save positions on pagehide
    usePageHide(React__namespace.useCallback(() => {
      if (navigation.state === "idle") {
        let key = (getKey ? getKey(location, matches) : null) || location.key;
        savedScrollPositions[key] = window.scrollY;
      }
      try {
        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
      } catch (error) {
        router.UNSAFE_warning(false, "Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (" + error + ").");
      }
      window.history.scrollRestoration = "auto";
    }, [storageKey, getKey, navigation.state, location, matches]));

    // Read in any saved scroll locations
    if (typeof document !== "undefined") {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => {
        try {
          let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
          if (sessionPositions) {
            savedScrollPositions = JSON.parse(sessionPositions);
          }
        } catch (e) {
          // no-op, use default empty object
        }
      }, [storageKey]);

      // Enable scroll restoration in the router
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => {
        let getKeyWithoutBasename = getKey && basename !== "/" ? (location, matches) => getKey(
        // Strip the basename to match useLocation()
        _extends({}, location, {
          pathname: router.stripBasename(location.pathname, basename) || location.pathname
        }), matches) : getKey;
        let disableScrollRestoration = router$1 == null ? void 0 : router$1.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
        return () => disableScrollRestoration && disableScrollRestoration();
      }, [router$1, basename, getKey]);

      // Restore scrolling when state.restoreScrollPosition changes
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => {
        // Explicit false means don't do anything (used for submissions)
        if (restoreScrollPosition === false) {
          return;
        }

        // been here before, scroll to it
        if (typeof restoreScrollPosition === "number") {
          window.scrollTo(0, restoreScrollPosition);
          return;
        }

        // try to scroll to the hash
        if (location.hash) {
          let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
          if (el) {
            el.scrollIntoView();
            return;
          }
        }

        // Don't reset if this navigation opted out
        if (preventScrollReset === true) {
          return;
        }

        // otherwise go to the top on new locations
        window.scrollTo(0, 0);
      }, [location, restoreScrollPosition, preventScrollReset]);
    }
  }

  /**
   * Setup a callback to be fired on the window's `beforeunload` event. This is
   * useful for saving some data to `window.localStorage` just before the page
   * refreshes.
   *
   * Note: The `callback` argument should be a function created with
   * `React.useCallback()`.
   */
  function useBeforeUnload(callback, options) {
    let {
      capture
    } = options || {};
    React__namespace.useEffect(() => {
      let opts = capture != null ? {
        capture
      } : undefined;
      window.addEventListener("beforeunload", callback, opts);
      return () => {
        window.removeEventListener("beforeunload", callback, opts);
      };
    }, [callback, capture]);
  }

  /**
   * Setup a callback to be fired on the window's `pagehide` event. This is
   * useful for saving some data to `window.localStorage` just before the page
   * refreshes.  This event is better supported than beforeunload across browsers.
   *
   * Note: The `callback` argument should be a function created with
   * `React.useCallback()`.
   */
  function usePageHide(callback, options) {
    let {
      capture
    } = options || {};
    React__namespace.useEffect(() => {
      let opts = capture != null ? {
        capture
      } : undefined;
      window.addEventListener("pagehide", callback, opts);
      return () => {
        window.removeEventListener("pagehide", callback, opts);
      };
    }, [callback, capture]);
  }

  /**
   * Wrapper around useBlocker to show a window.confirm prompt to users instead
   * of building a custom UI with useBlocker.
   *
   * Warning: This has *a lot of rough edges* and behaves very differently (and
   * very incorrectly in some cases) across browsers if user click addition
   * back/forward navigations while the confirm is open.  Use at your own risk.
   */
  function usePrompt(_ref12) {
    let {
      when,
      message
    } = _ref12;
    let blocker = reactRouter.useBlocker(when);
    React__namespace.useEffect(() => {
      if (blocker.state === "blocked") {
        let proceed = window.confirm(message);
        if (proceed) {
          // This timeout is needed to avoid a weird "race" on POP navigations
          // between the `window.history` revert navigation and the result of
          // `window.confirm`
          setTimeout(blocker.proceed, 0);
        } else {
          blocker.reset();
        }
      }
    }, [blocker, message]);
    React__namespace.useEffect(() => {
      if (blocker.state === "blocked" && !when) {
        blocker.reset();
      }
    }, [blocker, when]);
  }

  /**
   * Return a boolean indicating if there is an active view transition to the
   * given href.  You can use this value to render CSS classes or viewTransitionName
   * styles onto your elements
   *
   * @param href The destination href
   * @param [opts.relative] Relative routing type ("route" | "path")
   */
  function useViewTransitionState(to, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let vtContext = React__namespace.useContext(ViewTransitionContext);
    !(vtContext != null) ? router.UNSAFE_invariant(false, "`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  " + "Did you accidentally import `RouterProvider` from `react-router`?") : void 0;
    let {
      basename
    } = useDataRouterContext(DataRouterHook.useViewTransitionState);
    let path = reactRouter.useResolvedPath(to, {
      relative: opts.relative
    });
    if (!vtContext.isTransitioning) {
      return false;
    }
    let currentPath = router.stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
    let nextPath = router.stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;

    // Transition is active if we're going to or coming from the indicated
    // destination.  This ensures that other PUSH navigations that reverse
    // an indicated transition apply.  I.e., on the list view you have:
    //
    //   <NavLink to="/details/1" unstable_viewTransition>
    //
    // If you click the breadcrumb back to the list view:
    //
    //   <NavLink to="/list" unstable_viewTransition>
    //
    // We should apply the transition because it's indicated as active going
    // from /list -> /details/1 and therefore should be active on the reverse
    // (even though this isn't strictly a POP reverse)
    return router.matchPath(path.pathname, nextPath) != null || router.matchPath(path.pathname, currentPath) != null;
  }

  //#endregion

  Object.defineProperty(exports, 'AbortedDeferredError', {
    enumerable: true,
    get: function () {
      return reactRouter.AbortedDeferredError;
    }
  });
  Object.defineProperty(exports, 'Await', {
    enumerable: true,
    get: function () {
      return reactRouter.Await;
    }
  });
  Object.defineProperty(exports, 'MemoryRouter', {
    enumerable: true,
    get: function () {
      return reactRouter.MemoryRouter;
    }
  });
  Object.defineProperty(exports, 'Navigate', {
    enumerable: true,
    get: function () {
      return reactRouter.Navigate;
    }
  });
  Object.defineProperty(exports, 'NavigationType', {
    enumerable: true,
    get: function () {
      return reactRouter.NavigationType;
    }
  });
  Object.defineProperty(exports, 'Outlet', {
    enumerable: true,
    get: function () {
      return reactRouter.Outlet;
    }
  });
  Object.defineProperty(exports, 'Route', {
    enumerable: true,
    get: function () {
      return reactRouter.Route;
    }
  });
  Object.defineProperty(exports, 'Router', {
    enumerable: true,
    get: function () {
      return reactRouter.Router;
    }
  });
  Object.defineProperty(exports, 'Routes', {
    enumerable: true,
    get: function () {
      return reactRouter.Routes;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_DataRouterContext', {
    enumerable: true,
    get: function () {
      return reactRouter.UNSAFE_DataRouterContext;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_DataRouterStateContext', {
    enumerable: true,
    get: function () {
      return reactRouter.UNSAFE_DataRouterStateContext;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_LocationContext', {
    enumerable: true,
    get: function () {
      return reactRouter.UNSAFE_LocationContext;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_NavigationContext', {
    enumerable: true,
    get: function () {
      return reactRouter.UNSAFE_NavigationContext;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_RouteContext', {
    enumerable: true,
    get: function () {
      return reactRouter.UNSAFE_RouteContext;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_useRouteId', {
    enumerable: true,
    get: function () {
      return reactRouter.UNSAFE_useRouteId;
    }
  });
  Object.defineProperty(exports, 'createMemoryRouter', {
    enumerable: true,
    get: function () {
      return reactRouter.createMemoryRouter;
    }
  });
  Object.defineProperty(exports, 'createPath', {
    enumerable: true,
    get: function () {
      return reactRouter.createPath;
    }
  });
  Object.defineProperty(exports, 'createRoutesFromChildren', {
    enumerable: true,
    get: function () {
      return reactRouter.createRoutesFromChildren;
    }
  });
  Object.defineProperty(exports, 'createRoutesFromElements', {
    enumerable: true,
    get: function () {
      return reactRouter.createRoutesFromElements;
    }
  });
  Object.defineProperty(exports, 'defer', {
    enumerable: true,
    get: function () {
      return reactRouter.defer;
    }
  });
  Object.defineProperty(exports, 'generatePath', {
    enumerable: true,
    get: function () {
      return reactRouter.generatePath;
    }
  });
  Object.defineProperty(exports, 'isRouteErrorResponse', {
    enumerable: true,
    get: function () {
      return reactRouter.isRouteErrorResponse;
    }
  });
  Object.defineProperty(exports, 'json', {
    enumerable: true,
    get: function () {
      return reactRouter.json;
    }
  });
  Object.defineProperty(exports, 'matchPath', {
    enumerable: true,
    get: function () {
      return reactRouter.matchPath;
    }
  });
  Object.defineProperty(exports, 'matchRoutes', {
    enumerable: true,
    get: function () {
      return reactRouter.matchRoutes;
    }
  });
  Object.defineProperty(exports, 'parsePath', {
    enumerable: true,
    get: function () {
      return reactRouter.parsePath;
    }
  });
  Object.defineProperty(exports, 'redirect', {
    enumerable: true,
    get: function () {
      return reactRouter.redirect;
    }
  });
  Object.defineProperty(exports, 'redirectDocument', {
    enumerable: true,
    get: function () {
      return reactRouter.redirectDocument;
    }
  });
  Object.defineProperty(exports, 'renderMatches', {
    enumerable: true,
    get: function () {
      return reactRouter.renderMatches;
    }
  });
  Object.defineProperty(exports, 'resolvePath', {
    enumerable: true,
    get: function () {
      return reactRouter.resolvePath;
    }
  });
  Object.defineProperty(exports, 'useActionData', {
    enumerable: true,
    get: function () {
      return reactRouter.useActionData;
    }
  });
  Object.defineProperty(exports, 'useAsyncError', {
    enumerable: true,
    get: function () {
      return reactRouter.useAsyncError;
    }
  });
  Object.defineProperty(exports, 'useAsyncValue', {
    enumerable: true,
    get: function () {
      return reactRouter.useAsyncValue;
    }
  });
  Object.defineProperty(exports, 'useBlocker', {
    enumerable: true,
    get: function () {
      return reactRouter.useBlocker;
    }
  });
  Object.defineProperty(exports, 'useHref', {
    enumerable: true,
    get: function () {
      return reactRouter.useHref;
    }
  });
  Object.defineProperty(exports, 'useInRouterContext', {
    enumerable: true,
    get: function () {
      return reactRouter.useInRouterContext;
    }
  });
  Object.defineProperty(exports, 'useLoaderData', {
    enumerable: true,
    get: function () {
      return reactRouter.useLoaderData;
    }
  });
  Object.defineProperty(exports, 'useLocation', {
    enumerable: true,
    get: function () {
      return reactRouter.useLocation;
    }
  });
  Object.defineProperty(exports, 'useMatch', {
    enumerable: true,
    get: function () {
      return reactRouter.useMatch;
    }
  });
  Object.defineProperty(exports, 'useMatches', {
    enumerable: true,
    get: function () {
      return reactRouter.useMatches;
    }
  });
  Object.defineProperty(exports, 'useNavigate', {
    enumerable: true,
    get: function () {
      return reactRouter.useNavigate;
    }
  });
  Object.defineProperty(exports, 'useNavigation', {
    enumerable: true,
    get: function () {
      return reactRouter.useNavigation;
    }
  });
  Object.defineProperty(exports, 'useNavigationType', {
    enumerable: true,
    get: function () {
      return reactRouter.useNavigationType;
    }
  });
  Object.defineProperty(exports, 'useOutlet', {
    enumerable: true,
    get: function () {
      return reactRouter.useOutlet;
    }
  });
  Object.defineProperty(exports, 'useOutletContext', {
    enumerable: true,
    get: function () {
      return reactRouter.useOutletContext;
    }
  });
  Object.defineProperty(exports, 'useParams', {
    enumerable: true,
    get: function () {
      return reactRouter.useParams;
    }
  });
  Object.defineProperty(exports, 'useResolvedPath', {
    enumerable: true,
    get: function () {
      return reactRouter.useResolvedPath;
    }
  });
  Object.defineProperty(exports, 'useRevalidator', {
    enumerable: true,
    get: function () {
      return reactRouter.useRevalidator;
    }
  });
  Object.defineProperty(exports, 'useRouteError', {
    enumerable: true,
    get: function () {
      return reactRouter.useRouteError;
    }
  });
  Object.defineProperty(exports, 'useRouteLoaderData', {
    enumerable: true,
    get: function () {
      return reactRouter.useRouteLoaderData;
    }
  });
  Object.defineProperty(exports, 'useRoutes', {
    enumerable: true,
    get: function () {
      return reactRouter.useRoutes;
    }
  });
  Object.defineProperty(exports, 'UNSAFE_ErrorResponseImpl', {
    enumerable: true,
    get: function () {
      return router.UNSAFE_ErrorResponseImpl;
    }
  });
  exports.BrowserRouter = BrowserRouter;
  exports.Form = Form;
  exports.HashRouter = HashRouter;
  exports.Link = Link;
  exports.NavLink = NavLink;
  exports.RouterProvider = RouterProvider;
  exports.ScrollRestoration = ScrollRestoration;
  exports.UNSAFE_FetchersContext = FetchersContext;
  exports.UNSAFE_ViewTransitionContext = ViewTransitionContext;
  exports.UNSAFE_useScrollRestoration = useScrollRestoration;
  exports.createBrowserRouter = createBrowserRouter;
  exports.createHashRouter = createHashRouter;
  exports.createSearchParams = createSearchParams;
  exports.unstable_HistoryRouter = HistoryRouter;
  exports.unstable_usePrompt = usePrompt;
  exports.unstable_useViewTransitionState = useViewTransitionState;
  exports.useBeforeUnload = useBeforeUnload;
  exports.useFetcher = useFetcher;
  exports.useFetchers = useFetchers;
  exports.useFormAction = useFormAction;
  exports.useLinkClickHandler = useLinkClickHandler;
  exports.useSearchParams = useSearchParams;
  exports.useSubmit = useSubmit;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWZhdWx0TWV0aG9kIiwiZGVmYXVsdEVuY1R5cGUiLCJpc0h0bWxFbGVtZW50Iiwib2JqZWN0IiwidGFnTmFtZSIsImlzQnV0dG9uRWxlbWVudCIsInRvTG93ZXJDYXNlIiwiaXNGb3JtRWxlbWVudCIsImlzSW5wdXRFbGVtZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwic2hvdWxkUHJvY2Vzc0xpbmtDbGljayIsInRhcmdldCIsImJ1dHRvbiIsImNyZWF0ZVNlYXJjaFBhcmFtcyIsImluaXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwibWVtbyIsImtleSIsInZhbHVlIiwiY29uY2F0IiwibWFwIiwidiIsImdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uIiwibG9jYXRpb25TZWFyY2giLCJkZWZhdWx0U2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiZm9yRWFjaCIsIl8iLCJoYXMiLCJnZXRBbGwiLCJhcHBlbmQiLCJfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciIsImlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQiLCJGb3JtRGF0YSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImUiLCJzdXBwb3J0ZWRGb3JtRW5jVHlwZXMiLCJTZXQiLCJnZXRGb3JtRW5jVHlwZSIsImVuY1R5cGUiLCJyb3V0ZXIiLCJVTlNBRkVfd2FybmluZyIsImdldEZvcm1TdWJtaXNzaW9uSW5mbyIsImJhc2VuYW1lIiwibWV0aG9kIiwiYWN0aW9uIiwiZm9ybURhdGEiLCJib2R5IiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsInN0cmlwQmFzZW5hbWUiLCJ0eXBlIiwiZm9ybSIsIkVycm9yIiwibmFtZSIsInByZWZpeCIsInVuZGVmaW5lZCIsIlJFQUNUX1JPVVRFUl9WRVJTSU9OIiwid2luZG93IiwiX19yZWFjdFJvdXRlclZlcnNpb24iLCJjcmVhdGVCcm93c2VyUm91dGVyIiwicm91dGVzIiwib3B0cyIsImNyZWF0ZVJvdXRlciIsImZ1dHVyZSIsIl9leHRlbmRzIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaGlzdG9yeSIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiaHlkcmF0aW9uRGF0YSIsInBhcnNlSHlkcmF0aW9uRGF0YSIsInJlYWN0Um91dGVyIiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsInVuc3RhYmxlX2RhdGFTdHJhdGVneSIsImluaXRpYWxpemUiLCJjcmVhdGVIYXNoUm91dGVyIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJfd2luZG93Iiwic3RhdGUiLCJfX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEiLCJlcnJvcnMiLCJkZXNlcmlhbGl6ZUVycm9ycyIsImVudHJpZXMiLCJzZXJpYWxpemVkIiwidmFsIiwiX190eXBlIiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRhdGEiLCJpbnRlcm5hbCIsIl9fc3ViVHlwZSIsIkVycm9yQ29uc3RydWN0b3IiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsIlZpZXdUcmFuc2l0aW9uQ29udGV4dCIsIlJlYWN0X19uYW1lc3BhY2UiLCJjcmVhdGVDb250ZXh0IiwiaXNUcmFuc2l0aW9uaW5nIiwiZGlzcGxheU5hbWUiLCJGZXRjaGVyc0NvbnRleHQiLCJNYXAiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIkZMVVNIX1NZTkMiLCJmbHVzaFN5bmNJbXBsIiwiUmVhY3RET01fX25hbWVzcGFjZSIsIlVTRV9JRCIsInVzZUlkSW1wbCIsInN0YXJ0VHJhbnNpdGlvblNhZmUiLCJjYiIsImZsdXNoU3luY1NhZmUiLCJEZWZlcnJlZCIsImNvbnN0cnVjdG9yIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhc29uIiwiUm91dGVyUHJvdmlkZXIiLCJfcmVmIiwiZmFsbGJhY2tFbGVtZW50Iiwicm91dGVyJDEiLCJzZXRTdGF0ZUltcGwiLCJ1c2VTdGF0ZSIsInBlbmRpbmdTdGF0ZSIsInNldFBlbmRpbmdTdGF0ZSIsInZ0Q29udGV4dCIsInNldFZ0Q29udGV4dCIsInJlbmRlckRmZCIsInNldFJlbmRlckRmZCIsInRyYW5zaXRpb24iLCJzZXRUcmFuc2l0aW9uIiwiaW50ZXJydXB0aW9uIiwic2V0SW50ZXJydXB0aW9uIiwiZmV0Y2hlckRhdGEiLCJ1c2VSZWYiLCJ2N19zdGFydFRyYW5zaXRpb24iLCJvcHRJblN0YXJ0VHJhbnNpdGlvbiIsInVzZUNhbGxiYWNrIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsIl9yZWYyIiwiZGVsZXRlZEZldGNoZXJzIiwidW5zdGFibGVfZmx1c2hTeW5jIiwiZmx1c2hTeW5jIiwidW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzIiwidmlld1RyYW5zaXRpb25PcHRzIiwiY3VycmVudCIsImRlbGV0ZSIsImZldGNoZXJzIiwiZmV0Y2hlciIsInNldCIsImlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSIsInN0YXJ0Vmlld1RyYW5zaXRpb24iLCJza2lwVHJhbnNpdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsIm5leHRMb2NhdGlvbiIsInQiLCJmaW5pc2hlZCIsImZpbmFsbHkiLCJ1c2VMYXlvdXRFZmZlY3QiLCJzdWJzY3JpYmUiLCJ1c2VFZmZlY3QiLCJyZW5kZXJQcm9taXNlIiwibG9jYXRpb24iLCJ2N19wYXJ0aWFsSHlkcmF0aW9uIiwibmF2aWdhdG9yIiwidXNlTWVtbyIsImNyZWF0ZUhyZWYiLCJlbmNvZGVMb2NhdGlvbiIsImdvIiwibiIsIm5hdmlnYXRlIiwicHVzaCIsInRvIiwicHJldmVudFNjcm9sbFJlc2V0IiwicmVwbGFjZSIsImRhdGFSb3V0ZXJDb250ZXh0Iiwic3RhdGljIiwiRnJhZ21lbnQiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiUm91dGVyIiwibmF2aWdhdGlvblR5cGUiLCJoaXN0b3J5QWN0aW9uIiwidjdfcmVsYXRpdmVTcGxhdFBhdGgiLCJpbml0aWFsaXplZCIsIkRhdGFSb3V0ZXMiLCJfcmVmMyIsIlVOU0FGRV91c2VSb3V0ZXNJbXBsIiwiQnJvd3NlclJvdXRlciIsIl9yZWY0IiwiY2hpbGRyZW4iLCJoaXN0b3J5UmVmIiwidjVDb21wYXQiLCJsaXN0ZW4iLCJIYXNoUm91dGVyIiwiX3JlZjUiLCJIaXN0b3J5Um91dGVyIiwiX3JlZjYiLCJpc0Jyb3dzZXIiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtXaXRoUmVmIiwiX3JlZjciLCJyZWYiLCJvbkNsaWNrIiwicmVsYXRpdmUiLCJyZWxvYWREb2N1bWVudCIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uIiwicmVzdCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2V4Y2x1ZGVkIiwidXNlQ29udGV4dCIsIlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCIsImFic29sdXRlSHJlZiIsImlzRXh0ZXJuYWwiLCJ0ZXN0IiwiY3VycmVudFVybCIsIlVSTCIsImhyZWYiLCJ0YXJnZXRVcmwiLCJzdGFydHNXaXRoIiwicHJvdG9jb2wiLCJwYXRoIiwicGF0aG5hbWUiLCJvcmlnaW4iLCJzZWFyY2giLCJoYXNoIiwidXNlSHJlZiIsImludGVybmFsT25DbGljayIsInVzZUxpbmtDbGlja0hhbmRsZXIiLCJoYW5kbGVDbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJOYXZMaW5rIiwiTmF2TGlua1dpdGhSZWYiLCJfcmVmOCIsImFyaWFDdXJyZW50UHJvcCIsImNhc2VTZW5zaXRpdmUiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcm9wIiwiZW5kIiwic3R5bGUiLCJzdHlsZVByb3AiLCJfZXhjbHVkZWQyIiwidXNlUmVzb2x2ZWRQYXRoIiwidXNlTG9jYXRpb24iLCJyb3V0ZXJTdGF0ZSIsInVzZVZpZXdUcmFuc2l0aW9uU3RhdGUiLCJ0b1BhdGhuYW1lIiwibG9jYXRpb25QYXRobmFtZSIsIm5leHRMb2NhdGlvblBhdGhuYW1lIiwibmF2aWdhdGlvbiIsImVuZFNsYXNoUG9zaXRpb24iLCJlbmRzV2l0aCIsImxlbmd0aCIsImlzQWN0aXZlIiwiY2hhckF0IiwiaXNQZW5kaW5nIiwicmVuZGVyUHJvcHMiLCJhcmlhQ3VycmVudCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiRm9ybSIsIl9yZWY5IiwiZm9yd2FyZGVkUmVmIiwiZmV0Y2hlcktleSIsIm9uU3VibWl0IiwicHJvcHMiLCJfZXhjbHVkZWQzIiwic3VibWl0IiwidXNlU3VibWl0IiwiZm9ybUFjdGlvbiIsInVzZUZvcm1BY3Rpb24iLCJmb3JtTWV0aG9kIiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0IiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmMTAiLCJnZXRLZXkiLCJzdG9yYWdlS2V5IiwidXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJEYXRhUm91dGVySG9vayIsIkRhdGFSb3V0ZXJTdGF0ZUhvb2siLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yIiwiaG9va05hbWUiLCJ1c2VEYXRhUm91dGVyQ29udGV4dCIsImN0eCIsIlVOU0FGRV9pbnZhcmlhbnQiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJfdGVtcCIsInJlcGxhY2VQcm9wIiwidXNlTmF2aWdhdGUiLCJjcmVhdGVQYXRoIiwidXNlU2VhcmNoUGFyYW1zIiwiZGVmYXVsdEluaXQiLCJkZWZhdWx0U2VhcmNoUGFyYW1zUmVmIiwiaGFzU2V0U2VhcmNoUGFyYW1zUmVmIiwic2V0U2VhcmNoUGFyYW1zIiwibmV4dEluaXQiLCJuYXZpZ2F0ZU9wdGlvbnMiLCJuZXdTZWFyY2hQYXJhbXMiLCJ2YWxpZGF0ZUNsaWVudFNpZGVTdWJtaXNzaW9uIiwiZmV0Y2hlcklkIiwiZ2V0VW5pcXVlRmV0Y2hlcklkIiwiU3RyaW5nIiwiVXNlU3VibWl0IiwiY3VycmVudFJvdXRlSWQiLCJVTlNBRkVfdXNlUm91dGVJZCIsIm9wdGlvbnMiLCJmZXRjaCIsImZvcm1FbmNUeXBlIiwiZnJvbVJvdXRlSWQiLCJfdGVtcDIiLCJyb3V0ZUNvbnRleHQiLCJVTlNBRkVfUm91dGVDb250ZXh0IiwibWF0Y2giLCJtYXRjaGVzIiwic2xpY2UiLCJwYXJhbXMiLCJnZXQiLCJ0b1N0cmluZyIsInJvdXRlIiwiaW5kZXgiLCJqb2luUGF0aHMiLCJ1c2VGZXRjaGVyIiwiX3RlbXAzIiwiX3JvdXRlJG1hdGNoZXMiLCJVc2VGZXRjaGVyIiwicm91dGVJZCIsImlkIiwiZGVmYXVsdEtleSIsInNldEZldGNoZXJLZXkiLCJnZXRGZXRjaGVyIiwiZGVsZXRlRmV0Y2hlciIsImxvYWQiLCJzdWJtaXRJbXBsIiwiRmV0Y2hlckZvcm0iLCJJRExFX0ZFVENIRVIiLCJmZXRjaGVyV2l0aENvbXBvbmVudHMiLCJ1c2VGZXRjaGVycyIsIlVzZUZldGNoZXJzIiwiZnJvbSIsIl9yZWYxMSIsIlNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiX3RlbXA0IiwiVXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGlvbiIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlc3Npb25Qb3NpdGlvbnMiLCJnZXRJdGVtIiwicGFyc2UiLCJnZXRLZXlXaXRob3V0QmFzZW5hbWUiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsImRlY29kZVVSSUNvbXBvbmVudCIsInNjcm9sbEludG9WaWV3IiwidXNlQmVmb3JlVW5sb2FkIiwiY2FsbGJhY2siLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VQcm9tcHQiLCJfcmVmMTIiLCJ3aGVuIiwiYmxvY2tlciIsInVzZUJsb2NrZXIiLCJwcm9jZWVkIiwiY29uZmlybSIsInNldFRpbWVvdXQiLCJyZXNldCIsImN1cnJlbnRQYXRoIiwibmV4dFBhdGgiLCJtYXRjaFBhdGgiXSwic291cmNlcyI6WyIuLi8uLi9kb20udHMiLCIuLi8uLi9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBGb3JtRW5jVHlwZSxcbiAgSFRNTEZvcm1NZXRob2QsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHsgc3RyaXBCYXNlbmFtZSwgVU5TQUZFX3dhcm5pbmcgYXMgd2FybmluZyB9IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdE1ldGhvZDogSFRNTEZvcm1NZXRob2QgPSBcImdldFwiO1xuY29uc3QgZGVmYXVsdEVuY1R5cGU6IEZvcm1FbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTEVsZW1lbnQge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxCdXR0b25FbGVtZW50IHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBIVE1MRm9ybUVsZW1lbnQge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTElucHV0RWxlbWVudCB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuXG50eXBlIExpbWl0ZWRNb3VzZUV2ZW50ID0gUGljazxcbiAgTW91c2VFdmVudCxcbiAgXCJidXR0b25cIiB8IFwibWV0YUtleVwiIHwgXCJhbHRLZXlcIiB8IFwiY3RybEtleVwiIHwgXCJzaGlmdEtleVwiXG4+O1xuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IExpbWl0ZWRNb3VzZUV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soXG4gIGV2ZW50OiBMaW1pdGVkTW91c2VFdmVudCxcbiAgdGFyZ2V0Pzogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIChcbiAgICBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1LZXlWYWx1ZVBhaXIgPSBbc3RyaW5nLCBzdHJpbmddO1xuXG5leHBvcnQgdHlwZSBVUkxTZWFyY2hQYXJhbXNJbml0ID1cbiAgfCBzdHJpbmdcbiAgfCBQYXJhbUtleVZhbHVlUGFpcltdXG4gIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+XG4gIHwgVVJMU2VhcmNoUGFyYW1zO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gIGluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQgPSBcIlwiXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIEFycmF5LmlzQXJyYXkoaW5pdCkgfHxcbiAgICBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICA/IGluaXRcbiAgICAgIDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKHYpID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgW10gYXMgUGFyYW1LZXlWYWx1ZVBhaXJbXSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKFxuICBsb2NhdGlvblNlYXJjaDogc3RyaW5nLFxuICBkZWZhdWx0U2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMgfCBudWxsXG4pIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCk7XG5cbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICAvLyBVc2UgYGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCguLi4pYCBoZXJlIGluc3RlYWQgb2YgaXRlcmF0aW5nIG9mXG4gICAgLy8gYGRlZmF1bHRTZWFyY2hQYXJhbXMua2V5cygpYCB0byB3b3JrLWFyb3VuZCBhIGJ1ZyBpbiBGaXJlZm94IHJlbGF0ZWQgdG9cbiAgICAvLyB3ZWIgZXh0ZW5zaW9ucy4gUmVsZXZhbnQgQnVnemlsbGEgdGlja2V0czpcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDE0NjAyXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyMzk4NFxuICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuXG4vLyBUaGFua3MgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy90eXBlLWZlc3QhXG50eXBlIEpzb25PYmplY3QgPSB7IFtLZXkgaW4gc3RyaW5nXTogSnNvblZhbHVlIH0gJiB7XG4gIFtLZXkgaW4gc3RyaW5nXT86IEpzb25WYWx1ZSB8IHVuZGVmaW5lZDtcbn07XG50eXBlIEpzb25BcnJheSA9IEpzb25WYWx1ZVtdIHwgcmVhZG9ubHkgSnNvblZhbHVlW107XG50eXBlIEpzb25QcmltaXRpdmUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbDtcbnR5cGUgSnNvblZhbHVlID0gSnNvblByaW1pdGl2ZSB8IEpzb25PYmplY3QgfCBKc29uQXJyYXk7XG5cbmV4cG9ydCB0eXBlIFN1Ym1pdFRhcmdldCA9XG4gIHwgSFRNTEZvcm1FbGVtZW50XG4gIHwgSFRNTEJ1dHRvbkVsZW1lbnRcbiAgfCBIVE1MSW5wdXRFbGVtZW50XG4gIHwgRm9ybURhdGFcbiAgfCBVUkxTZWFyY2hQYXJhbXNcbiAgfCBKc29uVmFsdWVcbiAgfCBudWxsO1xuXG4vLyBPbmUtdGltZSBjaGVjayBmb3Igc3VibWl0dGVyIHN1cHBvcnRcbmxldCBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkge1xuICBpZiAoX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZvcm1EYXRhKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZiBGb3JtRGF0YSBzdXBwb3J0cyB0aGUgc3VibWl0dGVyIHBhcmFtZXRlciwgdGhpcyB3aWxsIHRocm93XG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEhUVFAgbWV0aG9kIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIG1ldGhvZD5gLlxuICAgKiBEZWZhdWx0cyB0byBcIkdFVFwiLlxuICAgKi9cbiAgbWV0aG9kPzogSFRNTEZvcm1NZXRob2Q7XG5cbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gVVJMIHBhdGggdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0uIE92ZXJyaWRlcyBgPGZvcm0gYWN0aW9uPmAuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBwYXRoIG9mIHRoZSBjdXJyZW50IHJvdXRlLlxuICAgKi9cbiAgYWN0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZW5jb2RpbmcgdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0uIE92ZXJyaWRlcyBgPGZvcm0gZW5jVHlwZT5gLlxuICAgKiBEZWZhdWx0cyB0byBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLlxuICAgKi9cbiAgZW5jVHlwZT86IEZvcm1FbmNUeXBlO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSBhIHNwZWNpZmljIGZldGNoZXJLZXkgdG8gdXNlIHdoZW4gdXNpbmcgbmF2aWdhdGU9ZmFsc2VcbiAgICovXG4gIGZldGNoZXJLZXk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hdmlnYXRlPWZhbHNlIHdpbGwgdXNlIGEgZmV0Y2hlciBpbnN0ZWFkIG9mIGEgbmF2aWdhdGlvblxuICAgKi9cbiAgbmF2aWdhdGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZXQgYHRydWVgIHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgZW50cnkgaW4gdGhlIGJyb3dzZXIncyBoaXN0b3J5IHN0YWNrXG4gICAqIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lIChpLmUuIHN0YXkgb24gXCJ0aGUgc2FtZSBwYWdlXCIpLiBEZWZhdWx0c1xuICAgKiB0byBgZmFsc2VgLlxuICAgKi9cbiAgcmVwbGFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFN0YXRlIG9iamVjdCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RhY2sgZW50cnkgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgKi9cbiAgc3RhdGU/OiBhbnk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZm9ybSBhY3Rpb24gaXMgcmVsYXRpdmUgdG8gdGhlIHJvdXRlIGhpZXJhcmNoeSBvclxuICAgKiB0aGUgcGF0aG5hbWUuICBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBvcHQgb3V0IG9mIG5hdmlnYXRpbmcgdGhlIHJvdXRlXG4gICAqIGhpZXJhcmNoeSBhbmQgd2FudCB0byBpbnN0ZWFkIHJvdXRlIGJhc2VkIG9uIC8tZGVsaW1pdGVkIFVSTCBzZWdtZW50c1xuICAgKi9cbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuXG4gIC8qKlxuICAgKiBJbiBicm93c2VyLWJhc2VkIGVudmlyb25tZW50cywgcHJldmVudCByZXNldHRpbmcgc2Nyb2xsIGFmdGVyIHRoaXNcbiAgICogbmF2aWdhdGlvbiB3aGVuIHVzaW5nIHRoZSA8U2Nyb2xsUmVzdG9yYXRpb24+IGNvbXBvbmVudFxuICAgKi9cbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlIGZsdXNoU3luYyBmb3IgdGhpcyBuYXZpZ2F0aW9uJ3Mgc3RhdGUgdXBkYXRlc1xuICAgKi9cbiAgdW5zdGFibGVfZmx1c2hTeW5jPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlIHZpZXcgdHJhbnNpdGlvbnMgb24gdGhpcyBzdWJtaXNzaW9uIG5hdmlnYXRpb25cbiAgICovXG4gIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPzogYm9vbGVhbjtcbn1cblxuY29uc3Qgc3VwcG9ydGVkRm9ybUVuY1R5cGVzOiBTZXQ8Rm9ybUVuY1R5cGU+ID0gbmV3IFNldChbXG4gIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxuICBcInRleHQvcGxhaW5cIixcbl0pO1xuXG5mdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSBhcyBGb3JtRW5jVHlwZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgXCIke2VuY1R5cGV9XCIgaXMgbm90IGEgdmFsaWQgXFxgZW5jVHlwZVxcYCBmb3IgXFxgPEZvcm0+XFxgL1xcYDxmZXRjaGVyLkZvcm0+XFxgIGAgK1xuICAgICAgICBgYW5kIHdpbGwgZGVmYXVsdCB0byBcIiR7ZGVmYXVsdEVuY1R5cGV9XCJgXG4gICAgKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbmNUeXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICB0YXJnZXQ6IFN1Ym1pdFRhcmdldCxcbiAgYmFzZW5hbWU6IHN0cmluZ1xuKToge1xuICBhY3Rpb246IHN0cmluZyB8IG51bGw7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBlbmNUeXBlOiBzdHJpbmc7XG4gIGZvcm1EYXRhOiBGb3JtRGF0YSB8IHVuZGVmaW5lZDtcbiAgYm9keTogYW55O1xufSB7XG4gIGxldCBtZXRob2Q6IHN0cmluZztcbiAgbGV0IGFjdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgbGV0IGVuY1R5cGU6IHN0cmluZztcbiAgbGV0IGZvcm1EYXRhOiBGb3JtRGF0YSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJvZHk6IGFueTtcblxuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuXG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcbiAgfSBlbHNlIGlmIChcbiAgICBpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fFxuICAgIChpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmXG4gICAgICAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpXG4gICkge1xuICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG5cbiAgICBpZiAoZm9ybSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gb3IgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gd2l0aG91dCBhIDxmb3JtPmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG5cbiAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAvLyBwcmVmaXhlZCB0byBlbnN1cmUgbm9uLUpTIHNjZW5hcmlvcyB3b3JrLCBzbyBzdHJpcCBpdCBzaW5jZSB3ZSdsbFxuICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuXG4gICAgbWV0aG9kID1cbiAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8XG4gICAgICBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fFxuICAgICAgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID1cbiAgICAgIGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHxcbiAgICAgIGdldEZvcm1FbmNUeXBlKGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHxcbiAgICAgIGRlZmF1bHRFbmNUeXBlO1xuXG4gICAgLy8gQnVpbGQgYSBGb3JtRGF0YSBvYmplY3QgcG9wdWxhdGVkIGZyb20gYSBmb3JtIGFuZCBzdWJtaXR0ZXJcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuXG4gICAgLy8gSWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgYEZvcm1EYXRhKGVsLCBzdWJtaXR0ZXIpYCBmb3JtYXQsXG4gICAgLy8gdGhlbiB0YWNrIG9uIHRoZSBzdWJtaXR0ZXIgdmFsdWUgYXQgdGhlIGVuZC4gIFRoaXMgaXMgYSBsaWdodHdlaWdodFxuICAgIC8vIHNvbHV0aW9uIHRoYXQgaXMgbm90IDEwMCUgc3BlYyBjb21wbGlhbnQuICBGb3IgY29tcGxldGUgc3VwcG9ydCBpbiBvbGRlclxuICAgIC8vIGJyb3dzZXJzLCBjb25zaWRlciB1c2luZyB0aGUgYGZvcm1kYXRhLXN1Ym1pdHRlci1wb2x5ZmlsbGAgcGFja2FnZVxuICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICBsZXQgeyBuYW1lLCB0eXBlLCB2YWx1ZSB9ID0gdGFyZ2V0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IGAke25hbWV9LmAgOiBcIlwiO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXhgLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eWAsIFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIGAgK1xuICAgICAgICBgPGlucHV0IHR5cGU9XCJzdWJtaXR8aW1hZ2VcIj5gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG51bGw7XG4gICAgZW5jVHlwZSA9IGRlZmF1bHRFbmNUeXBlO1xuICAgIGJvZHkgPSB0YXJnZXQ7XG4gIH1cblxuICAvLyBTZW5kIGJvZHkgZm9yIDxGb3JtIGVuY1R5cGU9XCJ0ZXh0L3BsYWluXCIgc28gd2UgZW5jb2RlIGl0IGludG8gdGV4dFxuICBpZiAoZm9ybURhdGEgJiYgZW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICBib2R5ID0gZm9ybURhdGE7XG4gICAgZm9ybURhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4geyBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH07XG59XG4iLCIvKipcbiAqIE5PVEU6IElmIHlvdSByZWZhY3RvciB0aGlzIHRvIHNwbGl0IHVwIHRoZSBtb2R1bGVzIGludG8gc2VwYXJhdGUgZmlsZXMsXG4gKiB5b3UnbGwgbmVlZCB0byB1cGRhdGUgdGhlIHJvbGx1cCBjb25maWcgZm9yIHJlYWN0LXJvdXRlci1kb20tdjUtY29tcGF0LlxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJvdXRlT2JqZWN0LFxuICBGdXR1cmVDb25maWcsXG4gIExvY2F0aW9uLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBOYXZpZ2F0b3IsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZXJQcm92aWRlclByb3BzLFxuICBUbyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHtcbiAgUm91dGVyLFxuICBjcmVhdGVQYXRoLFxuICB1c2VIcmVmLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlQmxvY2tlcixcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IGFzIERhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQgYXMgTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQgYXMgUm91dGVDb250ZXh0LFxuICBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIGFzIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgVU5TQUZFX3VzZVJvdXRlSWQgYXMgdXNlUm91dGVJZCxcbiAgVU5TQUZFX3VzZVJvdXRlc0ltcGwgYXMgdXNlUm91dGVzSW1wbCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHR5cGUge1xuICBCcm93c2VySGlzdG9yeSxcbiAgdW5zdGFibGVfRGF0YVN0cmF0ZWd5RnVuY3Rpb24sXG4gIHVuc3RhYmxlX0RhdGFTdHJhdGVneUZ1bmN0aW9uQXJncyxcbiAgdW5zdGFibGVfRGF0YVN0cmF0ZWd5TWF0Y2gsXG4gIEZldGNoZXIsXG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBGdXR1cmVDb25maWcgYXMgUm91dGVyRnV0dXJlQ29uZmlnLFxuICBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uLFxuICBIYXNoSGlzdG9yeSxcbiAgSGlzdG9yeSxcbiAgSFRNTEZvcm1NZXRob2QsXG4gIEh5ZHJhdGlvblN0YXRlLFxuICBSb3V0ZXIgYXMgUmVtaXhSb3V0ZXIsXG4gIFY3X0Zvcm1NZXRob2QsXG4gIFJvdXRlclN0YXRlLFxuICBSb3V0ZXJTdWJzY3JpYmVyLFxuICBCbG9ja2VyRnVuY3Rpb24sXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlUm91dGVyLFxuICBjcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgY3JlYXRlSGFzaEhpc3RvcnksXG4gIGpvaW5QYXRocyxcbiAgc3RyaXBCYXNlbmFtZSxcbiAgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIGFzIEVycm9yUmVzcG9uc2VJbXBsLFxuICBVTlNBRkVfaW52YXJpYW50IGFzIGludmFyaWFudCxcbiAgVU5TQUZFX3dhcm5pbmcgYXMgd2FybmluZyxcbiAgbWF0Y2hQYXRoLFxuICBJRExFX0ZFVENIRVIsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIFN1Ym1pdE9wdGlvbnMsXG4gIFBhcmFtS2V5VmFsdWVQYWlyLFxuICBVUkxTZWFyY2hQYXJhbXNJbml0LFxuICBTdWJtaXRUYXJnZXQsXG59IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBkZWZhdWx0TWV0aG9kLFxuICBnZXRGb3JtU3VibWlzc2lvbkluZm8sXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uLFxuICBzaG91bGRQcm9jZXNzTGlua0NsaWNrLFxufSBmcm9tIFwiLi9kb21cIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSZS1leHBvcnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSB7XG4gIHVuc3RhYmxlX0RhdGFTdHJhdGVneUZ1bmN0aW9uLFxuICB1bnN0YWJsZV9EYXRhU3RyYXRlZ3lGdW5jdGlvbkFyZ3MsXG4gIHVuc3RhYmxlX0RhdGFTdHJhdGVneU1hdGNoLFxuICBGb3JtRW5jVHlwZSxcbiAgRm9ybU1ldGhvZCxcbiAgR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbixcbiAgUGFyYW1LZXlWYWx1ZVBhaXIsXG4gIFN1Ym1pdE9wdGlvbnMsXG4gIFVSTFNlYXJjaFBhcmFtc0luaXQsXG4gIFY3X0Zvcm1NZXRob2QsXG59O1xuZXhwb3J0IHsgY3JlYXRlU2VhcmNoUGFyYW1zLCBFcnJvclJlc3BvbnNlSW1wbCBhcyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwgfTtcblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEF3YWl0UHJvcHMsXG4gIEJsb2NrZXIsXG4gIEJsb2NrZXJGdW5jdGlvbixcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgRXJyb3JSZXNwb25zZSxcbiAgRmV0Y2hlcixcbiAgRnV0dXJlQ29uZmlnLFxuICBIYXNoLFxuICBJbmRleFJvdXRlT2JqZWN0LFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIEpzb25GdW5jdGlvbixcbiAgTGF6eVJvdXRlRnVuY3Rpb24sXG4gIExheW91dFJvdXRlUHJvcHMsXG4gIExvYWRlckZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbkFyZ3MsXG4gIExvY2F0aW9uLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0aW9uLFxuICBOYXZpZ2F0b3IsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbXMsXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aG5hbWUsXG4gIFBhdGhQYXJhbSxcbiAgUGF0aFBhdHRlcm4sXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBSZWRpcmVjdEZ1bmN0aW9uLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUm91dGVQcm9wcyxcbiAgUm91dGVyUHJvcHMsXG4gIFJvdXRlclByb3ZpZGVyUHJvcHMsXG4gIFJvdXRlc1Byb3BzLFxuICBTZWFyY2gsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyxcbiAgVG8sXG4gIFVJTWF0Y2gsXG4gIHVuc3RhYmxlX0hhbmRsZXJSZXN1bHQsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmV4cG9ydCB7XG4gIEFib3J0ZWREZWZlcnJlZEVycm9yLFxuICBBd2FpdCxcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgTmF2aWdhdGlvblR5cGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBkZWZlcixcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGdlbmVyYXRlUGF0aCxcbiAganNvbixcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUJsb2NrZXIsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBVTlNBRkVfdXNlUm91dGVJZCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuLy8jZW5kcmVnaW9uXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgdmFyIF9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTogSHlkcmF0aW9uU3RhdGUgfCB1bmRlZmluZWQ7XG4gIHZhciBfX3JlYWN0Um91dGVyVmVyc2lvbjogc3RyaW5nO1xuICBpbnRlcmZhY2UgRG9jdW1lbnQge1xuICAgIHN0YXJ0Vmlld1RyYW5zaXRpb24oY2I6ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkKTogVmlld1RyYW5zaXRpb247XG4gIH1cbn1cblxuLy8gSEVZIFlPVSEgRE9OJ1QgVE9VQ0ggVEhJUyBWQVJJQUJMRSFcbi8vXG4vLyBJdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBwcm9wZXIgdmVyc2lvbiBhdCBidWlsZCB0aW1lIHZpYSBhIGJhYmVsIHBsdWdpbiBpblxuLy8gdGhlIHJvbGx1cCBjb25maWcuXG4vL1xuLy8gRXhwb3J0IGEgZ2xvYmFsIHByb3BlcnR5IG9udG8gdGhlIHdpbmRvdyBmb3IgUmVhY3QgUm91dGVyIGRldGVjdGlvbiBieSB0aGVcbi8vIENvcmUgV2ViIFZpdGFscyBUZWNobm9sb2d5IFJlcG9ydC4gIFRoaXMgd2F5IHRoZXkgY2FuIGNvbmZpZ3VyZSB0aGUgYHdhcHBhbHl6ZXJgXG4vLyB0byBkZXRlY3QgYW5kIHByb3Blcmx5IGNsYXNzaWZ5IGxpdmUgd2Vic2l0ZXMgYXMgYmVpbmcgYnVpbHQgd2l0aCBSZWFjdCBSb3V0ZXI6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vSFRUUEFyY2hpdmUvd2FwcGFseXplci9ibG9iL21haW4vc3JjL3RlY2hub2xvZ2llcy9yLmpzb25cbmNvbnN0IFJFQUNUX1JPVVRFUl9WRVJTSU9OID0gXCIwXCI7XG50cnkge1xuICB3aW5kb3cuX19yZWFjdFJvdXRlclZlcnNpb24gPSBSRUFDVF9ST1VURVJfVkVSU0lPTjtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gbm8tb3Bcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSb3V0ZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5pbnRlcmZhY2UgRE9NUm91dGVyT3B0cyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBmdXR1cmU/OiBQYXJ0aWFsPE9taXQ8Um91dGVyRnV0dXJlQ29uZmlnLCBcInY3X3ByZXBlbmRCYXNlbmFtZVwiPj47XG4gIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5PzogdW5zdGFibGVfRGF0YVN0cmF0ZWd5RnVuY3Rpb247XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IERPTVJvdXRlck9wdHNcbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5OiBvcHRzPy51bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3csXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IERPTVJvdXRlck9wdHNcbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5OiBvcHRzPy51bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3csXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCk6IEh5ZHJhdGlvblN0YXRlIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhcbiAgZXJyb3JzOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdXG4pOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIC8vIEhleSB5b3UhICBJZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSBjaGFuZ2UgdGhlIGNvcnJlc3BvbmRpbmcgbG9naWMgaW5cbiAgICAvLyBzZXJpYWxpemVFcnJvcnMgaW4gcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIudHN4IDopXG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbnN0cnVjdCB0aGUgcmlnaHQgdHlwZSBvZiBFcnJvciAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpXG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBuby1vcCAtIGZhbGwgdGhyb3VnaCBhbmQgY3JlYXRlIGEgbm9ybWFsIEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBDb250ZXh0c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudHlwZSBWaWV3VHJhbnNpdGlvbkNvbnRleHRPYmplY3QgPVxuICB8IHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2U7XG4gICAgfVxuICB8IHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZTtcbiAgICAgIGZsdXNoU3luYzogYm9vbGVhbjtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gICAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICAgIH07XG5cbmNvbnN0IFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Vmlld1RyYW5zaXRpb25Db250ZXh0T2JqZWN0Pih7XG4gIGlzVHJhbnNpdGlvbmluZzogZmFsc2UsXG59KTtcbmlmIChfX0RFVl9fKSB7XG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbn1cblxuZXhwb3J0IHsgVmlld1RyYW5zaXRpb25Db250ZXh0IGFzIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQgfTtcblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIHVzZUZldGNoZXIgZGF0YSBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxudHlwZSBGZXRjaGVyc0NvbnRleHRPYmplY3QgPSBNYXA8c3RyaW5nLCBhbnk+O1xuXG5jb25zdCBGZXRjaGVyc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PEZldGNoZXJzQ29udGV4dE9iamVjdD4obmV3IE1hcCgpKTtcbmlmIChfX0RFVl9fKSB7XG4gIEZldGNoZXJzQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRmV0Y2hlcnNcIjtcbn1cblxuZXhwb3J0IHsgRmV0Y2hlcnNDb250ZXh0IGFzIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQgfTtcblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQ29tcG9uZW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICogaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBIb3dldmVyLCB0aGF0IGludHJvZHVjZXMgd2VicGFjay90ZXJzZXIgbWluaWZpY2F0aW9uIGlzc3VlcyBpbiBwcm9kdWN0aW9uIGJ1aWxkc1xuICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gIHRoaXMgZXhwb3J0ZWQgcmVmZXJlbmNlIG9uY2UgdXAgZnJvbnQgcmVzb2x2ZXMgdGhhdCBpc3N1ZS5cblxuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4qL1xuY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG5jb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl07XG5jb25zdCBGTFVTSF9TWU5DID0gXCJmbHVzaFN5bmNcIjtcbmNvbnN0IGZsdXNoU3luY0ltcGwgPSBSZWFjdERPTVtGTFVTSF9TWU5DXTtcbmNvbnN0IFVTRV9JRCA9IFwidXNlSWRcIjtcbmNvbnN0IHVzZUlkSW1wbCA9IFJlYWN0W1VTRV9JRF07XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2I6ICgpID0+IHZvaWQpIHtcbiAgaWYgKHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICBzdGFydFRyYW5zaXRpb25JbXBsKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU3luY1NhZmUoY2I6ICgpID0+IHZvaWQpIHtcbiAgaWYgKGZsdXNoU3luY0ltcGwpIHtcbiAgICBmbHVzaFN5bmNJbXBsKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmludGVyZmFjZSBWaWV3VHJhbnNpdGlvbiB7XG4gIGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+O1xuICByZWFkeTogUHJvbWlzZTx2b2lkPjtcbiAgdXBkYXRlQ2FsbGJhY2tEb25lOiBQcm9taXNlPHZvaWQ+O1xuICBza2lwVHJhbnNpdGlvbigpOiB2b2lkO1xufVxuXG5jbGFzcyBEZWZlcnJlZDxUPiB7XG4gIHN0YXR1czogXCJwZW5kaW5nXCIgfCBcInJlc29sdmVkXCIgfCBcInJlamVjdGVkXCIgPSBcInBlbmRpbmdcIjtcbiAgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGluaXRpYWxpemVyXG4gIHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZDtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGluaXRpYWxpemVyXG4gIHJlamVjdDogKHJlYXNvbj86IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlc29sdmVkXCI7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKHtcbiAgZmFsbGJhY2tFbGVtZW50LFxuICByb3V0ZXIsXG4gIGZ1dHVyZSxcbn06IFJvdXRlclByb3ZpZGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZTxSb3V0ZXJTdGF0ZT4oKTtcbiAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZTxWaWV3VHJhbnNpdGlvbkNvbnRleHRPYmplY3Q+KHtcbiAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlLFxuICB9KTtcbiAgbGV0IFtyZW5kZXJEZmQsIHNldFJlbmRlckRmZF0gPSBSZWFjdC51c2VTdGF0ZTxEZWZlcnJlZDx2b2lkPj4oKTtcbiAgbGV0IFt0cmFuc2l0aW9uLCBzZXRUcmFuc2l0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPFZpZXdUcmFuc2l0aW9uPigpO1xuICBsZXQgW2ludGVycnVwdGlvbiwgc2V0SW50ZXJydXB0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPHtcbiAgICBzdGF0ZTogUm91dGVyU3RhdGU7XG4gICAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICB9PigpO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdC51c2VSZWY8TWFwPHN0cmluZywgYW55Pj4obmV3IE1hcCgpKTtcbiAgbGV0IHsgdjdfc3RhcnRUcmFuc2l0aW9uIH0gPSBmdXR1cmUgfHwge307XG5cbiAgbGV0IG9wdEluU3RhcnRUcmFuc2l0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGNiOiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFt2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2s8Um91dGVyU3Vic2NyaWJlcj4oXG4gICAgKFxuICAgICAgbmV3U3RhdGU6IFJvdXRlclN0YXRlLFxuICAgICAge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnMsXG4gICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IHZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgIH1cbiAgICApID0+IHtcbiAgICAgIGRlbGV0ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IGZldGNoZXJEYXRhLmN1cnJlbnQuZGVsZXRlKGtleSkpO1xuICAgICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZldGNoZXJEYXRhLmN1cnJlbnQuc2V0KGtleSwgZmV0Y2hlci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGxldCBpc1ZpZXdUcmFuc2l0aW9uVW5hdmFpbGFibGUgPVxuICAgICAgICByb3V0ZXIud2luZG93ID09IG51bGwgfHxcbiAgICAgICAgcm91dGVyLndpbmRvdy5kb2N1bWVudCA9PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24gIT09IFwiZnVuY3Rpb25cIjtcblxuICAgICAgLy8gSWYgdGhpcyBpc24ndCBhIHZpZXcgdHJhbnNpdGlvbiBvciBpdCdzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLFxuICAgICAgLy8ganVzdCB1cGRhdGUgYW5kIGJlIGRvbmUgd2l0aCBpdFxuICAgICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlKSB7XG4gICAgICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdEluU3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZmx1c2hTeW5jICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgICAgaWYgKGZsdXNoU3luYykge1xuICAgICAgICAvLyBGbHVzaCB0aHJvdWdoIHRoZSBjb250ZXh0IHRvIG1hcmsgRE9NIGVsZW1lbnRzIGFzIHRyYW5zaXRpb249aW5nXG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4ge1xuICAgICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyB0cmFuc2l0aW9uc1xuICAgICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZsdXNoU3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBET01cbiAgICAgICAgbGV0IHQgPSByb3V0ZXIud2luZG93IS5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbGVhbiB1cCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuICAgICAgICB0LmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4ge1xuICAgICAgICAgICAgc2V0UmVuZGVyRGZkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRQZW5kaW5nU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHNldFZ0Q29udGV4dCh7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnRUcmFuc2l0aW9uICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgLy8gSW50ZXJydXB0aW5nIGFuIGluLXByb2dyZXNzIHRyYW5zaXRpb24sIGNhbmNlbCBhbmQgbGV0IGV2ZXJ5dGhpbmcgZmx1c2hcbiAgICAgICAgLy8gb3V0LCBhbmQgdGhlbiBraWNrIG9mZiBhIG5ldyB0cmFuc2l0aW9uIGZyb20gdGhlIGludGVycnVwdGlvbiBzdGF0ZVxuICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbXBsZXRlZCBuYXZpZ2F0aW9uIHVwZGF0ZSB3aXRoIG9wdGVkLWluIHZpZXcgdHJhbnNpdGlvbnMsIGxldCAnZXIgcmlwXG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLndpbmRvdywgdHJhbnNpdGlvbiwgcmVuZGVyRGZkLCBmZXRjaGVyRGF0YSwgb3B0SW5TdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgLy8gTmVlZCB0byB1c2UgYSBsYXlvdXQgZWZmZWN0IGhlcmUgc28gd2UgYXJlIHN1YnNjcmliZWQgZWFybHkgZW5vdWdoIHRvXG4gIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuXG4gIC8vIFdoZW4gd2Ugc3RhcnQgYSB2aWV3IHRyYW5zaXRpb24sIGNyZWF0ZSBhIERlZmVycmVkIHdlIGNhbiB1c2UgZm9yIHRoZVxuICAvLyBldmVudHVhbCBcImNvbXBsZXRlZFwiIHJlbmRlclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmICF2dENvbnRleHQuZmx1c2hTeW5jKSB7XG4gICAgICBzZXRSZW5kZXJEZmQobmV3IERlZmVycmVkPHZvaWQ+KCkpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dF0pO1xuXG4gIC8vIE9uY2UgdGhlIGRlZmVycmVkIGlzIGNyZWF0ZWQsIGtpY2sgb2ZmIHN0YXJ0Vmlld1RyYW5zaXRpb24oKSB0byB1cGRhdGUgdGhlXG4gIC8vIERPTSBhbmQgdGhlbiB3YWl0IG9uIHRoZSBEZWZlcnJlZCB0byByZXNvbHZlIChpbmRpY2F0aW5nIHRoZSBET00gdXBkYXRlIGhhc1xuICAvLyBoYXBwZW5lZClcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiByb3V0ZXIud2luZG93KSB7XG4gICAgICBsZXQgbmV3U3RhdGUgPSBwZW5kaW5nU3RhdGU7XG4gICAgICBsZXQgcmVuZGVyUHJvbWlzZSA9IHJlbmRlckRmZC5wcm9taXNlO1xuICAgICAgbGV0IHRyYW5zaXRpb24gPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgYXdhaXQgcmVuZGVyUHJvbWlzZTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNpdGlvbi5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyRGZkKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFRyYW5zaXRpb24odW5kZWZpbmVkKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgfVxuICB9LCBbb3B0SW5TdGFydFRyYW5zaXRpb24sIHBlbmRpbmdTdGF0ZSwgcmVuZGVyRGZkLCByb3V0ZXIud2luZG93XSk7XG5cbiAgLy8gV2hlbiB0aGUgbmV3IGxvY2F0aW9uIGZpbmFsbHkgcmVuZGVycyBhbmQgaXMgY29tbWl0dGVkIHRvIHRoZSBET00sIHRoaXNcbiAgLy8gZWZmZWN0IHdpbGwgcnVuIHRvIHJlc29sdmUgdGhlIHRyYW5zaXRpb25cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICByZW5kZXJEZmQgJiZcbiAgICAgIHBlbmRpbmdTdGF0ZSAmJlxuICAgICAgc3RhdGUubG9jYXRpb24ua2V5ID09PSBwZW5kaW5nU3RhdGUubG9jYXRpb24ua2V5XG4gICAgKSB7XG4gICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwgW3JlbmRlckRmZCwgdHJhbnNpdGlvbiwgc3RhdGUubG9jYXRpb24sIHBlbmRpbmdTdGF0ZV0pO1xuXG4gIC8vIElmIHdlIGdldCBpbnRlcnJ1cHRlZCB3aXRoIGEgbmV3IG5hdmlnYXRpb24gZHVyaW5nIGEgdHJhbnNpdGlvbiwgd2Ugc2tpcFxuICAvLyB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGxldCBpdCBjbGVhbnVwLCB0aGVuIGtpY2sgaXQgb2ZmIGFnYWluIGhlcmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgaW50ZXJydXB0aW9uKSB7XG4gICAgICBzZXRQZW5kaW5nU3RhdGUoaW50ZXJydXB0aW9uLnN0YXRlKTtcbiAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBpbnRlcnJ1cHRpb24uY3VycmVudExvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGludGVycnVwdGlvbi5uZXh0TG9jYXRpb24sXG4gICAgICB9KTtcbiAgICAgIHNldEludGVycnVwdGlvbih1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbGxiYWNrRWxlbWVudCA9PSBudWxsIHx8ICFyb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sXG4gICAgICBcImA8Um91dGVyUHJvdmlkZXIgZmFsbGJhY2tFbGVtZW50PmAgaXMgZGVwcmVjYXRlZCB3aGVuIHVzaW5nIFwiICtcbiAgICAgICAgXCJgdjdfcGFydGlhbEh5ZHJhdGlvbmAsIHVzZSBhIGBIeWRyYXRlRmFsbGJhY2tgIGNvbXBvbmVudCBpbnN0ZWFkXCJcbiAgICApO1xuICAgIC8vIE9ubHkgbG9nIHRoaXMgb25jZSBvbiBpbml0aWFsIG1vdW50XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG5cbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCk6IE5hdmlnYXRvciA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiAobikgPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT5cbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT5cbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgfSksXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcblxuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICByb3V0ZXIsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgfSksXG4gICAgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV1cbiAgKTtcblxuICAvLyBUaGUgZnJhZ21lbnQgYW5kIHtudWxsfSBoZXJlIGFyZSBpbXBvcnRhbnQhICBXZSBuZWVkIHRoZW0gdG8ga2VlcCBSZWFjdCAxOCdzXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAvLyB1c2VJZCByZWxpZXMgb24gdGhlIGNvbXBvbmVudCB0cmVlIHN0cnVjdHVyZSB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGlkJ3NcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2RhdGFSb3V0ZXJDb250ZXh0fT5cbiAgICAgICAgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3N0YXRlfT5cbiAgICAgICAgICA8RmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtmZXRjaGVyRGF0YS5jdXJyZW50fT5cbiAgICAgICAgICAgIDxWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3Z0Q29udGV4dH0+XG4gICAgICAgICAgICAgIDxSb3V0ZXJcbiAgICAgICAgICAgICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICAgICAgICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5oaXN0b3J5QWN0aW9ufVxuICAgICAgICAgICAgICAgIG5hdmlnYXRvcj17bmF2aWdhdG9yfVxuICAgICAgICAgICAgICAgIGZ1dHVyZT17e1xuICAgICAgICAgICAgICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IHJvdXRlci5mdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtzdGF0ZS5pbml0aWFsaXplZCB8fCByb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gPyAoXG4gICAgICAgICAgICAgICAgICA8RGF0YVJvdXRlc1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXM9e3JvdXRlci5yb3V0ZXN9XG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZT17cm91dGVyLmZ1dHVyZX1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGU9e3N0YXRlfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tFbGVtZW50XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9Sb3V0ZXI+XG4gICAgICAgICAgICA8L1ZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICA8L0ZldGNoZXJzQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9EYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIHtudWxsfVxuICAgIDwvPlxuICApO1xufVxuXG5mdW5jdGlvbiBEYXRhUm91dGVzKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlLFxufToge1xuICByb3V0ZXM6IERhdGFSb3V0ZU9iamVjdFtdO1xuICBmdXR1cmU6IFJlbWl4Um91dGVyW1wiZnV0dXJlXCJdO1xuICBzdGF0ZTogUm91dGVyU3RhdGU7XG59KTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdW5kZWZpbmVkLCBzdGF0ZSwgZnV0dXJlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGZ1dHVyZT86IFBhcnRpYWw8RnV0dXJlQ29uZmlnPjtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCcm93c2VyUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBmdXR1cmUsXG4gIHdpbmRvdyxcbn06IEJyb3dzZXJSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxCcm93c2VySGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3csIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgICAgZnV0dXJlPXtmdXR1cmV9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYXNoUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGZ1dHVyZT86IFBhcnRpYWw8RnV0dXJlQ29uZmlnPjtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBIYXNoUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBmdXR1cmUsXG4gIHdpbmRvdyxcbn06IEhhc2hSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxIYXNoSGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3csIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgICAgZnV0dXJlPXtmdXR1cmV9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGZ1dHVyZT86IEZ1dHVyZUNvbmZpZztcbiAgaGlzdG9yeTogSGlzdG9yeTtcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcbiAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAqL1xuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgZnV0dXJlLFxuICBoaXN0b3J5LFxufTogSGlzdG9yeVJvdXRlclByb3BzKSB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgICAgZnV0dXJlPXtmdXR1cmV9XG4gICAgLz5cbiAgKTtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIgfTtcblxuZXhwb3J0IGludGVyZmFjZSBMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PFJlYWN0LkFuY2hvckhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50PiwgXCJocmVmXCI+IHtcbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbiAgdG86IFRvO1xuICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj86IGJvb2xlYW47XG59XG5cbmNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5cbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSBgPGE+YC5cbiAqL1xuZXhwb3J0IGNvbnN0IExpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZihcbiAgICB7XG4gICAgICBvbkNsaWNrLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuXG4gICAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgYWJzb2x1dGUgVVJMc1xuICAgIGxldCBhYnNvbHV0ZUhyZWY7XG4gICAgbGV0IGlzRXh0ZXJuYWwgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodG8pKSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGFic29sdXRlIGhyZWYgc2VydmVyLSBhbmQgY2xpZW50LXNpZGVcbiAgICAgIGFic29sdXRlSHJlZiA9IHRvO1xuXG4gICAgICAvLyBPbmx5IGNoZWNrIGZvciBleHRlcm5hbCBvcmlnaW5zIGNsaWVudC1zaWRlXG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpXG4gICAgICAgICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIHRvKVxuICAgICAgICAgICAgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0VXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgcGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTdHJpcCB0aGUgcHJvdG9jb2wvb3JpZ2luL2Jhc2VuYW1lIGZvciBzYW1lLW9yaWdpbiBhYnNvbHV0ZSBVUkxzXG4gICAgICAgICAgICB0byA9IHBhdGggKyB0YXJnZXRVcmwuc2VhcmNoICsgdGFyZ2V0VXJsLmhhc2g7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFdlIGNhbid0IGRvIGV4dGVybmFsIFVSTCBkZXRlY3Rpb24gd2l0aG91dCBhIHZhbGlkIFVSTFxuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGA8TGluayB0bz1cIiR7dG99XCI+IGNvbnRhaW5zIGFuIGludmFsaWQgVVJMIHdoaWNoIHdpbGwgcHJvYmFibHkgYnJlYWsgYCArXG4gICAgICAgICAgICAgIGB3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciByZWxhdGl2ZSBVUkxzXG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0pO1xuXG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soXG4gICAgICBldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQW5jaG9yRWxlbWVudCwgTW91c2VFdmVudD5cbiAgICApIHtcbiAgICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICA8YVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgaHJlZj17YWJzb2x1dGVIcmVmIHx8IGhyZWZ9XG4gICAgICAgIG9uQ2xpY2s9e2lzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB0YXJnZXQ9e3RhcmdldH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuXG50eXBlIE5hdkxpbmtSZW5kZXJQcm9wcyA9IHtcbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIGlzUGVuZGluZzogYm9vbGVhbjtcbiAgaXNUcmFuc2l0aW9uaW5nOiBib29sZWFuO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBOYXZMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PExpbmtQcm9wcywgXCJjbGFzc05hbWVcIiB8IFwic3R5bGVcIiB8IFwiY2hpbGRyZW5cIj4ge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZSB8ICgocHJvcHM6IE5hdkxpbmtSZW5kZXJQcm9wcykgPT4gUmVhY3QuUmVhY3ROb2RlKTtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNsYXNzTmFtZT86IHN0cmluZyB8ICgocHJvcHM6IE5hdkxpbmtSZW5kZXJQcm9wcykgPT4gc3RyaW5nIHwgdW5kZWZpbmVkKTtcbiAgZW5kPzogYm9vbGVhbjtcbiAgc3R5bGU/OlxuICAgIHwgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgIHwgKChwcm9wczogTmF2TGlua1JlbmRlclByb3BzKSA9PiBSZWFjdC5DU1NQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkKTtcbn1cblxuLyoqXG4gKiBBIGA8TGluaz5gIHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5leHBvcnQgY29uc3QgTmF2TGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIE5hdkxpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICAgIHRvLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZSB9KTtcbiAgICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgbGV0IHsgbmF2aWdhdG9yLCBiYXNlbmFtZSB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IGlzVHJhbnNpdGlvbmluZyA9XG4gICAgICByb3V0ZXJTdGF0ZSAhPSBudWxsICYmXG4gICAgICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUocGF0aCkgJiZcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uID09PSB0cnVlO1xuXG4gICAgbGV0IHRvUGF0aG5hbWUgPSBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb25cbiAgICAgID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKHBhdGgpLnBhdGhuYW1lXG4gICAgICA6IHBhdGgucGF0aG5hbWU7XG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPVxuICAgICAgcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uXG4gICAgICAgID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICA6IG51bGw7XG5cbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lXG4gICAgICAgID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICA6IG51bGw7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmIChuZXh0TG9jYXRpb25QYXRobmFtZSAmJiBiYXNlbmFtZSkge1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPVxuICAgICAgICBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvblBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbmV4dExvY2F0aW9uUGF0aG5hbWU7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGB0b2AgaGFzIGEgdHJhaWxpbmcgc2xhc2gsIGxvb2sgYXQgdGhhdCBleGFjdCBzcG90LiAgT3RoZXJ3aXNlLFxuICAgIC8vIHdlJ3JlIGxvb2tpbmcgZm9yIGEgc2xhc2ggX2FmdGVyXyB3aGF0J3MgaW4gYHRvYC4gIEZvciBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPE5hdkxpbmsgdG89XCIvdXNlcnNcIj4gYW5kIDxOYXZMaW5rIHRvPVwiL3VzZXJzL1wiPlxuICAgIC8vIGJvdGggd2FudCB0byBsb29rIGZvciBhIC8gYXQgaW5kZXggNiB0byBtYXRjaCBVUkwgYC91c2Vycy9tYXR0YFxuICAgIGNvbnN0IGVuZFNsYXNoUG9zaXRpb24gPVxuICAgICAgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIilcbiAgICAgICAgPyB0b1BhdGhuYW1lLmxlbmd0aCAtIDFcbiAgICAgICAgOiB0b1BhdGhuYW1lLmxlbmd0aDtcbiAgICBsZXQgaXNBY3RpdmUgPVxuICAgICAgbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgKCFlbmQgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KGVuZFNsYXNoUG9zaXRpb24pID09PSBcIi9cIik7XG5cbiAgICBsZXQgaXNQZW5kaW5nID1cbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiZcbiAgICAgIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgICAoIWVuZCAmJlxuICAgICAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiZcbiAgICAgICAgICBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIikpO1xuXG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgaXNBY3RpdmUsXG4gICAgICBpc1BlbmRpbmcsXG4gICAgICBpc1RyYW5zaXRpb25pbmcsXG4gICAgfTtcblxuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGNsYXNzTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHJlbmRlclByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgICBjbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZVByb3AsXG4gICAgICAgIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsXG4gICAgICAgIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCxcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nID8gXCJ0cmFuc2l0aW9uaW5nXCIgOiBudWxsLFxuICAgICAgXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPVxuICAgICAgdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcblxuICAgIHJldHVybiAoXG4gICAgICA8TGlua1xuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgYXJpYS1jdXJyZW50PXthcmlhQ3VycmVudH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIHRvPXt0b31cbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb249e3Vuc3RhYmxlX3ZpZXdUcmFuc2l0aW9ufVxuICAgICAgPlxuICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlbn1cbiAgICAgIDwvTGluaz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hlckZvcm1Qcm9wc1xuICBleHRlbmRzIFJlYWN0LkZvcm1IVE1MQXR0cmlidXRlczxIVE1MRm9ybUVsZW1lbnQ+IHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgdG8gdXNlIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0LiBTdXBwb3J0cyBcImdldFwiLCBcInBvc3RcIixcbiAgICogXCJwdXRcIiwgXCJkZWxldGVcIiwgXCJwYXRjaFwiLlxuICAgKi9cbiAgbWV0aG9kPzogSFRNTEZvcm1NZXRob2Q7XG5cbiAgLyoqXG4gICAqIGA8Zm9ybSBlbmNUeXBlPmAgLSBlbmhhbmNpbmcgYmV5b25kIHRoZSBub3JtYWwgc3RyaW5nIHR5cGUgYW5kIGxpbWl0aW5nXG4gICAqIHRvIHRoZSBidWlsdC1pbiBicm93c2VyIHN1cHBvcnRlZCB2YWx1ZXNcbiAgICovXG4gIGVuY1R5cGU/OlxuICAgIHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgIHwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJcbiAgICB8IFwidGV4dC9wbGFpblwiO1xuXG4gIC8qKlxuICAgKiBOb3JtYWwgYDxmb3JtIGFjdGlvbj5gIGJ1dCBzdXBwb3J0cyBSZWFjdCBSb3V0ZXIncyByZWxhdGl2ZSBwYXRocy5cbiAgICovXG4gIGFjdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmb3JtIGFjdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgcm91dGUgaGllcmFyY2h5IG9yXG4gICAqIHRoZSBwYXRobmFtZS4gIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIG9wdCBvdXQgb2YgbmF2aWdhdGluZyB0aGUgcm91dGVcbiAgICogaGllcmFyY2h5IGFuZCB3YW50IHRvIGluc3RlYWQgcm91dGUgYmFzZWQgb24gLy1kZWxpbWl0ZWQgVVJMIHNlZ21lbnRzXG4gICAqL1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgdGhlIHNjcm9sbCBwb3NpdGlvbiBmcm9tIHJlc2V0dGluZyB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCBvblxuICAgKiBjb21wbGV0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIHdoZW4gdXNpbmcgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQuIElmIHlvdSBjYWxsXG4gICAqIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCB0aGVuIHRoaXMgZm9ybSB3aWxsIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIG9uU3VibWl0PzogUmVhY3QuRm9ybUV2ZW50SGFuZGxlcjxIVE1MRm9ybUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1Qcm9wcyBleHRlbmRzIEZldGNoZXJGb3JtUHJvcHMge1xuICAvKipcbiAgICogSW5kaWNhdGUgYSBzcGVjaWZpYyBmZXRjaGVyS2V5IHRvIHVzZSB3aGVuIHVzaW5nIG5hdmlnYXRlPWZhbHNlXG4gICAqL1xuICBmZXRjaGVyS2V5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBuYXZpZ2F0ZT1mYWxzZSB3aWxsIHVzZSBhIGZldGNoZXIgaW5zdGVhZCBvZiBhIG5hdmlnYXRpb25cbiAgICovXG4gIG5hdmlnYXRlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRm9yY2VzIGEgZnVsbCBkb2N1bWVudCBuYXZpZ2F0aW9uIGluc3RlYWQgb2YgYSBmZXRjaC5cbiAgICovXG4gIHJlbG9hZERvY3VtZW50PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgZW50cnkgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeSBzdGFjayB3aGVuIHRoZSBmb3JtXG4gICAqIG5hdmlnYXRlcy4gVXNlIHRoaXMgaWYgeW91IGRvbid0IHdhbnQgdGhlIHVzZXIgdG8gYmUgYWJsZSB0byBjbGljayBcImJhY2tcIlxuICAgKiB0byB0aGUgcGFnZSB3aXRoIHRoZSBmb3JtIG9uIGl0LlxuICAgKi9cbiAgcmVwbGFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFN0YXRlIG9iamVjdCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RhY2sgZW50cnkgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgKi9cbiAgc3RhdGU/OiBhbnk7XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB2aWV3IHRyYW5zaXRpb25zIG9uIHRoaXMgRm9ybSBuYXZpZ2F0aW9uXG4gICAqL1xuICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj86IGJvb2xlYW47XG59XG5cbnR5cGUgSFRNTFN1Ym1pdEV2ZW50ID0gUmVhY3QuQmFzZVN5bnRoZXRpY0V2ZW50PFxuICBTdWJtaXRFdmVudCxcbiAgRXZlbnQsXG4gIEhUTUxGb3JtRWxlbWVudFxuPjtcblxudHlwZSBIVE1MRm9ybVN1Ym1pdHRlciA9IEhUTUxCdXR0b25FbGVtZW50IHwgSFRNTElucHV0RWxlbWVudDtcblxuLyoqXG4gKiBBIGBAcmVtaXgtcnVuL3JvdXRlcmAtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdFxuICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICogcmVxdWVzdHMsIGFsbG93aW5nIGNvbXBvbmVudHMgdG8gYWRkIG5pY2VyIFVYIHRvIHRoZSBwYWdlIGFzIHRoZSBmb3JtIGlzXG4gKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgRm9ybSA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEZvcm1FbGVtZW50LCBGb3JtUHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgZmV0Y2hlcktleSxcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgICAgYWN0aW9uLFxuICAgICAgb25TdWJtaXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uLFxuICAgICAgLi4ucHJvcHNcbiAgICB9LFxuICAgIGZvcndhcmRlZFJlZlxuICApID0+IHtcbiAgICBsZXQgc3VibWl0ID0gdXNlU3VibWl0KCk7XG4gICAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgeyByZWxhdGl2ZSB9KTtcbiAgICBsZXQgZm9ybU1ldGhvZDogSFRNTEZvcm1NZXRob2QgPVxuICAgICAgbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG5cbiAgICBsZXQgc3VibWl0SGFuZGxlcjogUmVhY3QuRm9ybUV2ZW50SGFuZGxlcjxIVE1MRm9ybUVsZW1lbnQ+ID0gKGV2ZW50KSA9PiB7XG4gICAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbGV0IHN1Ym1pdHRlciA9IChldmVudCBhcyB1bmtub3duIGFzIEhUTUxTdWJtaXRFdmVudCkubmF0aXZlRXZlbnRcbiAgICAgICAgLnN1Ym1pdHRlciBhcyBIVE1MRm9ybVN1Ym1pdHRlciB8IG51bGw7XG5cbiAgICAgIGxldCBzdWJtaXRNZXRob2QgPVxuICAgICAgICAoc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIGFzIEhUTUxGb3JtTWV0aG9kIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgICBtZXRob2Q7XG5cbiAgICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgICAgbmF2aWdhdGUsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGZvcm1cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgIG1ldGhvZD17Zm9ybU1ldGhvZH1cbiAgICAgICAgYWN0aW9uPXtmb3JtQWN0aW9ufVxuICAgICAgICBvblN1Ym1pdD17cmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJ9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbFJlc3RvcmF0aW9uUHJvcHMge1xuICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uO1xuICBzdG9yYWdlS2V5Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxufTogU2Nyb2xsUmVzdG9yYXRpb25Qcm9wcykge1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7IGdldEtleSwgc3RvcmFnZUtleSB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSG9va3Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmVudW0gRGF0YVJvdXRlckhvb2sge1xuICBVc2VTY3JvbGxSZXN0b3JhdGlvbiA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIixcbiAgVXNlU3VibWl0ID0gXCJ1c2VTdWJtaXRcIixcbiAgVXNlU3VibWl0RmV0Y2hlciA9IFwidXNlU3VibWl0RmV0Y2hlclwiLFxuICBVc2VGZXRjaGVyID0gXCJ1c2VGZXRjaGVyXCIsXG4gIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUgPSBcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIixcbn1cblxuZW51bSBEYXRhUm91dGVyU3RhdGVIb29rIHtcbiAgVXNlRmV0Y2hlciA9IFwidXNlRmV0Y2hlclwiLFxuICBVc2VGZXRjaGVycyA9IFwidXNlRmV0Y2hlcnNcIixcbiAgVXNlU2Nyb2xsUmVzdG9yYXRpb24gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIsXG59XG5cbi8vIEludGVybmFsIGhvb2tzXG5cbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoXG4gIGhvb2tOYW1lOiBEYXRhUm91dGVySG9vayB8IERhdGFSb3V0ZXJTdGF0ZUhvb2tcbikge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWU6IERhdGFSb3V0ZXJIb29rKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWU6IERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLy8gRXh0ZXJuYWwgaG9va3NcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICogdXNlIGluIG91ciBleHBvcnRlZCBgPExpbms+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXI8RSBleHRlbmRzIEVsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudD4oXG4gIHRvOiBUbyxcbiAge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gIH06IHtcbiAgICB0YXJnZXQ/OiBSZWFjdC5IVE1MQXR0cmlidXRlQW5jaG9yVGFyZ2V0O1xuICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIHN0YXRlPzogYW55O1xuICAgIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gICAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPzogYm9vbGVhbjtcbiAgfSA9IHt9XG4pOiAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHZvaWQge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUgdW5sZXNzIHRoZSByZXBsYWNlIHByb3AgaXMgZXhwbGljaXRseSBzZXRcbiAgICAgICAgbGV0IHJlcGxhY2UgPVxuICAgICAgICAgIHJlcGxhY2VQcm9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gcmVwbGFjZVByb3BcbiAgICAgICAgICAgIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG5cbiAgICAgICAgbmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcGF0aCxcbiAgICAgIHJlcGxhY2VQcm9wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgXVxuICApO1xufVxuXG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoXG4gIGRlZmF1bHRJbml0PzogVVJMU2VhcmNoUGFyYW1zSW5pdFxuKTogW1VSTFNlYXJjaFBhcmFtcywgU2V0VVJMU2VhcmNoUGFyYW1zXSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IGAgK1xuICAgICAgYHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgYCArXG4gICAgICBgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuYCArXG4gICAgICBgSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IGAgK1xuICAgICAgYGh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBgICtcbiAgICAgIGB0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgYCArXG4gICAgICBgdXNlci5gXG4gICk7XG5cbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG4gIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAgICAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgICAgIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50XG4gICAgICApLFxuICAgIFtsb2NhdGlvbi5zZWFyY2hdXG4gICk7XG5cbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrPFNldFVSTFNlYXJjaFBhcmFtcz4oXG4gICAgKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgICAgICAgdHlwZW9mIG5leHRJbml0ID09PSBcImZ1bmN0aW9uXCIgPyBuZXh0SW5pdChzZWFyY2hQYXJhbXMpIDogbmV4dEluaXRcbiAgICAgICk7XG4gICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LFxuICAgIFtuYXZpZ2F0ZSwgc2VhcmNoUGFyYW1zXVxuICApO1xuXG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxuXG5leHBvcnQgdHlwZSBTZXRVUkxTZWFyY2hQYXJhbXMgPSAoXG4gIG5leHRJbml0PzpcbiAgICB8IFVSTFNlYXJjaFBhcmFtc0luaXRcbiAgICB8ICgocHJldjogVVJMU2VhcmNoUGFyYW1zKSA9PiBVUkxTZWFyY2hQYXJhbXNJbml0KSxcbiAgbmF2aWdhdGVPcHRzPzogTmF2aWdhdGVPcHRpb25zXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogU3VibWl0cyBhIEhUTUwgYDxmb3JtPmAgdG8gdGhlIHNlcnZlciB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRGdW5jdGlvbiB7XG4gIChcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGA8Zm9ybT5gIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgc2VydmVyLCBhIHNwZWNpZmljXG4gICAgICogYDxidXR0b24+YCBvciBgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj5gIHRvIHVzZSB0byBzdWJtaXQgdGhlIGZvcm0sIG9yIHNvbWVcbiAgICAgKiBhcmJpdHJhcnkgZGF0YSB0byBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBXaGVuIHVzaW5nIGEgYDxidXR0b24+YCBpdHMgYG5hbWVgIGFuZCBgdmFsdWVgIHdpbGwgYWxzbyBiZVxuICAgICAqIGluY2x1ZGVkIGluIHRoZSBmb3JtIGRhdGEgdGhhdCBpcyBzdWJtaXR0ZWQuXG4gICAgICovXG4gICAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRoYXQgb3ZlcnJpZGUgdGhlIGA8Zm9ybT5gJ3Mgb3duIGF0dHJpYnV0ZXMuIFJlcXVpcmVkIHdoZW5cbiAgICAgKiBzdWJtaXR0aW5nIGFyYml0cmFyeSBkYXRhIHdpdGhvdXQgYSBiYWNraW5nIGA8Zm9ybT5gLlxuICAgICAqL1xuICAgIG9wdGlvbnM/OiBTdWJtaXRPcHRpb25zXG4gICk6IHZvaWQ7XG59XG5cbi8qKlxuICogU3VibWl0cyBhIGZldGNoZXIgYDxmb3JtPmAgdG8gdGhlIHNlcnZlciB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGZXRjaGVyU3VibWl0RnVuY3Rpb24ge1xuICAoXG4gICAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG4gICAgLy8gRmV0Y2hlcnMgY2Fubm90IHJlcGxhY2Ugb3Igc2V0IHN0YXRlIGJlY2F1c2UgdGhleSBhcmUgbm90IG5hdmlnYXRpb24gZXZlbnRzXG4gICAgb3B0aW9ucz86IE9taXQ8U3VibWl0T3B0aW9ucywgXCJyZXBsYWNlXCIgfCBcInN0YXRlXCI+XG4gICk6IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArXG4gICAgICAgIFwiVHJ5IGNhbGxpbmcgc3VibWl0IHdpdGhpbiBhIGB1c2VFZmZlY3RgIG9yIGNhbGxiYWNrIGluc3RlYWQuXCJcbiAgICApO1xuICB9XG59XG5cbmxldCBmZXRjaGVySWQgPSAwO1xubGV0IGdldFVuaXF1ZUZldGNoZXJJZCA9ICgpID0+IGBfXyR7U3RyaW5nKCsrZmV0Y2hlcklkKX1fX2A7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1Ym1pdCgpOiBTdWJtaXRGdW5jdGlvbiB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU3VibWl0KTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSB1c2VSb3V0ZUlkKCk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrPFN1Ym1pdEZ1bmN0aW9uPihcbiAgICAodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKTtcblxuICAgICAgbGV0IHsgYWN0aW9uLCBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgYmFzZW5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChvcHRpb25zLm5hdmlnYXRlID09PSBmYWxzZSkge1xuICAgICAgICBsZXQga2V5ID0gb3B0aW9ucy5mZXRjaGVyS2V5IHx8IGdldFVuaXF1ZUZldGNoZXJJZCgpO1xuICAgICAgICByb3V0ZXIuZmV0Y2goa2V5LCBjdXJyZW50Um91dGVJZCwgb3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IChtZXRob2QgYXMgSFRNTEZvcm1NZXRob2QpLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgKGVuY1R5cGUgYXMgRm9ybUVuY1R5cGUpLFxuICAgICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogb3B0aW9ucy51bnN0YWJsZV9mbHVzaFN5bmMsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAobWV0aG9kIGFzIEhUTUxGb3JtTWV0aG9kKSxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IChlbmNUeXBlIGFzIEZvcm1FbmNUeXBlKSxcbiAgICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXG4gICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgZnJvbVJvdXRlSWQ6IGN1cnJlbnRSb3V0ZUlkLFxuICAgICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogb3B0aW9ucy51bnN0YWJsZV9mbHVzaFN5bmMsXG4gICAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb246IG9wdGlvbnMudW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXVxuICApO1xufVxuXG4vLyB2NzogRXZlbnR1YWxseSB3ZSBzaG91bGQgZGVwcmVjYXRlIHRoaXMgZW50aXJlbHkgaW4gZmF2b3Igb2YgdXNpbmcgdGhlXG4vLyByb3V0ZXIgbWV0aG9kIGRpcmVjdGx5P1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oXG4gIGFjdGlvbj86IHN0cmluZyxcbiAgeyByZWxhdGl2ZSB9OiB7IHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZSB9ID0ge31cbik6IHN0cmluZyB7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlQ29udGV4dCwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIik7XG5cbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIC8vIFNoYWxsb3cgY2xvbmUgcGF0aCBzbyB3ZSBjYW4gbW9kaWZ5IGl0IGJlbG93LCBvdGhlcndpc2Ugd2UgbW9kaWZ5IHRoZVxuICAvLyBvYmplY3QgcmVmZXJlbmNlZCBieSB1c2VNZW1vIGluc2lkZSB1c2VSZXNvbHZlZFBhdGhcbiAgbGV0IHBhdGggPSB7IC4uLnVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwgeyByZWxhdGl2ZSB9KSB9O1xuXG4gIC8vIElmIG5vIGFjdGlvbiB3YXMgc3BlY2lmaWVkLCBicm93c2VycyB3aWxsIHBlcnNpc3QgY3VycmVudCBzZWFyY2ggcGFyYW1zXG4gIC8vIHdoZW4gZGV0ZXJtaW5pbmcgdGhlIHBhdGgsIHNvIG1hdGNoIHRoYXQgYmVoYXZpb3JcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIC8vIFNhZmUgdG8gd3JpdGUgdG8gdGhpcyBkaXJlY3RseSBoZXJlIHNpbmNlIGlmIGFjdGlvbiB3YXMgdW5kZWZpbmVkLCB3ZVxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG5cbiAgICAvLyBXaGVuIGdyYWJiaW5nIHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUgVVJMLCByZW1vdmUgYW55IGluY2x1ZGVkID9pbmRleCBwYXJhbVxuICAgIC8vIHNpbmNlIGl0IG1pZ2h0IG5vdCBhcHBseSB0byBvdXIgY29udGV4dHVhbCByb3V0ZS4gIFdlIGFkZCBpdCBiYWNrIGJhc2VkXG4gICAgLy8gb24gbWF0Y2gucm91dGUuaW5kZXggYmVsb3dcbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgaWYgKHBhcmFtcy5oYXMoXCJpbmRleFwiKSAmJiBwYXJhbXMuZ2V0KFwiaW5kZXhcIikgPT09IFwiXCIpIHtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcGFyYW1zLnRvU3RyaW5nKCkgPyBgPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCA6IFwiXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaFxuICAgICAgPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpXG4gICAgICA6IFwiP2luZGV4XCI7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBmb3JtIGFjdGlvbi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2VcbiAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgIHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cblxuZXhwb3J0IHR5cGUgRmV0Y2hlcldpdGhDb21wb25lbnRzPFREYXRhPiA9IEZldGNoZXI8VERhdGE+ICYge1xuICBGb3JtOiBSZWFjdC5Gb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50PFxuICAgIEZldGNoZXJGb3JtUHJvcHMgJiBSZWFjdC5SZWZBdHRyaWJ1dGVzPEhUTUxGb3JtRWxlbWVudD5cbiAgPjtcbiAgc3VibWl0OiBGZXRjaGVyU3VibWl0RnVuY3Rpb247XG4gIGxvYWQ6IChocmVmOiBzdHJpbmcsIG9wdHM/OiB7IHVuc3RhYmxlX2ZsdXNoU3luYz86IGJvb2xlYW4gfSkgPT4gdm9pZDtcbn07XG5cbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSB1c2VGZXRjaGVyIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxuXG4vKipcbiAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAqIGZvciBhbnkgaW50ZXJhY3Rpb24gdGhhdCBzdGF5cyBvbiB0aGUgc2FtZSBwYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRmV0Y2hlcjxURGF0YSA9IGFueT4oe1xuICBrZXksXG59OiB7IGtleT86IHN0cmluZyB9ID0ge30pOiBGZXRjaGVyV2l0aENvbXBvbmVudHM8VERhdGE+IHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VGZXRjaGVyKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcik7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0LnVzZUNvbnRleHQoRmV0Y2hlcnNDb250ZXh0KTtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVJZCA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXT8ucm91dGUuaWQ7XG5cbiAgaW52YXJpYW50KGZldGNoZXJEYXRhLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0YCk7XG4gIGludmFyaWFudChyb3V0ZSwgYHVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVJZCAhPSBudWxsLFxuICAgIGB1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG5cbiAgLy8gRmV0Y2hlciBrZXkgaGFuZGxpbmdcbiAgLy8gT0sgdG8gY2FsbCBjb25kaXRpb25hbGx5IHRvIGZlYXR1cmUgZGV0ZWN0IGB1c2VJZGBcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIGxldCBkZWZhdWx0S2V5ID0gdXNlSWRJbXBsID8gdXNlSWRJbXBsKCkgOiBcIlwiO1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QudXNlU3RhdGU8c3RyaW5nPihrZXkgfHwgZGVmYXVsdEtleSk7XG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICB9IGVsc2UgaWYgKCFmZXRjaGVyS2V5KSB7XG4gICAgLy8gV2Ugd2lsbCBvbmx5IGZhbGwgdGhyb3VnaCBoZXJlIHdoZW4gYHVzZUlkYCBpcyBub3QgYXZhaWxhYmxlXG4gICAgc2V0RmV0Y2hlcktleShnZXRVbmlxdWVGZXRjaGVySWQoKSk7XG4gIH1cblxuICAvLyBSZWdpc3RyYXRpb24vY2xlYW51cFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBUZWxsIHRoZSByb3V0ZXIgd2UndmUgdW5tb3VudGVkIC0gaWYgdjdfZmV0Y2hlclBlcnNpc3QgaXMgZW5hYmxlZCB0aGlzXG4gICAgICAvLyB3aWxsIG5vdCBkZWxldGUgaW1tZWRpYXRlbHkgYnV0IGluc3RlYWQgcXVldWUgdXAgYSBkZWxldGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBmZXRjaGVyIHJldHVybnMgdG8gYW4gYGlkbGVgIHN0YXRlXG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICB9O1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG5cbiAgLy8gRmV0Y2hlciBhZGRpdGlvbnNcbiAgbGV0IGxvYWQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoaHJlZjogc3RyaW5nLCBvcHRzPzogeyB1bnN0YWJsZV9mbHVzaFN5bmM/OiBib29sZWFuIH0pID0+IHtcbiAgICAgIGludmFyaWFudChyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKTtcbiAgICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCByb3V0ZUlkLCBocmVmLCBvcHRzKTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdXG4gICk7XG5cbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0LnVzZUNhbGxiYWNrPEZldGNoZXJTdWJtaXRGdW5jdGlvbj4oXG4gICAgKHRhcmdldCwgb3B0cykgPT4ge1xuICAgICAgc3VibWl0SW1wbCh0YXJnZXQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF1cbiAgKTtcblxuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgRmV0Y2hlckZvcm1Qcm9wcz4oXG4gICAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxGb3JtIHsuLi5wcm9wc30gbmF2aWdhdGU9e2ZhbHNlfSBmZXRjaGVyS2V5PXtmZXRjaGVyS2V5fSByZWY9e3JlZn0gLz5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgfVxuICAgIHJldHVybiBGZXRjaGVyRm9ybTtcbiAgfSwgW2ZldGNoZXJLZXldKTtcblxuICAvLyBFeHBvc2VkIEZldGNoZXJXaXRoQ29tcG9uZW50c1xuICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChmZXRjaGVyS2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIGxldCBkYXRhID0gZmV0Y2hlckRhdGEuZ2V0KGZldGNoZXJLZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgRm9ybTogRmV0Y2hlckZvcm0sXG4gICAgICBzdWJtaXQsXG4gICAgICBsb2FkLFxuICAgICAgLi4uZmV0Y2hlcixcbiAgICAgIGRhdGEsXG4gICAgfSksXG4gICAgW0ZldGNoZXJGb3JtLCBzdWJtaXQsIGxvYWQsIGZldGNoZXIsIGRhdGFdXG4gICk7XG5cbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICogcm91dGVzIHRoYXQgbmVlZCB0byBwcm92aWRlIHBlbmRpbmcvb3B0aW1pc3RpYyBVSSByZWdhcmRpbmcgdGhlIGZldGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKTogKEZldGNoZXIgJiB7IGtleTogc3RyaW5nIH0pW10ge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVycyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKChba2V5LCBmZXRjaGVyXSkgPT4gKHtcbiAgICAuLi5mZXRjaGVyLFxuICAgIGtleSxcbiAgfSkpO1xufVxuXG5jb25zdCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkgPSBcInJlYWN0LXJvdXRlci1zY3JvbGwtcG9zaXRpb25zXCI7XG5sZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuLyoqXG4gKiBXaGVuIHJlbmRlcmVkIGluc2lkZSBhIFJvdXRlclByb3ZpZGVyLCB3aWxsIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9ucyBvbiBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleSxcbn06IHtcbiAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbjtcbiAgc3RvcmFnZUtleT86IHN0cmluZztcbn0gPSB7fSkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXQgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuXG4gIC8vIFRyaWdnZXIgbWFudWFsIHNjcm9sbCByZXN0b3JhdGlvbiB3aGlsZSB3ZSdyZSBhY3RpdmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgcG9zaXRpb25zIG9uIHBhZ2VoaWRlXG4gIHVzZVBhZ2VIaWRlKFxuICAgIFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICBsZXQga2V5ID0gKGdldEtleSA/IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcykgOiBudWxsKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoJHtlcnJvcn0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKVxuICApO1xuXG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG5cbiAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGdldEtleVdpdGhvdXRCYXNlbmFtZTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGdldEtleSAmJiBiYXNlbmFtZSAhPT0gXCIvXCJcbiAgICAgICAgICA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT5cbiAgICAgICAgICAgICAgZ2V0S2V5KFxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBiYXNlbmFtZSB0byBtYXRjaCB1c2VMb2NhdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICBwYXRobmFtZTpcbiAgICAgICAgICAgICAgICAgICAgc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgOiBnZXRLZXk7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXlXaXRob3V0QmFzZW5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcblxuICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCByZXNldCBpZiB0aGlzIG5hdmlnYXRpb24gb3B0ZWQgb3V0XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuXG5leHBvcnQgeyB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24gfTtcblxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKFxuICBjYWxsYmFjazogKGV2ZW50OiBCZWZvcmVVbmxvYWRFdmVudCkgPT4gYW55LFxuICBvcHRpb25zPzogeyBjYXB0dXJlPzogYm9vbGVhbiB9XG4pOiB2b2lkIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdW5kZWZpbmVkO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKFxuICBjYWxsYmFjazogKGV2ZW50OiBQYWdlVHJhbnNpdGlvbkV2ZW50KSA9PiBhbnksXG4gIG9wdGlvbnM/OiB7IGNhcHR1cmU/OiBib29sZWFuIH1cbik6IHZvaWQge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXG4gKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcbiAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKi9cbmZ1bmN0aW9uIHVzZVByb21wdCh7XG4gIHdoZW4sXG4gIG1lc3NhZ2UsXG59OiB7XG4gIHdoZW46IGJvb2xlYW4gfCBCbG9ja2VyRnVuY3Rpb247XG4gIG1lc3NhZ2U6IHN0cmluZztcbn0pIHtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IGlzIG5lZWRlZCB0byBhdm9pZCBhIHdlaXJkIFwicmFjZVwiIG9uIFBPUCBuYXZpZ2F0aW9uc1xuICAgICAgICAvLyBiZXR3ZWVuIHRoZSBgd2luZG93Lmhpc3RvcnlgIHJldmVydCBuYXZpZ2F0aW9uIGFuZCB0aGUgcmVzdWx0IG9mXG4gICAgICAgIC8vIGB3aW5kb3cuY29uZmlybWBcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cblxuZXhwb3J0IHsgdXNlUHJvbXB0IGFzIHVuc3RhYmxlX3VzZVByb21wdCB9O1xuXG4vKipcbiAqIFJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgdmlldyB0cmFuc2l0aW9uIHRvIHRoZVxuICogZ2l2ZW4gaHJlZi4gIFlvdSBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gcmVuZGVyIENTUyBjbGFzc2VzIG9yIHZpZXdUcmFuc2l0aW9uTmFtZVxuICogc3R5bGVzIG9udG8geW91ciBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSBocmVmIFRoZSBkZXN0aW5hdGlvbiBocmVmXG4gKiBAcGFyYW0gW29wdHMucmVsYXRpdmVdIFJlbGF0aXZlIHJvdXRpbmcgdHlwZSAoXCJyb3V0ZVwiIHwgXCJwYXRoXCIpXG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUoXG4gIHRvOiBUbyxcbiAgb3B0czogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pIHtcbiAgbGV0IHZ0Q29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVmlld1RyYW5zaXRpb25Db250ZXh0KTtcblxuICBpbnZhcmlhbnQoXG4gICAgdnRDb250ZXh0ICE9IG51bGwsXG4gICAgXCJgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgXCIgK1xuICAgICAgXCJEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFxuICAgIERhdGFSb3V0ZXJIb29rLnVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcbiAgKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IG9wdHMucmVsYXRpdmUgfSk7XG4gIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBjdXJyZW50UGF0aCA9XG4gICAgc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHxcbiAgICB2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dFBhdGggPVxuICAgIHN0cmlwQmFzZW5hbWUodnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcblxuICAvLyBUcmFuc2l0aW9uIGlzIGFjdGl2ZSBpZiB3ZSdyZSBnb2luZyB0byBvciBjb21pbmcgZnJvbSB0aGUgaW5kaWNhdGVkXG4gIC8vIGRlc3RpbmF0aW9uLiAgVGhpcyBlbnN1cmVzIHRoYXQgb3RoZXIgUFVTSCBuYXZpZ2F0aW9ucyB0aGF0IHJldmVyc2VcbiAgLy8gYW4gaW5kaWNhdGVkIHRyYW5zaXRpb24gYXBwbHkuICBJLmUuLCBvbiB0aGUgbGlzdCB2aWV3IHlvdSBoYXZlOlxuICAvL1xuICAvLyAgIDxOYXZMaW5rIHRvPVwiL2RldGFpbHMvMVwiIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPlxuICAvL1xuICAvLyBJZiB5b3UgY2xpY2sgdGhlIGJyZWFkY3J1bWIgYmFjayB0byB0aGUgbGlzdCB2aWV3OlxuICAvL1xuICAvLyAgIDxOYXZMaW5rIHRvPVwiL2xpc3RcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIGFwcGx5IHRoZSB0cmFuc2l0aW9uIGJlY2F1c2UgaXQncyBpbmRpY2F0ZWQgYXMgYWN0aXZlIGdvaW5nXG4gIC8vIGZyb20gL2xpc3QgLT4gL2RldGFpbHMvMSBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSBhY3RpdmUgb24gdGhlIHJldmVyc2VcbiAgLy8gKGV2ZW4gdGhvdWdoIHRoaXMgaXNuJ3Qgc3RyaWN0bHkgYSBQT1AgcmV2ZXJzZSlcbiAgcmV0dXJuIChcbiAgICBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHxcbiAgICBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgY3VycmVudFBhdGgpICE9IG51bGxcbiAgKTtcbn1cblxuZXhwb3J0IHsgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSBhcyB1bnN0YWJsZV91c2VWaWV3VHJhbnNpdGlvblN0YXRlIH07XG5cbi8vI2VuZHJlZ2lvblxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQU9PLE1BQU1BLGFBQTZCLEdBQUcsS0FBSztFQUNsRCxNQUFNQyxjQUEyQixHQUFHLG1DQUFtQztFQUVoRSxTQUFTQyxhQUFhQSxDQUFDQyxNQUFXLEVBQXlCO0lBQ2hFLE9BQU9BLE1BQU0sSUFBSSxJQUFJLElBQUksT0FBT0EsTUFBTSxDQUFD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