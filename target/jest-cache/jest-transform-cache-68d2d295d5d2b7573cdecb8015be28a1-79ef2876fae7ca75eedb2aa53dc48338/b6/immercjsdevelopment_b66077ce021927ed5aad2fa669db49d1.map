{"version":3,"names":["immer_exports","__export","Immer","Immer2","applyPatches","castDraft","castImmutable","createDraft","current","enableMapSet","enablePatches","finishDraft","freeze","immerable","DRAFTABLE","isDraft","isDraftable","nothing","NOTHING","original","produce","produceWithPatches","setAutoFreeze","setUseStrictShallowCopy","module","exports","__toCommonJS","Symbol","for","DRAFT_STATE","errors","process","env","NODE_ENV","plugin","thing","data","die","error","args","e","msg","apply","Error","getPrototypeOf","Object","value","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","prototype","toString","proto","Ctor","hasOwnProperty","call","Function","base_","each","obj","iter","getArchtype","Reflect","ownKeys","forEach","key","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","add","is","x","y","target","Map","Set","latest","copy_","shallowCopy","base","strict","slice","isPlain","descriptors","getOwnPropertyDescriptors","keys","i","length","desc","writable","configurable","enumerable","create","assign","deep","isFrozen","clear","delete","dontMutateFrozenCollections","entries","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer2","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","isSet2","generatePatches_","parentState","targetObject","rootPath","targetIsSet","assigned_","concat","res","autoFreeze_","propertyIsEnumerable","createProxyProxy","parent","draft_","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","Proxy","revocable","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current2","currentState","markChanged","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","useStrictShallowCopy_","config","recipe","defaultBase","self","curriedProduce","base2","hasError","p","ip","patches","inversePatches","autoFreeze","useStrictShallowCopy","patch","op","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","push","currentImpl","copy","errorOffset","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","baseValue","replacement","parentType","join","type","deepClonePatchValue","splice","map","from","k","v","cloned","DraftMap","size","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","values","iterator","next","r","done","DraftSet","prepareSetCopy","JSON","stringify","immer","bind"],"sources":["../../src/immer.ts","../../src/utils/env.ts","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/plugins/patches.ts","../../src/plugins/mapset.ts"],"sourcesContent":["import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n * Regardless whether they are enumerable or symbols\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tReflect.ownKeys(obj).forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc.writable === false) {\n\t\t\t\tdesc.writable = true\n\t\t\t\tdesc.configurable = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\tvalue: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn Object.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = Object.create(proto)\n\t\treturn Object.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.entries (only string-like, enumerables) instead of each()\n\t\tObject.entries(obj).forEach(([key, value]) => freeze(value, true))\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(value, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path)\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// Immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\t// Per #590, we never freeze symbolic properties. Just to make sure don't accidentally interfere\n\t\t// with other frameworks.\n\t\tif (\n\t\t\t(!parentState || !parentState.scope_.parent_) &&\n\t\t\ttypeof prop !== \"symbol\" &&\n\t\t\tObject.prototype.propertyIsEnumerable.call(targetObject, prop)\n\t\t)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\";\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n"],"mappings":"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","ignoreList":[]}