c688adbbc971cc5453f4a5dd674f5cc7
/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@remix-run/router')) : typeof define === 'function' && define.amd ? define(['exports', 'react', '@remix-run/router'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouter = {}, global.React, global.RemixRouter));
})(this, function (exports, React, router) {
  'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var React__namespace = /*#__PURE__*/_interopNamespace(React);
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // Create react-specific types from the agnostic types in @remix-run/router to
  // export from react-router
  const DataRouterContext = /*#__PURE__*/React__namespace.createContext(null);
  {
    DataRouterContext.displayName = "DataRouter";
  }
  const DataRouterStateContext = /*#__PURE__*/React__namespace.createContext(null);
  {
    DataRouterStateContext.displayName = "DataRouterState";
  }
  const AwaitContext = /*#__PURE__*/React__namespace.createContext(null);
  {
    AwaitContext.displayName = "Await";
  }

  /**
   * A Navigator is a "location changer"; it's how you get to different locations.
   *
   * Every history instance conforms to the Navigator interface, but the
   * distinction is useful primarily when it comes to the low-level `<Router>` API
   * where both the location and a navigator must be provided separately in order
   * to avoid "tearing" that may occur in a suspense-enabled app if the action
   * and/or location were to be read directly from the history instance.
   */

  const NavigationContext = /*#__PURE__*/React__namespace.createContext(null);
  {
    NavigationContext.displayName = "Navigation";
  }
  const LocationContext = /*#__PURE__*/React__namespace.createContext(null);
  {
    LocationContext.displayName = "Location";
  }
  const RouteContext = /*#__PURE__*/React__namespace.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  {
    RouteContext.displayName = "Route";
  }
  const RouteErrorContext = /*#__PURE__*/React__namespace.createContext(null);
  {
    RouteErrorContext.displayName = "RouteError";
  }

  /**
   * Returns the full href for the given "to" value. This is useful for building
   * custom links that are also accessible and preserve right-click behavior.
   *
   * @see https://reactrouter.com/hooks/use-href
   */
  function useHref(to, _temp) {
    let {
      relative
    } = _temp === void 0 ? {} : _temp;
    !useInRouterContext() ? router.UNSAFE_invariant(false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component.") : void 0;
    let {
      basename,
      navigator
    } = React__namespace.useContext(NavigationContext);
    let {
      hash,
      pathname,
      search
    } = useResolvedPath(to, {
      relative
    });
    let joinedPathname = pathname;

    // If we're operating within a basename, prepend it to the pathname prior
    // to creating the href.  If this is a root navigation, then just use the raw
    // basename which allows the basename to have full control over the presence
    // of a trailing slash on root links
    if (basename !== "/") {
      joinedPathname = pathname === "/" ? basename : router.joinPaths([basename, pathname]);
    }
    return navigator.createHref({
      pathname: joinedPathname,
      search,
      hash
    });
  }

  /**
   * Returns true if this component is a descendant of a `<Router>`.
   *
   * @see https://reactrouter.com/hooks/use-in-router-context
   */
  function useInRouterContext() {
    return React__namespace.useContext(LocationContext) != null;
  }

  /**
   * Returns the current location object, which represents the current URL in web
   * browsers.
   *
   * Note: If you're using this it may mean you're doing some of your own
   * "routing" in your app, and we'd like to know what your use case is. We may
   * be able to provide something higher-level to better suit your needs.
   *
   * @see https://reactrouter.com/hooks/use-location
   */
  function useLocation() {
    !useInRouterContext() ? router.UNSAFE_invariant(false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component.") : void 0;
    return React__namespace.useContext(LocationContext).location;
  }

  /**
   * Returns the current navigation action which describes how the router came to
   * the current location, either by a pop, push, or replace on the history stack.
   *
   * @see https://reactrouter.com/hooks/use-navigation-type
   */
  function useNavigationType() {
    return React__namespace.useContext(LocationContext).navigationType;
  }

  /**
   * Returns a PathMatch object if the given pattern matches the current URL.
   * This is useful for components that need to know "active" state, e.g.
   * `<NavLink>`.
   *
   * @see https://reactrouter.com/hooks/use-match
   */
  function useMatch(pattern) {
    !useInRouterContext() ? router.UNSAFE_invariant(false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component.") : void 0;
    let {
      pathname
    } = useLocation();
    return React__namespace.useMemo(() => router.matchPath(pattern, pathname), [pathname, pattern]);
  }

  /**
   * The interface for the navigate() function returned from useNavigate().
   */

  const navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.";

  // Mute warnings for calls to useNavigate in SSR environments
  function useIsomorphicLayoutEffect(cb) {
    let isStatic = React__namespace.useContext(NavigationContext).static;
    if (!isStatic) {
      // We should be able to get rid of this once react 18.3 is released
      // See: https://github.com/facebook/react/pull/26395
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(cb);
    }
  }

  /**
   * Returns an imperative method for changing the location. Used by `<Link>`s, but
   * may also be used by other elements to change the location.
   *
   * @see https://reactrouter.com/hooks/use-navigate
   */
  function useNavigate() {
    let {
      isDataRoute
    } = React__namespace.useContext(RouteContext);
    // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return isDataRoute ? useNavigateStable() : useNavigateUnstable();
  }
  function useNavigateUnstable() {
    !useInRouterContext() ? router.UNSAFE_invariant(false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component.") : void 0;
    let dataRouterContext = React__namespace.useContext(DataRouterContext);
    let {
      basename,
      future,
      navigator
    } = React__namespace.useContext(NavigationContext);
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));
    let activeRef = React__namespace.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React__namespace.useCallback(function (to, options) {
      if (options === void 0) {
        options = {};
      }
      router.UNSAFE_warning(activeRef.current, navigateEffectWarning);

      // Short circuit here since if this happens on first render the navigate
      // is useless because we haven't wired up our history listener yet
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator.go(to);
        return;
      }
      let path = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");

      // If we're operating within a basename, prepend it to the pathname prior
      // to handing off to history (but only if we're not in a data router,
      // otherwise it'll prepend the basename inside of the router).
      // If this is a root navigation, then we navigate to the raw basename
      // which allows the basename to have full control over the presence of a
      // trailing slash on root links
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
    }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
    return navigate;
  }
  const OutletContext = /*#__PURE__*/React__namespace.createContext(null);

  /**
   * Returns the context (if provided) for the child route at this level of the route
   * hierarchy.
   * @see https://reactrouter.com/hooks/use-outlet-context
   */
  function useOutletContext() {
    return React__namespace.useContext(OutletContext);
  }

  /**
   * Returns the element for the child route at this level of the route
   * hierarchy. Used internally by `<Outlet>` to render child routes.
   *
   * @see https://reactrouter.com/hooks/use-outlet
   */
  function useOutlet(context) {
    let outlet = React__namespace.useContext(RouteContext).outlet;
    if (outlet) {
      return /*#__PURE__*/React__namespace.createElement(OutletContext.Provider, {
        value: context
      }, outlet);
    }
    return outlet;
  }

  /**
   * Returns an object of key/value pairs of the dynamic params from the current
   * URL that were matched by the route path.
   *
   * @see https://reactrouter.com/hooks/use-params
   */
  function useParams() {
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let routeMatch = matches[matches.length - 1];
    return routeMatch ? routeMatch.params : {};
  }

  /**
   * Resolves the pathname of the given `to` value against the current location.
   *
   * @see https://reactrouter.com/hooks/use-resolved-path
   */
  function useResolvedPath(to, _temp2) {
    let {
      relative
    } = _temp2 === void 0 ? {} : _temp2;
    let {
      future
    } = React__namespace.useContext(NavigationContext);
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));
    return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
  }

  /**
   * Returns the element of the route that matched the current location, prepared
   * with the correct context to render the remainder of the route tree. Route
   * elements in the tree must render an `<Outlet>` to render their child route's
   * element.
   *
   * @see https://reactrouter.com/hooks/use-routes
   */
  function useRoutes(routes, locationArg) {
    return useRoutesImpl(routes, locationArg);
  }

  // Internal implementation with accept optional param for RouterProvider usage
  function useRoutesImpl(routes, locationArg, dataRouterState, future) {
    !useInRouterContext() ? router.UNSAFE_invariant(false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component.") : void 0;
    let {
      navigator
    } = React__namespace.useContext(NavigationContext);
    let {
      matches: parentMatches
    } = React__namespace.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    let parentPathname = routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    let parentRoute = routeMatch && routeMatch.route;
    {
      // You won't get a warning about 2 different <Routes> under a <Route>
      // without a trailing *, but this is a best-effort warning anyway since we
      // cannot even give the warning unless they land at the parent route.
      //
      // Example:
      //
      // <Routes>
      //   {/* This route path MUST end with /* because otherwise
      //       it will never match /blog/post/123 */}
      //   <Route path="blog" element={<Blog />} />
      //   <Route path="blog/feed" element={<BlogFeed />} />
      // </Routes>
      //
      // function Blog() {
      //   return (
      //     <Routes>
      //       <Route path="post/:id" element={<Post />} />
      //     </Routes>
      //   );
      // }
      let parentPath = parentRoute && parentRoute.path || "";
      warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ("\"" + parentPathname + "\" (under <Route path=\"" + parentPath + "\">) but the ") + "parent route path has no trailing \"*\". This means if you navigate " + "deeper, the parent won't match anymore and therefore the child " + "routes will never render.\n\n" + ("Please change the parent <Route path=\"" + parentPath + "\"> to <Route ") + ("path=\"" + (parentPath === "/" ? "*" : parentPath + "/*") + "\">."));
    }
    let locationFromContext = useLocation();
    let location;
    if (locationArg) {
      var _parsedLocationArg$pa;
      let parsedLocationArg = typeof locationArg === "string" ? router.parsePath(locationArg) : locationArg;
      !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? router.UNSAFE_invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, " + "the location pathname must begin with the portion of the URL pathname that was " + ("matched by all parent routes. The current pathname base is \"" + parentPathnameBase + "\" ") + ("but pathname \"" + parsedLocationArg.pathname + "\" was given in the `location` prop.")) : void 0;
      location = parsedLocationArg;
    } else {
      location = locationFromContext;
    }
    let pathname = location.pathname || "/";
    let remainingPathname = pathname;
    if (parentPathnameBase !== "/") {
      // Determine the remaining pathname by removing the # of URL segments the
      // parentPathnameBase has, instead of removing based on character count.
      // This is because we can't guarantee that incoming/outgoing encodings/
      // decodings will match exactly.
      // We decode paths before matching on a per-segment basis with
      // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they
      // match what `window.location.pathname` would reflect.  Those don't 100%
      // align when it comes to encoded URI characters such as % and &.
      //
      // So we may end up with:
      //   pathname:           "/descendant/a%25b/match"
      //   parentPathnameBase: "/descendant/a%b"
      //
      // And the direct substring removal approach won't work :/
      let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
      let segments = pathname.replace(/^\//, "").split("/");
      remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
    }
    let matches = router.matchRoutes(routes, {
      pathname: remainingPathname
    });
    {
      router.UNSAFE_warning(parentRoute || matches != null, "No routes matched location \"" + location.pathname + location.search + location.hash + "\" ");
      router.UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, "Matched leaf route at location \"" + location.pathname + location.search + location.hash + "\" " + "does not have an element or Component. This means it will render an <Outlet /> with a " + "null value by default resulting in an \"empty\" page.");
    }
    let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
      params: Object.assign({}, parentParams, match.params),
      pathname: router.joinPaths([parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
      pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : router.joinPaths([parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
    })), parentMatches, dataRouterState, future);

    // When a user passes in a `locationArg`, the associated routes need to
    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
    // to use the scoped location instead of the global location.
    if (locationArg && renderedMatches) {
      return /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {
        value: {
          location: _extends({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default"
          }, location),
          navigationType: router.Action.Pop
        }
      }, renderedMatches);
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error = useRouteError();
    let message = router.isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
    let stack = error instanceof Error ? error.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = {
      padding: "0.5rem",
      backgroundColor: lightgrey
    };
    let codeStyles = {
      padding: "2px 4px",
      backgroundColor: lightgrey
    };
    let devInfo = null;
    {
      console.error("Error handled by React Router default ErrorBoundary:", error);
      devInfo = /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("p", null, "\uD83D\uDCBF Hey developer \uD83D\uDC4B"), /*#__PURE__*/React__namespace.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /*#__PURE__*/React__namespace.createElement("code", {
        style: codeStyles
      }, "ErrorBoundary"), " or", " ", /*#__PURE__*/React__namespace.createElement("code", {
        style: codeStyles
      }, "errorElement"), " prop on your route."));
    }
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("h2", null, "Unexpected Application Error!"), /*#__PURE__*/React__namespace.createElement("h3", {
      style: {
        fontStyle: "italic"
      }
    }, message), stack ? /*#__PURE__*/React__namespace.createElement("pre", {
      style: preStyles
    }, stack) : null, devInfo);
  }
  const defaultErrorElement = /*#__PURE__*/React__namespace.createElement(DefaultErrorComponent, null);
  class RenderErrorBoundary extends React__namespace.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error) {
      return {
        error: error
      };
    }
    static getDerivedStateFromProps(props, state) {
      // When we get into an error state, the user will likely click "back" to the
      // previous page that didn't have an error. Because this wraps the entire
      // application, that will have no effect--the error page continues to display.
      // This gives us a mechanism to recover from the error when the location changes.
      //
      // Whether we're in an error state or not, we update the location in state
      // so that when we are in an error state, it gets reset when a new location
      // comes in and the user recovers from the error.
      if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }

      // If we're not changing locations, preserve the location but still surface
      // any new errors that may come through. We retain the existing error, we do
      // this because the error provided from the app state may be cleared without
      // the location changing.
      return {
        error: props.error !== undefined ? props.error : state.error,
        location: state.location,
        revalidation: props.revalidation || state.revalidation
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error("React Router caught the following error during render", error, errorInfo);
    }
    render() {
      return this.state.error !== undefined ? /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {
        value: this.props.routeContext
      }, /*#__PURE__*/React__namespace.createElement(RouteErrorContext.Provider, {
        value: this.state.error,
        children: this.props.component
      })) : this.props.children;
    }
  }
  function RenderedRoute(_ref) {
    let {
      routeContext,
      match,
      children
    } = _ref;
    let dataRouterContext = React__namespace.useContext(DataRouterContext);

    // Track how deep we got in our render pass to emulate SSR componentDidCatch
    // in a DataStaticRouter
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
    }
    return /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {
      value: routeContext
    }, children);
  }
  function _renderMatches(matches, parentMatches, dataRouterState, future) {
    var _dataRouterState2;
    if (parentMatches === void 0) {
      parentMatches = [];
    }
    if (dataRouterState === void 0) {
      dataRouterState = null;
    }
    if (future === void 0) {
      future = null;
    }
    if (matches == null) {
      var _dataRouterState;
      if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
        // Don't bail if we have data router errors so we can render them in the
        // boundary.  Use the pre-matched (or shimmed) matches
        matches = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches;

    // If we have data errors, trim matches to the highest error boundary
    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
    if (errors != null) {
      let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);
      !(errorIndex >= 0) ? router.UNSAFE_invariant(false, "Could not find a matching route for errors on route IDs: " + Object.keys(errors).join(",")) : void 0;
      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
    }

    // If we're in a partial hydration mode, detect if we need to render down to
    // a given HydrateFallback while we load the rest of the hydration data
    let renderFallback = false;
    let fallbackIndex = -1;
    if (dataRouterState && future && future.v7_partialHydration) {
      for (let i = 0; i < renderedMatches.length; i++) {
        let match = renderedMatches[i];
        // Track the deepest fallback up until the first route without data
        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
          fallbackIndex = i;
        }
        if (match.route.id) {
          let {
            loaderData,
            errors
          } = dataRouterState;
          let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);
          if (match.route.lazy || needsToRunLoader) {
            // We found the first route that's not ready to render (waiting on
            // lazy, or has a loader that hasn't run yet).  Flag that we need to
            // render a fallback and render up until the appropriate fallback
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
    }
    return renderedMatches.reduceRight((outlet, match, index) => {
      // Only data routers handle errors/fallbacks
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match.route.id ? errors[match.route.id] : undefined;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          // Note: This is a de-optimized path since React won't re-use the
          // ReactElement since it's identity changes with each new
          // React.createElement call.  We keep this so folks can use
          // `<Route Component={...}>` in `<Routes>` but generally `Component`
          // usage is only advised in `RouterProvider` when we can convert it to
          // `element` ahead of time.
          children = /*#__PURE__*/React__namespace.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /*#__PURE__*/React__namespace.createElement(RenderedRoute, {
          match: match,
          routeContext: {
            outlet,
            matches,
            isDataRoute: dataRouterState != null
          },
          children: children
        });
      };
      // Only wrap in an error boundary within data router usages when we have an
      // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to
      // an ancestor ErrorBoundary/errorElement
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React__namespace.createElement(RenderErrorBoundary, {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error: error,
        children: getChildren(),
        routeContext: {
          outlet: null,
          matches,
          isDataRoute: true
        }
      }) : getChildren();
    }, null);
  }
  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {
    DataRouterHook["UseBlocker"] = "useBlocker";
    DataRouterHook["UseRevalidator"] = "useRevalidator";
    DataRouterHook["UseNavigateStable"] = "useNavigate";
    return DataRouterHook;
  }(DataRouterHook || {});
  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {
    DataRouterStateHook["UseBlocker"] = "useBlocker";
    DataRouterStateHook["UseLoaderData"] = "useLoaderData";
    DataRouterStateHook["UseActionData"] = "useActionData";
    DataRouterStateHook["UseRouteError"] = "useRouteError";
    DataRouterStateHook["UseNavigation"] = "useNavigation";
    DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
    DataRouterStateHook["UseMatches"] = "useMatches";
    DataRouterStateHook["UseRevalidator"] = "useRevalidator";
    DataRouterStateHook["UseNavigateStable"] = "useNavigate";
    DataRouterStateHook["UseRouteId"] = "useRouteId";
    return DataRouterStateHook;
  }(DataRouterStateHook || {});
  function getDataRouterConsoleError(hookName) {
    return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
  }
  function useDataRouterContext(hookName) {
    let ctx = React__namespace.useContext(DataRouterContext);
    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React__namespace.useContext(DataRouterStateContext);
    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
    return state;
  }
  function useRouteContext(hookName) {
    let route = React__namespace.useContext(RouteContext);
    !route ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
    return route;
  }

  // Internal version with hookName-aware debugging
  function useCurrentRouteId(hookName) {
    let route = useRouteContext(hookName);
    let thisRoute = route.matches[route.matches.length - 1];
    !thisRoute.route.id ? router.UNSAFE_invariant(false, hookName + " can only be used on routes that contain a unique \"id\"") : void 0;
    return thisRoute.route.id;
  }

  /**
   * Returns the ID for the nearest contextual route
   */
  function useRouteId() {
    return useCurrentRouteId(DataRouterStateHook.UseRouteId);
  }

  /**
   * Returns the current navigation, defaulting to an "idle" navigation when
   * no navigation is in progress
   */
  function useNavigation() {
    let state = useDataRouterState(DataRouterStateHook.UseNavigation);
    return state.navigation;
  }

  /**
   * Returns a revalidate function for manually triggering revalidation, as well
   * as the current state of any manual revalidations
   */
  function useRevalidator() {
    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
    return React__namespace.useMemo(() => ({
      revalidate: dataRouterContext.router.revalidate,
      state: state.revalidation
    }), [dataRouterContext.router.revalidate, state.revalidation]);
  }

  /**
   * Returns the active route matches, useful for accessing loaderData for
   * parent/child routes or the route "handle" property
   */
  function useMatches() {
    let {
      matches,
      loaderData
    } = useDataRouterState(DataRouterStateHook.UseMatches);
    return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);
  }

  /**
   * Returns the loader data for the nearest ancestor Route loader
   */
  function useLoaderData() {
    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
    if (state.errors && state.errors[routeId] != null) {
      console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
      return undefined;
    }
    return state.loaderData[routeId];
  }

  /**
   * Returns the loaderData for the given routeId
   */
  function useRouteLoaderData(routeId) {
    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
    return state.loaderData[routeId];
  }

  /**
   * Returns the action data for the nearest ancestor Route action
   */
  function useActionData() {
    let state = useDataRouterState(DataRouterStateHook.UseActionData);
    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
    return state.actionData ? state.actionData[routeId] : undefined;
  }

  /**
   * Returns the nearest ancestor Route error, which could be a loader/action
   * error or a render error.  This is intended to be called from your
   * ErrorBoundary/errorElement to display a proper error message.
   */
  function useRouteError() {
    var _state$errors;
    let error = React__namespace.useContext(RouteErrorContext);
    let state = useDataRouterState(DataRouterStateHook.UseRouteError);
    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);

    // If this was a render error, we put it in a RouteError context inside
    // of RenderErrorBoundary
    if (error !== undefined) {
      return error;
    }

    // Otherwise look for errors from our data router state
    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
  }

  /**
   * Returns the happy-path data from the nearest ancestor `<Await />` value
   */
  function useAsyncValue() {
    let value = React__namespace.useContext(AwaitContext);
    return value == null ? void 0 : value._data;
  }

  /**
   * Returns the error from the nearest ancestor `<Await />` value
   */
  function useAsyncError() {
    let value = React__namespace.useContext(AwaitContext);
    return value == null ? void 0 : value._error;
  }
  let blockerId = 0;

  /**
   * Allow the application to block navigations within the SPA and present the
   * user a confirmation dialog to confirm the navigation.  Mostly used to avoid
   * using half-filled form data.  This does not handle hard-reloads or
   * cross-origin navigations.
   */
  function useBlocker(shouldBlock) {
    let {
      router: router$1,
      basename
    } = useDataRouterContext(DataRouterHook.UseBlocker);
    let state = useDataRouterState(DataRouterStateHook.UseBlocker);
    let [blockerKey, setBlockerKey] = React__namespace.useState("");
    let blockerFunction = React__namespace.useCallback(arg => {
      if (typeof shouldBlock !== "function") {
        return !!shouldBlock;
      }
      if (basename === "/") {
        return shouldBlock(arg);
      }

      // If they provided us a function and we've got an active basename, strip
      // it from the locations we expose to the user to match the behavior of
      // useLocation
      let {
        currentLocation,
        nextLocation,
        historyAction
      } = arg;
      return shouldBlock({
        currentLocation: _extends({}, currentLocation, {
          pathname: router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
        }),
        nextLocation: _extends({}, nextLocation, {
          pathname: router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
        }),
        historyAction
      });
    }, [basename, shouldBlock]);

    // This effect is in charge of blocker key assignment and deletion (which is
    // tightly coupled to the key)
    React__namespace.useEffect(() => {
      let key = String(++blockerId);
      setBlockerKey(key);
      return () => router$1.deleteBlocker(key);
    }, [router$1]);

    // This effect handles assigning the blockerFunction.  This is to handle
    // unstable blocker function identities, and happens only after the prior
    // effect so we don't get an orphaned blockerFunction in the router with a
    // key of "".  Until then we just have the IDLE_BLOCKER.
    React__namespace.useEffect(() => {
      if (blockerKey !== "") {
        router$1.getBlocker(blockerKey, blockerFunction);
      }
    }, [router$1, blockerKey, blockerFunction]);

    // Prefer the blocker from `state` not `router.state` since DataRouterContext
    // is memoized so this ensures we update on blocker state updates
    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;
  }

  /**
   * Stable version of useNavigate that is used when we are in the context of
   * a RouterProvider.
   */
  function useNavigateStable() {
    let {
      router: router$1
    } = useDataRouterContext(DataRouterHook.UseNavigateStable);
    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
    let activeRef = React__namespace.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React__namespace.useCallback(function (to, options) {
      if (options === void 0) {
        options = {};
      }
      router.UNSAFE_warning(activeRef.current, navigateEffectWarning);

      // Short circuit here since if this happens on first render the navigate
      // is useless because we haven't wired up our router subscriber yet
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router$1.navigate(to);
      } else {
        router$1.navigate(to, _extends({
          fromRouteId: id
        }, options));
      }
    }, [router$1, id]);
    return navigate;
  }
  const alreadyWarned = {};
  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned[key]) {
      alreadyWarned[key] = true;
      router.UNSAFE_warning(false, message);
    }
  }

  /**
    Webpack + React 17 fails to compile on any of the following because webpack
    complains that `startTransition` doesn't exist in `React`:
    * import { startTransition } from "react"
    * import * as React from from "react";
      "startTransition" in React ? React.startTransition(() => setState()) : setState()
    * import * as React from from "react";
      "startTransition" in React ? React["startTransition"](() => setState()) : setState()
     Moving it to a constant such as the following solves the Webpack/React 17 issue:
    * import * as React from from "react";
      const START_TRANSITION = "startTransition";
      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()
     However, that introduces webpack/terser minification issues in production builds
    in React 18 where minification/obfuscation ends up removing the call of
    React.startTransition entirely from the first half of the ternary.  Grabbing
    this exported reference once up front resolves that issue.
     See https://github.com/remix-run/react-router/issues/10579
  */
  const START_TRANSITION = "startTransition";
  const startTransitionImpl = React__namespace[START_TRANSITION];

  /**
   * Given a Remix Router instance, render the appropriate UI
   */
  function RouterProvider(_ref) {
    let {
      fallbackElement,
      router: router$1,
      future
    } = _ref;
    let [state, setStateImpl] = React__namespace.useState(router$1.state);
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback(newState => {
      if (v7_startTransition && startTransitionImpl) {
        startTransitionImpl(() => setStateImpl(newState));
      } else {
        setStateImpl(newState);
      }
    }, [setStateImpl, v7_startTransition]);

    // Need to use a layout effect here so we are subscribed early enough to
    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)
    React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);
    React__namespace.useEffect(() => {
      router.UNSAFE_warning(fallbackElement == null || !router$1.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using " + "`v7_partialHydration`, use a `HydrateFallback` component instead");
      // Only log this once on initial mount
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    let navigator = React__namespace.useMemo(() => {
      return {
        createHref: router$1.createHref,
        encodeLocation: router$1.encodeLocation,
        go: n => router$1.navigate(n),
        push: (to, state, opts) => router$1.navigate(to, {
          state,
          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
        }),
        replace: (to, state, opts) => router$1.navigate(to, {
          replace: true,
          state,
          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
        })
      };
    }, [router$1]);
    let basename = router$1.basename || "/";
    let dataRouterContext = React__namespace.useMemo(() => ({
      router: router$1,
      navigator,
      static: false,
      basename
    }), [router$1, navigator, basename]);

    // The fragment and {null} here are important!  We need them to keep React 18's
    // useId happy when we are server-rendering since we may have a <script> here
    // containing the hydrated server-side staticContext (from StaticRouterProvider).
    // useId relies on the component tree structure to generate deterministic id's
    // so we need to ensure it remains the same on the client even though
    // we don't need the <script> tag
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(DataRouterContext.Provider, {
      value: dataRouterContext
    }, /*#__PURE__*/React__namespace.createElement(DataRouterStateContext.Provider, {
      value: state
    }, /*#__PURE__*/React__namespace.createElement(Router, {
      basename: basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: navigator,
      future: {
        v7_relativeSplatPath: router$1.future.v7_relativeSplatPath
      }
    }, state.initialized || router$1.future.v7_partialHydration ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {
      routes: router$1.routes,
      future: router$1.future,
      state: state
    }) : fallbackElement))), null);
  }
  function DataRoutes(_ref2) {
    let {
      routes,
      future,
      state
    } = _ref2;
    return useRoutesImpl(routes, undefined, state, future);
  }
  /**
   * A `<Router>` that stores all entries in memory.
   *
   * @see https://reactrouter.com/router-components/memory-router
   */
  function MemoryRouter(_ref3) {
    let {
      basename,
      children,
      initialEntries,
      initialIndex,
      future
    } = _ref3;
    let historyRef = React__namespace.useRef();
    if (historyRef.current == null) {
      historyRef.current = router.createMemoryHistory({
        initialEntries,
        initialIndex,
        v5Compat: true
      });
    }
    let history = historyRef.current;
    let [state, setStateImpl] = React__namespace.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback(newState => {
      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /*#__PURE__*/React__namespace.createElement(Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future: future
    });
  }
  /**
   * Changes the current location.
   *
   * Note: This API is mostly useful in React.Component subclasses that are not
   * able to use hooks. In functional components, we recommend you use the
   * `useNavigate` hook instead.
   *
   * @see https://reactrouter.com/components/navigate
   */
  function Navigate(_ref4) {
    let {
      to,
      replace,
      state,
      relative
    } = _ref4;
    !useInRouterContext() ? router.UNSAFE_invariant(false,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component.") : void 0;
    let {
      future,
      static: isStatic
    } = React__namespace.useContext(NavigationContext);
    router.UNSAFE_warning(!isStatic, "<Navigate> must not be used on the initial render in a <StaticRouter>. " + "This is a no-op, but you should modify your code so the <Navigate> is " + "only ever rendered in response to some user interaction or state change.");
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let navigate = useNavigate();

    // Resolve the path outside of the effect so that when effects run twice in
    // StrictMode they navigate to the same place
    let path = router.resolveTo(to, router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
    let jsonPath = JSON.stringify(path);
    React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {
      replace,
      state,
      relative
    }), [navigate, jsonPath, relative, replace, state]);
    return null;
  }
  /**
   * Renders the child route's element, if there is one.
   *
   * @see https://reactrouter.com/components/outlet
   */
  function Outlet(props) {
    return useOutlet(props.context);
  }
  /**
   * Declares an element that should be rendered at a certain URL path.
   *
   * @see https://reactrouter.com/components/route
   */
  function Route(_props) {
    router.UNSAFE_invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, " + "never rendered directly. Please wrap your <Route> in a <Routes>.");
  }
  /**
   * Provides location context for the rest of the app.
   *
   * Note: You usually won't render a `<Router>` directly. Instead, you'll render a
   * router that is more specific to your environment such as a `<BrowserRouter>`
   * in web browsers or a `<StaticRouter>` for server rendering.
   *
   * @see https://reactrouter.com/router-components/router
   */
  function Router(_ref5) {
    let {
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = router.Action.Pop,
      navigator,
      static: staticProp = false,
      future
    } = _ref5;
    !!useInRouterContext() ? router.UNSAFE_invariant(false, "You cannot render a <Router> inside another <Router>." + " You should never have more than one in your app.") : void 0;

    // Preserve trailing slashes on basename, so we can let the user control
    // the enforcement of trailing slashes throughout the app
    let basename = basenameProp.replace(/^\/*/, "/");
    let navigationContext = React__namespace.useMemo(() => ({
      basename,
      navigator,
      static: staticProp,
      future: _extends({
        v7_relativeSplatPath: false
      }, future)
    }), [basename, future, navigator, staticProp]);
    if (typeof locationProp === "string") {
      locationProp = router.parsePath(locationProp);
    }
    let {
      pathname = "/",
      search = "",
      hash = "",
      state = null,
      key = "default"
    } = locationProp;
    let locationContext = React__namespace.useMemo(() => {
      let trailingPathname = router.stripBasename(pathname, basename);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search,
          hash,
          state,
          key
        },
        navigationType
      };
    }, [basename, pathname, search, hash, state, key, navigationType]);
    router.UNSAFE_warning(locationContext != null, "<Router basename=\"" + basename + "\"> is not able to match the URL " + ("\"" + pathname + search + hash + "\" because it does not start with the ") + "basename, so the <Router> won't render anything.");
    if (locationContext == null) {
      return null;
    }
    return /*#__PURE__*/React__namespace.createElement(NavigationContext.Provider, {
      value: navigationContext
    }, /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {
      children: children,
      value: locationContext
    }));
  }
  /**
   * A container for a nested tree of `<Route>` elements that renders the branch
   * that best matches the current location.
   *
   * @see https://reactrouter.com/components/routes
   */
  function Routes(_ref6) {
    let {
      children,
      location
    } = _ref6;
    return useRoutes(createRoutesFromChildren(children), location);
  }
  /**
   * Component to use for rendering lazily loaded data from returning defer()
   * in a loader function
   */
  function Await(_ref7) {
    let {
      children,
      errorElement,
      resolve
    } = _ref7;
    return /*#__PURE__*/React__namespace.createElement(AwaitErrorBoundary, {
      resolve: resolve,
      errorElement: errorElement
    }, /*#__PURE__*/React__namespace.createElement(ResolveAwait, null, children));
  }
  var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {
    AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
    AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
    AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
    return AwaitRenderStatus;
  }(AwaitRenderStatus || {});
  const neverSettledPromise = new Promise(() => {});
  class AwaitErrorBoundary extends React__namespace.Component {
    constructor(props) {
      super(props);
      this.state = {
        error: null
      };
    }
    static getDerivedStateFromError(error) {
      return {
        error
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error("<Await> caught the following error during render", error, errorInfo);
    }
    render() {
      let {
        children,
        errorElement,
        resolve
      } = this.props;
      let promise = null;
      let status = AwaitRenderStatus.pending;
      if (!(resolve instanceof Promise)) {
        // Didn't get a promise - provide as a resolved promise
        status = AwaitRenderStatus.success;
        promise = Promise.resolve();
        Object.defineProperty(promise, "_tracked", {
          get: () => true
        });
        Object.defineProperty(promise, "_data", {
          get: () => resolve
        });
      } else if (this.state.error) {
        // Caught a render error, provide it as a rejected promise
        status = AwaitRenderStatus.error;
        let renderError = this.state.error;
        promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings
        Object.defineProperty(promise, "_tracked", {
          get: () => true
        });
        Object.defineProperty(promise, "_error", {
          get: () => renderError
        });
      } else if (resolve._tracked) {
        // Already tracked promise - check contents
        promise = resolve;
        status = "_error" in promise ? AwaitRenderStatus.error : "_data" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
      } else {
        // Raw (untracked) promise - track it
        status = AwaitRenderStatus.pending;
        Object.defineProperty(resolve, "_tracked", {
          get: () => true
        });
        promise = resolve.then(data => Object.defineProperty(resolve, "_data", {
          get: () => data
        }), error => Object.defineProperty(resolve, "_error", {
          get: () => error
        }));
      }
      if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {
        // Freeze the UI by throwing a never resolved promise
        throw neverSettledPromise;
      }
      if (status === AwaitRenderStatus.error && !errorElement) {
        // No errorElement, throw to the nearest route-level error boundary
        throw promise._error;
      }
      if (status === AwaitRenderStatus.error) {
        // Render via our errorElement
        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {
          value: promise,
          children: errorElement
        });
      }
      if (status === AwaitRenderStatus.success) {
        // Render children with resolved value
        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {
          value: promise,
          children: children
        });
      }

      // Throw to the suspense boundary
      throw promise;
    }
  }

  /**
   * @private
   * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`
   */
  function ResolveAwait(_ref8) {
    let {
      children
    } = _ref8;
    let data = useAsyncValue();
    let toRender = typeof children === "function" ? children(data) : children;
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, toRender);
  }

  ///////////////////////////////////////////////////////////////////////////////
  // UTILS
  ///////////////////////////////////////////////////////////////////////////////

  /**
   * Creates a route config from a React "children" object, which is usually
   * either a `<Route>` element or an array of them. Used internally by
   * `<Routes>` to create a route config from its children.
   *
   * @see https://reactrouter.com/utils/create-routes-from-children
   */
  function createRoutesFromChildren(children, parentPath) {
    if (parentPath === void 0) {
      parentPath = [];
    }
    let routes = [];
    React__namespace.Children.forEach(children, (element, index) => {
      if (! /*#__PURE__*/React__namespace.isValidElement(element)) {
        // Ignore non-elements. This allows people to more easily inline
        // conditionals in their route config.
        return;
      }
      let treePath = [...parentPath, index];
      if (element.type === React__namespace.Fragment) {
        // Transparently support React.Fragment and its children.
        routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
        return;
      }
      !(element.type === Route) ? router.UNSAFE_invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : void 0;
      !(!element.props.index || !element.props.children) ? router.UNSAFE_invariant(false, "An index route cannot have child routes.") : void 0;
      let route = {
        id: element.props.id || treePath.join("-"),
        caseSensitive: element.props.caseSensitive,
        element: element.props.element,
        Component: element.props.Component,
        index: element.props.index,
        path: element.props.path,
        loader: element.props.loader,
        action: element.props.action,
        errorElement: element.props.errorElement,
        ErrorBoundary: element.props.ErrorBoundary,
        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
        shouldRevalidate: element.props.shouldRevalidate,
        handle: element.props.handle,
        lazy: element.props.lazy
      };
      if (element.props.children) {
        route.children = createRoutesFromChildren(element.props.children, treePath);
      }
      routes.push(route);
    });
    return routes;
  }

  /**
   * Renders the result of `matchRoutes()` into a React element.
   */
  function renderMatches(matches) {
    return _renderMatches(matches);
  }
  function mapRouteProperties(route) {
    let updates = {
      // Note: this check also occurs in createRoutesFromChildren so update
      // there if you change this -- please and thank you!
      hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
    };
    if (route.Component) {
      {
        if (route.element) {
          router.UNSAFE_warning(false, "You should not include both `Component` and `element` on your route - " + "`Component` will be used.");
        }
      }
      Object.assign(updates, {
        element: /*#__PURE__*/React__namespace.createElement(route.Component),
        Component: undefined
      });
    }
    if (route.HydrateFallback) {
      {
        if (route.hydrateFallbackElement) {
          router.UNSAFE_warning(false, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - " + "`HydrateFallback` will be used.");
        }
      }
      Object.assign(updates, {
        hydrateFallbackElement: /*#__PURE__*/React__namespace.createElement(route.HydrateFallback),
        HydrateFallback: undefined
      });
    }
    if (route.ErrorBoundary) {
      {
        if (route.errorElement) {
          router.UNSAFE_warning(false, "You should not include both `ErrorBoundary` and `errorElement` on your route - " + "`ErrorBoundary` will be used.");
        }
      }
      Object.assign(updates, {
        errorElement: /*#__PURE__*/React__namespace.createElement(route.ErrorBoundary),
        ErrorBoundary: undefined
      });
    }
    return updates;
  }
  function createMemoryRouter(routes, opts) {
    return router.createRouter({
      basename: opts == null ? void 0 : opts.basename,
      future: _extends({}, opts == null ? void 0 : opts.future, {
        v7_prependBasename: true
      }),
      history: router.createMemoryHistory({
        initialEntries: opts == null ? void 0 : opts.initialEntries,
        initialIndex: opts == null ? void 0 : opts.initialIndex
      }),
      hydrationData: opts == null ? void 0 : opts.hydrationData,
      routes,
      mapRouteProperties,
      unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy
    }).initialize();
  }
  Object.defineProperty(exports, 'AbortedDeferredError', {
    enumerable: true,
    get: function () {
      return router.AbortedDeferredError;
    }
  });
  Object.defineProperty(exports, 'NavigationType', {
    enumerable: true,
    get: function () {
      return router.Action;
    }
  });
  Object.defineProperty(exports, 'createPath', {
    enumerable: true,
    get: function () {
      return router.createPath;
    }
  });
  Object.defineProperty(exports, 'defer', {
    enumerable: true,
    get: function () {
      return router.defer;
    }
  });
  Object.defineProperty(exports, 'generatePath', {
    enumerable: true,
    get: function () {
      return router.generatePath;
    }
  });
  Object.defineProperty(exports, 'isRouteErrorResponse', {
    enumerable: true,
    get: function () {
      return router.isRouteErrorResponse;
    }
  });
  Object.defineProperty(exports, 'json', {
    enumerable: true,
    get: function () {
      return router.json;
    }
  });
  Object.defineProperty(exports, 'matchPath', {
    enumerable: true,
    get: function () {
      return router.matchPath;
    }
  });
  Object.defineProperty(exports, 'matchRoutes', {
    enumerable: true,
    get: function () {
      return router.matchRoutes;
    }
  });
  Object.defineProperty(exports, 'parsePath', {
    enumerable: true,
    get: function () {
      return router.parsePath;
    }
  });
  Object.defineProperty(exports, 'redirect', {
    enumerable: true,
    get: function () {
      return router.redirect;
    }
  });
  Object.defineProperty(exports, 'redirectDocument', {
    enumerable: true,
    get: function () {
      return router.redirectDocument;
    }
  });
  Object.defineProperty(exports, 'resolvePath', {
    enumerable: true,
    get: function () {
      return router.resolvePath;
    }
  });
  exports.Await = Await;
  exports.MemoryRouter = MemoryRouter;
  exports.Navigate = Navigate;
  exports.Outlet = Outlet;
  exports.Route = Route;
  exports.Router = Router;
  exports.RouterProvider = RouterProvider;
  exports.Routes = Routes;
  exports.UNSAFE_DataRouterContext = DataRouterContext;
  exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;
  exports.UNSAFE_LocationContext = LocationContext;
  exports.UNSAFE_NavigationContext = NavigationContext;
  exports.UNSAFE_RouteContext = RouteContext;
  exports.UNSAFE_mapRouteProperties = mapRouteProperties;
  exports.UNSAFE_useRouteId = useRouteId;
  exports.UNSAFE_useRoutesImpl = useRoutesImpl;
  exports.createMemoryRouter = createMemoryRouter;
  exports.createRoutesFromChildren = createRoutesFromChildren;
  exports.createRoutesFromElements = createRoutesFromChildren;
  exports.renderMatches = renderMatches;
  exports.useActionData = useActionData;
  exports.useAsyncError = useAsyncError;
  exports.useAsyncValue = useAsyncValue;
  exports.useBlocker = useBlocker;
  exports.useHref = useHref;
  exports.useInRouterContext = useInRouterContext;
  exports.useLoaderData = useLoaderData;
  exports.useLocation = useLocation;
  exports.useMatch = useMatch;
  exports.useMatches = useMatches;
  exports.useNavigate = useNavigate;
  exports.useNavigation = useNavigation;
  exports.useNavigationType = useNavigationType;
  exports.useOutlet = useOutlet;
  exports.useOutletContext = useOutletContext;
  exports.useParams = useParams;
  exports.useResolvedPath = useResolvedPath;
  exports.useRevalidator = useRevalidator;
  exports.useRouteError = useRouteError;
  exports.useRouteLoaderData = useRouteLoaderData;
  exports.useRoutes = useRoutes;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEYXRhUm91dGVyQ29udGV4dCIsIlJlYWN0X19uYW1lc3BhY2UiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJEYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiQXdhaXRDb250ZXh0IiwiTmF2aWdhdGlvbkNvbnRleHQiLCJMb2NhdGlvbkNvbnRleHQiLCJSb3V0ZUNvbnRleHQiLCJvdXRsZXQiLCJtYXRjaGVzIiwiaXNEYXRhUm91dGUiLCJSb3V0ZUVycm9yQ29udGV4dCIsInVzZUhyZWYiLCJ0byIsIl90ZW1wIiwicmVsYXRpdmUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJyb3V0ZXIiLCJVTlNBRkVfaW52YXJpYW50IiwiYmFzZW5hbWUiLCJuYXZpZ2F0b3IiLCJ1c2VDb250ZXh0IiwiaGFzaCIsInBhdGhuYW1lIiwic2VhcmNoIiwidXNlUmVzb2x2ZWRQYXRoIiwiam9pbmVkUGF0aG5hbWUiLCJqb2luUGF0aHMiLCJjcmVhdGVIcmVmIiwidXNlTG9jYXRpb24iLCJsb2NhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwibmF2aWdhdGlvblR5cGUiLCJ1c2VNYXRjaCIsInBhdHRlcm4iLCJ1c2VNZW1vIiwibWF0Y2hQYXRoIiwibmF2aWdhdGVFZmZlY3RXYXJuaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImNiIiwiaXNTdGF0aWMiLCJzdGF0aWMiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VOYXZpZ2F0ZSIsInVzZU5hdmlnYXRlU3RhYmxlIiwidXNlTmF2aWdhdGVVbnN0YWJsZSIsImRhdGFSb3V0ZXJDb250ZXh0IiwiZnV0dXJlIiwibG9jYXRpb25QYXRobmFtZSIsInJvdXRlUGF0aG5hbWVzSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyIsInY3X3JlbGF0aXZlU3BsYXRQYXRoIiwiYWN0aXZlUmVmIiwidXNlUmVmIiwiY3VycmVudCIsIm5hdmlnYXRlIiwidXNlQ2FsbGJhY2siLCJvcHRpb25zIiwiVU5TQUZFX3dhcm5pbmciLCJnbyIsInBhdGgiLCJyZXNvbHZlVG8iLCJwYXJzZSIsInJlcGxhY2UiLCJwdXNoIiwic3RhdGUiLCJPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZU91dGxldCIsImNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVBhcmFtcyIsInJvdXRlTWF0Y2giLCJsZW5ndGgiLCJwYXJhbXMiLCJfdGVtcDIiLCJ1c2VSb3V0ZXMiLCJyb3V0ZXMiLCJsb2NhdGlvbkFyZyIsInVzZVJvdXRlc0ltcGwiLCJkYXRhUm91dGVyU3RhdGUiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsInJvdXRlIiwicGFyZW50UGF0aCIsIndhcm5pbmdPbmNlIiwiZW5kc1dpdGgiLCJsb2NhdGlvbkZyb21Db250ZXh0IiwiX3BhcnNlZExvY2F0aW9uQXJnJHBhIiwicGFyc2VkTG9jYXRpb25BcmciLCJwYXJzZVBhdGgiLCJzdGFydHNXaXRoIiwicmVtYWluaW5nUGF0aG5hbWUiLCJwYXJlbnRTZWdtZW50cyIsInNwbGl0Iiwic2VnbWVudHMiLCJzbGljZSIsImpvaW4iLCJtYXRjaFJvdXRlcyIsImVsZW1lbnQiLCJ1bmRlZmluZWQiLCJDb21wb25lbnQiLCJsYXp5IiwicmVuZGVyZWRNYXRjaGVzIiwiX3JlbmRlck1hdGNoZXMiLCJtYXAiLCJtYXRjaCIsIk9iamVjdCIsImFzc2lnbiIsImVuY29kZUxvY2F0aW9uIiwiX2V4dGVuZHMiLCJrZXkiLCJBY3Rpb24iLCJQb3AiLCJEZWZhdWx0RXJyb3JDb21wb25lbnQiLCJlcnJvciIsInVzZVJvdXRlRXJyb3IiLCJtZXNzYWdlIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJzdGFjayIsImxpZ2h0Z3JleSIsInByZVN0eWxlcyIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2RlU3R5bGVzIiwiZGV2SW5mbyIsImNvbnNvbGUiLCJGcmFnbWVudCIsInN0eWxlIiwiZm9udFN0eWxlIiwiZGVmYXVsdEVycm9yRWxlbWVudCIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwicmV2YWxpZGF0aW9uIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnJvckluZm8iLCJyZW5kZXIiLCJyb3V0ZUNvbnRleHQiLCJjaGlsZHJlbiIsImNvbXBvbmVudCIsIlJlbmRlcmVkUm91dGUiLCJfcmVmIiwic3RhdGljQ29udGV4dCIsImVycm9yRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlkIiwiX2RhdGFSb3V0ZXJTdGF0ZTIiLCJfZGF0YVJvdXRlclN0YXRlIiwiZXJyb3JzIiwiZXJyb3JJbmRleCIsImZpbmRJbmRleCIsIm0iLCJrZXlzIiwiTWF0aCIsIm1pbiIsInJlbmRlckZhbGxiYWNrIiwiZmFsbGJhY2tJbmRleCIsInY3X3BhcnRpYWxIeWRyYXRpb24iLCJpIiwiSHlkcmF0ZUZhbGxiYWNrIiwiaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCIsImxvYWRlckRhdGEiLCJuZWVkc1RvUnVuTG9hZGVyIiwibG9hZGVyIiwicmVkdWNlUmlnaHQiLCJpbmRleCIsInNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayIsImNvbmNhdCIsImdldENoaWxkcmVuIiwiRGF0YVJvdXRlckhvb2siLCJEYXRhUm91dGVyU3RhdGVIb29rIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJjdHgiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJ1c2VSb3V0ZUNvbnRleHQiLCJ1c2VDdXJyZW50Um91dGVJZCIsInRoaXNSb3V0ZSIsInVzZVJvdXRlSWQiLCJVc2VSb3V0ZUlkIiwidXNlTmF2aWdhdGlvbiIsIlVzZU5hdmlnYXRpb24iLCJuYXZpZ2F0aW9uIiwidXNlUmV2YWxpZGF0b3IiLCJVc2VSZXZhbGlkYXRvciIsInJldmFsaWRhdGUiLCJ1c2VNYXRjaGVzIiwiVXNlTWF0Y2hlcyIsIlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCIsInVzZUxvYWRlckRhdGEiLCJVc2VMb2FkZXJEYXRhIiwicm91dGVJZCIsInVzZVJvdXRlTG9hZGVyRGF0YSIsIlVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZUFjdGlvbkRhdGEiLCJVc2VBY3Rpb25EYXRhIiwiYWN0aW9uRGF0YSIsIl9zdGF0ZSRlcnJvcnMiLCJVc2VSb3V0ZUVycm9yIiwidXNlQXN5bmNWYWx1ZSIsIl9kYXRhIiwidXNlQXN5bmNFcnJvciIsIl9lcnJvciIsImJsb2NrZXJJZCIsInVzZUJsb2NrZXIiLCJzaG91bGRCbG9jayIsInJvdXRlciQxIiwiVXNlQmxvY2tlciIsImJsb2NrZXJLZXkiLCJzZXRCbG9ja2VyS2V5IiwidXNlU3RhdGUiLCJibG9ja2VyRnVuY3Rpb24iLCJhcmciLCJjdXJyZW50TG9jYXRpb24iLCJuZXh0TG9jYXRpb24iLCJoaXN0b3J5QWN0aW9uIiwic3RyaXBCYXNlbmFtZSIsInVzZUVmZmVjdCIsIlN0cmluZyIsImRlbGV0ZUJsb2NrZXIiLCJnZXRCbG9ja2VyIiwiYmxvY2tlcnMiLCJoYXMiLCJnZXQiLCJJRExFX0JMT0NLRVIiLCJVc2VOYXZpZ2F0ZVN0YWJsZSIsImZyb21Sb3V0ZUlkIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIlJvdXRlclByb3ZpZGVyIiwiZmFsbGJhY2tFbGVtZW50Iiwic2V0U3RhdGVJbXBsIiwidjdfc3RhcnRUcmFuc2l0aW9uIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsInN1YnNjcmliZSIsIm4iLCJvcHRzIiwicHJldmVudFNjcm9sbFJlc2V0IiwiUm91dGVyIiwiaW5pdGlhbGl6ZWQiLCJEYXRhUm91dGVzIiwiX3JlZjIiLCJNZW1vcnlSb3V0ZXIiLCJfcmVmMyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiaGlzdG9yeVJlZiIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJ2NUNvbXBhdCIsImhpc3RvcnkiLCJhY3Rpb24iLCJsaXN0ZW4iLCJOYXZpZ2F0ZSIsIl9yZWY0IiwianNvblBhdGgiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsIl9yZWY1IiwiYmFzZW5hbWVQcm9wIiwibG9jYXRpb25Qcm9wIiwic3RhdGljUHJvcCIsIm5hdmlnYXRpb25Db250ZXh0IiwibG9jYXRpb25Db250ZXh0IiwidHJhaWxpbmdQYXRobmFtZSIsIlJvdXRlcyIsIl9yZWY2IiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiQXdhaXQiLCJfcmVmNyIsInJlc29sdmUiLCJBd2FpdEVycm9yQm91bmRhcnkiLCJSZXNvbHZlQXdhaXQiLCJBd2FpdFJlbmRlclN0YXR1cyIsIm5ldmVyU2V0dGxlZFByb21pc2UiLCJQcm9taXNlIiwicHJvbWlzZSIsInBlbmRpbmciLCJzdWNjZXNzIiwiZGVmaW5lUHJvcGVydHkiLCJyZW5kZXJFcnJvciIsInJlamVjdCIsImNhdGNoIiwiX3RyYWNrZWQiLCJ0aGVuIiwiZGF0YSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiX3JlZjgiLCJ0b1JlbmRlciIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImlzVmFsaWRFbGVtZW50IiwidHJlZVBhdGgiLCJ0eXBlIiwiYXBwbHkiLCJuYW1lIiwiY2FzZVNlbnNpdGl2ZSIsImhhc0Vycm9yQm91bmRhcnkiLCJzaG91bGRSZXZhbGlkYXRlIiwiaGFuZGxlIiwicmVuZGVyTWF0Y2hlcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsInVwZGF0ZXMiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVSb3V0ZXIiLCJ2N19wcmVwZW5kQmFzZW5hbWUiLCJoeWRyYXRpb25EYXRhIiwidW5zdGFibGVfZGF0YVN0cmF0ZWd5IiwiaW5pdGlhbGl6ZSJdLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jb250ZXh0LnRzIiwiLi4vLi4vbGliL2hvb2tzLnRzeCIsIi4uLy4uL2xpYi9jb21wb25lbnRzLnRzeCIsIi4uLy4uL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QsXG4gIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCxcbiAgQWdub3N0aWNSb3V0ZU1hdGNoLFxuICBIaXN0b3J5LFxuICBMYXp5Um91dGVGdW5jdGlvbixcbiAgTG9jYXRpb24sXG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbiAgUm91dGVyLFxuICBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgVG8sXG4gIFRyYWNrZWRQcm9taXNlLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcblxuLy8gQ3JlYXRlIHJlYWN0LXNwZWNpZmljIHR5cGVzIGZyb20gdGhlIGFnbm9zdGljIHR5cGVzIGluIEByZW1peC1ydW4vcm91dGVyIHRvXG4vLyBleHBvcnQgZnJvbSByZWFjdC1yb3V0ZXJcbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleDogdHJ1ZTtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgQ29tcG9uZW50PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIEh5ZHJhdGVGYWxsYmFjaz86IFJlYWN0LkNvbXBvbmVudFR5cGUgfCBudWxsO1xuICBFcnJvckJvdW5kYXJ5PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIGxhenk/OiBMYXp5Um91dGVGdW5jdGlvbjxSb3V0ZU9iamVjdD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9uSW5kZXhSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbG9hZGVyPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleD86IGZhbHNlO1xuICBjaGlsZHJlbj86IFJvdXRlT2JqZWN0W107XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgQ29tcG9uZW50PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIEh5ZHJhdGVGYWxsYmFjaz86IFJlYWN0LkNvbXBvbmVudFR5cGUgfCBudWxsO1xuICBFcnJvckJvdW5kYXJ5PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIGxhenk/OiBMYXp5Um91dGVGdW5jdGlvbjxSb3V0ZU9iamVjdD47XG59XG5cbmV4cG9ydCB0eXBlIFJvdXRlT2JqZWN0ID0gSW5kZXhSb3V0ZU9iamVjdCB8IE5vbkluZGV4Um91dGVPYmplY3Q7XG5cbmV4cG9ydCB0eXBlIERhdGFSb3V0ZU9iamVjdCA9IFJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IERhdGFSb3V0ZU9iamVjdFtdO1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgUm91dGVPYmplY3QgPSBSb3V0ZU9iamVjdFxuPiBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFSb3V0ZU1hdGNoIGV4dGVuZHMgUm91dGVNYXRjaDxzdHJpbmcsIERhdGFSb3V0ZU9iamVjdD4ge31cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhUm91dGVyQ29udGV4dE9iamVjdFxuICAvLyBPbWl0IGBmdXR1cmVgIHNpbmNlIHRob3NlIGNhbiBiZSBwdWxsZWQgZnJvbSB0aGUgYHJvdXRlcmBcbiAgLy8gYE5hdmlnYXRpb25Db250ZXh0YCBuZWVkcyBmdXR1cmUgc2luY2UgaXQgZG9lc24ndCBoYXZlIGEgYHJvdXRlcmAgaW4gYWxsIGNhc2VzXG4gIGV4dGVuZHMgT21pdDxOYXZpZ2F0aW9uQ29udGV4dE9iamVjdCwgXCJmdXR1cmVcIj4ge1xuICByb3V0ZXI6IFJvdXRlcjtcbiAgc3RhdGljQ29udGV4dD86IFN0YXRpY0hhbmRsZXJDb250ZXh0O1xufVxuXG5leHBvcnQgY29uc3QgRGF0YVJvdXRlckNvbnRleHQgPVxuICBSZWFjdC5jcmVhdGVDb250ZXh0PERhdGFSb3V0ZXJDb250ZXh0T2JqZWN0IHwgbnVsbD4obnVsbCk7XG5pZiAoX19ERVZfXykge1xuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xufVxuXG5leHBvcnQgY29uc3QgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8XG4gIFJvdXRlcltcInN0YXRlXCJdIHwgbnVsbFxuPihudWxsKTtcbmlmIChfX0RFVl9fKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xufVxuXG5leHBvcnQgY29uc3QgQXdhaXRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxUcmFja2VkUHJvbWlzZSB8IG51bGw+KG51bGwpO1xuaWYgKF9fREVWX18pIHtcbiAgQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlT3B0aW9ucyB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuICB1bnN0YWJsZV9mbHVzaFN5bmM/OiBib29sZWFuO1xuICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIGA8Um91dGVyPmAgQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0b3Ige1xuICBjcmVhdGVIcmVmOiBIaXN0b3J5W1wiY3JlYXRlSHJlZlwiXTtcbiAgLy8gT3B0aW9uYWwgZm9yIGJhY2t3YXJkcy1jb21wYXQgd2l0aCBSb3V0ZXIvSGlzdG9yeVJvdXRlciB1c2FnZSAoZWRnZSBjYXNlKVxuICBlbmNvZGVMb2NhdGlvbj86IEhpc3RvcnlbXCJlbmNvZGVMb2NhdGlvblwiXTtcbiAgZ286IEhpc3RvcnlbXCJnb1wiXTtcbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55LCBvcHRzPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbiAgcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55LCBvcHRzPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIE5hdmlnYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgYmFzZW5hbWU6IHN0cmluZztcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYzogYm9vbGVhbjtcbiAgZnV0dXJlOiB7XG4gICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IGJvb2xlYW47XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmF2aWdhdGlvbkNvbnRleHRPYmplY3Q+KFxuICBudWxsIVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIExvY2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmF2aWdhdGlvblR5cGU6IE5hdmlnYXRpb25UeXBlO1xufVxuXG5leHBvcnQgY29uc3QgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxMb2NhdGlvbkNvbnRleHRPYmplY3Q+KFxuICBudWxsIVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlQ29udGV4dE9iamVjdCB7XG4gIG91dGxldDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbDtcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdO1xuICBpc0RhdGFSb3V0ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Um91dGVDb250ZXh0T2JqZWN0Pih7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW10sXG4gIGlzRGF0YVJvdXRlOiBmYWxzZSxcbn0pO1xuXG5pZiAoX19ERVZfXykge1xuICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG59XG5cbmV4cG9ydCBjb25zdCBSb3V0ZUVycm9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8YW55PihudWxsKTtcblxuaWYgKF9fREVWX18pIHtcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBCbG9ja2VyLFxuICBCbG9ja2VyRnVuY3Rpb24sXG4gIExvY2F0aW9uLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXJhbXMsXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aFBhdHRlcm4sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbiAgUmV2YWxpZGF0aW9uU3RhdGUsXG4gIFRvLFxuICBVSU1hdGNoLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIElETEVfQkxPQ0tFUixcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2ggYXMgY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsXG4gIFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzIGFzIGdldFJlc29sdmVUb01hdGNoZXMsXG4gIFVOU0FGRV9pbnZhcmlhbnQgYXMgaW52YXJpYW50LFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgam9pblBhdGhzLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlc29sdmVUbyxcbiAgc3RyaXBCYXNlbmFtZSxcbiAgVU5TQUZFX3dhcm5pbmcgYXMgd2FybmluZyxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUm91dGVDb250ZXh0T2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgQXdhaXRDb250ZXh0LFxuICBEYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0LFxuICBSb3V0ZUVycm9yQ29udGV4dCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGJ1aWxkaW5nXG4gKiBjdXN0b20gbGlua3MgdGhhdCBhcmUgYWxzbyBhY2Nlc3NpYmxlIGFuZCBwcmVzZXJ2ZSByaWdodC1jbGljayBiZWhhdmlvci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1ocmVmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VIcmVmKFxuICB0bzogVG8sXG4gIHsgcmVsYXRpdmUgfTogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pOiBzdHJpbmcge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcblxuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBocmVmLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3XG4gIC8vIGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2VcbiAgLy8gb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBqb2luZWRQYXRobmFtZSA9XG4gICAgICBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoeyBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgYDxSb3V0ZXI+YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1pbi1yb3V0ZXItY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpOiBOYXZpZ2F0aW9uVHlwZSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFBhdGhNYXRjaCBvYmplY3QgaWYgdGhlIGdpdmVuIHBhdHRlcm4gbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8ga25vdyBcImFjdGl2ZVwiIHN0YXRlLCBlLmcuXG4gKiBgPE5hdkxpbms+YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1tYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbmNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9XG4gIGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBgICtcbiAgYHlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLmA7XG5cbi8vIE11dGUgd2FybmluZ3MgZm9yIGNhbGxzIHRvIHVzZU5hdmlnYXRlIGluIFNTUiBlbnZpcm9ubWVudHNcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoXG4gIGNiOiBQYXJhbWV0ZXJzPHR5cGVvZiBSZWFjdC51c2VMYXlvdXRFZmZlY3Q+WzBdXG4pIHtcbiAgbGV0IGlzU3RhdGljID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG9uY2UgcmVhY3QgMTguMyBpcyByZWxlYXNlZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbXBlcmF0aXZlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGxvY2F0aW9uLiBVc2VkIGJ5IGA8TGluaz5gcywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRlKCk6IE5hdmlnYXRlRnVuY3Rpb24ge1xuICBsZXQgeyBpc0RhdGFSb3V0ZSB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICByZXR1cm4gaXNEYXRhUm91dGUgPyB1c2VOYXZpZ2F0ZVN0YWJsZSgpIDogdXNlTmF2aWdhdGVVbnN0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk6IE5hdmlnYXRlRnVuY3Rpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBsZXQgeyBiYXNlbmFtZSwgZnV0dXJlLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aClcbiAgKTtcblxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgaGlzdG9yeSBsaXN0ZW5lciB5ZXRcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKTtcblxuICAgICAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAgICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgICAvLyBvdGhlcndpc2UgaXQnbGwgcHJlcGVuZCB0aGUgYmFzZW5hbWUgaW5zaWRlIG9mIHRoZSByb3V0ZXIpLlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiB3ZSBuYXZpZ2F0ZSB0byB0aGUgcmF3IGJhc2VuYW1lXG4gICAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAgIC8vIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgICAgICBwYXRoLnBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICAgICAgPyBiYXNlbmFtZVxuICAgICAgICAgICAgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH0sXG4gICAgW1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICByb3V0ZVBhdGhuYW1lc0pzb24sXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgZGF0YVJvdXRlckNvbnRleHQsXG4gICAgXVxuICApO1xuXG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cblxuY29uc3QgT3V0bGV0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5rbm93bj4obnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldC1jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0PENvbnRleHQgPSB1bmtub3duPigpOiBDb250ZXh0IHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCkgYXMgQ29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IGA8T3V0bGV0PmAgdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0PzogdW5rbm93bik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0bGV0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+e291dGxldH08L091dGxldENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFyYW1zPFxuICBQYXJhbXNPcktleSBleHRlbmRzIHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSBzdHJpbmdcbj4oKTogUmVhZG9ubHk8XG4gIFtQYXJhbXNPcktleV0gZXh0ZW5kcyBbc3RyaW5nXSA/IFBhcmFtczxQYXJhbXNPcktleT4gOiBQYXJ0aWFsPFBhcmFtc09yS2V5PlxuPiB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gKHJvdXRlTWF0Y2gucGFyYW1zIGFzIGFueSkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yZXNvbHZlZC1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgoXG4gIHRvOiBUbyxcbiAgeyByZWxhdGl2ZSB9OiB7IHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZSB9ID0ge31cbik6IFBhdGgge1xuICBsZXQgeyBmdXR1cmUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgICApLFxuICAgIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZV1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXG4gKiBlbGVtZW50cyBpbiB0aGUgdHJlZSBtdXN0IHJlbmRlciBhbiBgPE91dGxldD5gIHRvIHJlbmRlciB0aGVpciBjaGlsZCByb3V0ZSdzXG4gKiBlbGVtZW50LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGxvY2F0aW9uQXJnPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmdcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnKTtcbn1cblxuLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gd2l0aCBhY2NlcHQgb3B0aW9uYWwgcGFyYW0gZm9yIFJvdXRlclByb3ZpZGVyIHVzYWdlXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVzSW1wbChcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nLFxuICBkYXRhUm91dGVyU3RhdGU/OiBSZW1peFJvdXRlcltcInN0YXRlXCJdLFxuICBmdXR1cmU/OiBSZW1peFJvdXRlcltcImZ1dHVyZVwiXVxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXM6IHBhcmVudE1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgbGV0IHBhcmVudFBhdGhuYW1lID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWUgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IChwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoKSB8fCBcIlwiO1xuICAgIHdhcm5pbmdPbmNlKFxuICAgICAgcGFyZW50UGF0aG5hbWUsXG4gICAgICAhcGFyZW50Um91dGUgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIipcIiksXG4gICAgICBgWW91IHJlbmRlcmVkIGRlc2NlbmRhbnQgPFJvdXRlcz4gKG9yIGNhbGxlZCBcXGB1c2VSb3V0ZXMoKVxcYCkgYXQgYCArXG4gICAgICAgIGBcIiR7cGFyZW50UGF0aG5hbWV9XCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPikgYnV0IHRoZSBgICtcbiAgICAgICAgYHBhcmVudCByb3V0ZSBwYXRoIGhhcyBubyB0cmFpbGluZyBcIipcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgYCArXG4gICAgICAgIGBkZWVwZXIsIHRoZSBwYXJlbnQgd29uJ3QgbWF0Y2ggYW55bW9yZSBhbmQgdGhlcmVmb3JlIHRoZSBjaGlsZCBgICtcbiAgICAgICAgYHJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5gICtcbiAgICAgICAgYFBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4gdG8gPFJvdXRlIGAgK1xuICAgICAgICBgcGF0aD1cIiR7cGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IGAke3BhcmVudFBhdGh9LypgfVwiPi5gXG4gICAgKTtcbiAgfVxuXG4gIGxldCBsb2NhdGlvbkZyb21Db250ZXh0ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgbG9jYXRpb247XG4gIGlmIChsb2NhdGlvbkFyZykge1xuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9XG4gICAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8XG4gICAgICAgIHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lPy5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSksXG4gICAgICBgV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBcXGA8Um91dGVzIGxvY2F0aW9uPlxcYCBvciBcXGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilcXGAsIGAgK1xuICAgICAgICBgdGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIGAgK1xuICAgICAgICBgbWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcIiR7cGFyZW50UGF0aG5hbWVCYXNlfVwiIGAgK1xuICAgICAgICBgYnV0IHBhdGhuYW1lIFwiJHtwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZX1cIiB3YXMgZ2l2ZW4gaW4gdGhlIFxcYGxvY2F0aW9uXFxgIHByb3AuYFxuICAgICk7XG5cbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuXG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuXG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAocGFyZW50UGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgIC8vIERldGVybWluZSB0aGUgcmVtYWluaW5nIHBhdGhuYW1lIGJ5IHJlbW92aW5nIHRoZSAjIG9mIFVSTCBzZWdtZW50cyB0aGVcbiAgICAvLyBwYXJlbnRQYXRobmFtZUJhc2UgaGFzLCBpbnN0ZWFkIG9mIHJlbW92aW5nIGJhc2VkIG9uIGNoYXJhY3RlciBjb3VudC5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgY2FuJ3QgZ3VhcmFudGVlIHRoYXQgaW5jb21pbmcvb3V0Z29pbmcgZW5jb2RpbmdzL1xuICAgIC8vIGRlY29kaW5ncyB3aWxsIG1hdGNoIGV4YWN0bHkuXG4gICAgLy8gV2UgZGVjb2RlIHBhdGhzIGJlZm9yZSBtYXRjaGluZyBvbiBhIHBlci1zZWdtZW50IGJhc2lzIHdpdGhcbiAgICAvLyBkZWNvZGVVUklDb21wb25lbnQoKSwgYnV0IHdlIHJlLWVuY29kZSBwYXRobmFtZXMgdmlhIGBuZXcgVVJMKClgIHNvIHRoZXlcbiAgICAvLyBtYXRjaCB3aGF0IGB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVgIHdvdWxkIHJlZmxlY3QuICBUaG9zZSBkb24ndCAxMDAlXG4gICAgLy8gYWxpZ24gd2hlbiBpdCBjb21lcyB0byBlbmNvZGVkIFVSSSBjaGFyYWN0ZXJzIHN1Y2ggYXMgJSBhbmQgJi5cbiAgICAvL1xuICAgIC8vIFNvIHdlIG1heSBlbmQgdXAgd2l0aDpcbiAgICAvLyAgIHBhdGhuYW1lOiAgICAgICAgICAgXCIvZGVzY2VuZGFudC9hJTI1Yi9tYXRjaFwiXG4gICAgLy8gICBwYXJlbnRQYXRobmFtZUJhc2U6IFwiL2Rlc2NlbmRhbnQvYSViXCJcbiAgICAvL1xuICAgIC8vIEFuZCB0aGUgZGlyZWN0IHN1YnN0cmluZyByZW1vdmFsIGFwcHJvYWNoIHdvbid0IHdvcmsgOi9cbiAgICBsZXQgcGFyZW50U2VnbWVudHMgPSBwYXJlbnRQYXRobmFtZUJhc2UucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgc2VnbWVudHMgPSBwYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gXCIvXCIgKyBzZWdtZW50cy5zbGljZShwYXJlbnRTZWdtZW50cy5sZW5ndGgpLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuXG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5Db21wb25lbnQgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubGF6eSAhPT0gdW5kZWZpbmVkLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGAgK1xuICAgICAgICBgZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBgICtcbiAgICAgICAgYG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cblxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJlxuICAgICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW1xuICAgICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvblxuICAgICAgICAgICAgICA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZSkucGF0aG5hbWVcbiAgICAgICAgICAgICAgOiBtYXRjaC5wYXRobmFtZSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBwYXRobmFtZUJhc2U6XG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICAgICAgICAgID8gcGFyZW50UGF0aG5hbWVCYXNlXG4gICAgICAgICAgICAgIDogam9pblBhdGhzKFtcbiAgICAgICAgICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAgICAgICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZVxuICAgICAgICAgICAgICAgICAgICA6IG1hdGNoLnBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgcGFyZW50TWF0Y2hlcyxcbiAgICBkYXRhUm91dGVyU3RhdGUsXG4gICAgZnV0dXJlXG4gICk7XG5cbiAgLy8gV2hlbiBhIHVzZXIgcGFzc2VzIGluIGEgYGxvY2F0aW9uQXJnYCwgdGhlIGFzc29jaWF0ZWQgcm91dGVzIG5lZWQgdG9cbiAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxuICAvLyB0byB1c2UgdGhlIHNjb3BlZCBsb2NhdGlvbiBpbnN0ZWFkIG9mIHRoZSBnbG9iYWwgbG9jYXRpb24uXG4gIGlmIChsb2NhdGlvbkFyZyAmJiByZW5kZXJlZE1hdGNoZXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICB2YWx1ZT17e1xuICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgICBoYXNoOiBcIlwiLFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGUuUG9wLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7cmVuZGVyZWRNYXRjaGVzfVxuICAgICAgPC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckNvbXBvbmVudCgpIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBsZXQgbWVzc2FnZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKVxuICAgID8gYCR7ZXJyb3Iuc3RhdHVzfSAke2Vycm9yLnN0YXR1c1RleHR9YFxuICAgIDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgID8gZXJyb3IubWVzc2FnZVxuICAgIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XG4gIGxldCBwcmVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMC41cmVtXCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIGxldCBjb2RlU3R5bGVzID0geyBwYWRkaW5nOiBcIjJweCA0cHhcIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcblxuICBsZXQgZGV2SW5mbyA9IG51bGw7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiRXJyb3IgaGFuZGxlZCBieSBSZWFjdCBSb3V0ZXIgZGVmYXVsdCBFcnJvckJvdW5kYXJ5OlwiLFxuICAgICAgZXJyb3JcbiAgICApO1xuXG4gICAgZGV2SW5mbyA9IChcbiAgICAgIDw+XG4gICAgICAgIDxwPvCfkr8gSGV5IGRldmVsb3BlciDwn5GLPC9wPlxuICAgICAgICA8cD5cbiAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnNcbiAgICAgICAgICBieSBwcm92aWRpbmcgeW91ciBvd24gPGNvZGUgc3R5bGU9e2NvZGVTdHlsZXN9PkVycm9yQm91bmRhcnk8L2NvZGU+IG9ye1wiIFwifVxuICAgICAgICAgIDxjb2RlIHN0eWxlPXtjb2RlU3R5bGVzfT5lcnJvckVsZW1lbnQ8L2NvZGU+IHByb3Agb24geW91ciByb3V0ZS5cbiAgICAgICAgPC9wPlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxoMj5VbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yITwvaDI+XG4gICAgICA8aDMgc3R5bGU9e3sgZm9udFN0eWxlOiBcIml0YWxpY1wiIH19PnttZXNzYWdlfTwvaDM+XG4gICAgICB7c3RhY2sgPyA8cHJlIHN0eWxlPXtwcmVTdHlsZXN9PntzdGFja308L3ByZT4gOiBudWxsfVxuICAgICAge2RldkluZm99XG4gICAgPC8+XG4gICk7XG59XG5cbmNvbnN0IGRlZmF1bHRFcnJvckVsZW1lbnQgPSA8RGVmYXVsdEVycm9yQ29tcG9uZW50IC8+O1xuXG50eXBlIFJlbmRlckVycm9yQm91bmRhcnlQcm9wcyA9IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xuICByZXZhbGlkYXRpb246IFJldmFsaWRhdGlvblN0YXRlO1xuICBlcnJvcjogYW55O1xuICBjb21wb25lbnQ6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcm91dGVDb250ZXh0OiBSb3V0ZUNvbnRleHRPYmplY3Q7XG59PjtcblxudHlwZSBSZW5kZXJFcnJvckJvdW5kYXJ5U3RhdGUgPSB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgcmV2YWxpZGF0aW9uOiBSZXZhbGlkYXRpb25TdGF0ZTtcbiAgZXJyb3I6IGFueTtcbn07XG5cbmV4cG9ydCBjbGFzcyBSZW5kZXJFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIFJlbmRlckVycm9yQm91bmRhcnlTdGF0ZVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4geyBlcnJvcjogZXJyb3IgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgcHJvcHM6IFJlbmRlckVycm9yQm91bmRhcnlQcm9wcyxcbiAgICBzdGF0ZTogUmVuZGVyRXJyb3JCb3VuZGFyeVN0YXRlXG4gICkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiwgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZSBjb250aW51ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3Igd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChcbiAgICAgIHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fFxuICAgICAgKHN0YXRlLnJldmFsaWRhdGlvbiAhPT0gXCJpZGxlXCIgJiYgcHJvcHMucmV2YWxpZGF0aW9uID09PSBcImlkbGVcIilcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXG4gICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciAhPT0gdW5kZWZpbmVkID8gcHJvcHMuZXJyb3IgOiBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvbixcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3I6IGFueSwgZXJyb3JJbmZvOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yICE9PSB1bmRlZmluZWQgPyAoXG4gICAgICA8Um91dGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0aGlzLnByb3BzLnJvdXRlQ29udGV4dH0+XG4gICAgICAgIDxSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmVycm9yfVxuICAgICAgICAgIGNoaWxkcmVuPXt0aGlzLnByb3BzLmNvbXBvbmVudH1cbiAgICAgICAgLz5cbiAgICAgIDwvUm91dGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICkgOiAoXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmVuZGVyZWRSb3V0ZVByb3BzIHtcbiAgcm91dGVDb250ZXh0OiBSb3V0ZUNvbnRleHRPYmplY3Q7XG4gIG1hdGNoOiBSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3Q+O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZSh7IHJvdXRlQ29udGV4dCwgbWF0Y2gsIGNoaWxkcmVuIH06IFJlbmRlcmVkUm91dGVQcm9wcykge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcblxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICBpZiAoXG4gICAgZGF0YVJvdXRlckNvbnRleHQgJiZcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiZcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0ICYmXG4gICAgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KVxuICApIHtcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3JvdXRlQ29udGV4dH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Sb3V0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbCxcbiAgcGFyZW50TWF0Y2hlczogUm91dGVNYXRjaFtdID0gW10sXG4gIGRhdGFSb3V0ZXJTdGF0ZTogUmVtaXhSb3V0ZXJbXCJzdGF0ZVwiXSB8IG51bGwgPSBudWxsLFxuICBmdXR1cmU6IFJlbWl4Um91dGVyW1wiZnV0dXJlXCJdIHwgbnVsbCA9IG51bGxcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZT8uZXJyb3JzKSB7XG4gICAgICAvLyBEb24ndCBiYWlsIGlmIHdlIGhhdmUgZGF0YSByb3V0ZXIgZXJyb3JzIHNvIHdlIGNhbiByZW5kZXIgdGhlbSBpbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5LiAgVXNlIHRoZSBwcmUtbWF0Y2hlZCAob3Igc2hpbW1lZCkgbWF0Y2hlc1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzIGFzIERhdGFSb3V0ZU1hdGNoW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuXG4gIC8vIElmIHdlIGhhdmUgZGF0YSBlcnJvcnMsIHRyaW0gbWF0Y2hlcyB0byB0aGUgaGlnaGVzdCBlcnJvciBib3VuZGFyeVxuICBsZXQgZXJyb3JzID0gZGF0YVJvdXRlclN0YXRlPy5lcnJvcnM7XG4gIGlmIChlcnJvcnMgIT0gbnVsbCkge1xuICAgIGxldCBlcnJvckluZGV4ID0gcmVuZGVyZWRNYXRjaGVzLmZpbmRJbmRleChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkICYmIGVycm9ycz8uW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWRcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIGVycm9ySW5kZXggPj0gMCxcbiAgICAgIGBDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciBlcnJvcnMgb24gcm91dGUgSURzOiAke09iamVjdC5rZXlzKFxuICAgICAgICBlcnJvcnNcbiAgICAgICkuam9pbihcIixcIil9YFxuICAgICk7XG4gICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKVxuICAgICk7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBpbiBhIHBhcnRpYWwgaHlkcmF0aW9uIG1vZGUsIGRldGVjdCBpZiB3ZSBuZWVkIHRvIHJlbmRlciBkb3duIHRvXG4gIC8vIGEgZ2l2ZW4gSHlkcmF0ZUZhbGxiYWNrIHdoaWxlIHdlIGxvYWQgdGhlIHJlc3Qgb2YgdGhlIGh5ZHJhdGlvbiBkYXRhXG4gIGxldCByZW5kZXJGYWxsYmFjayA9IGZhbHNlO1xuICBsZXQgZmFsbGJhY2tJbmRleCA9IC0xO1xuICBpZiAoZGF0YVJvdXRlclN0YXRlICYmIGZ1dHVyZSAmJiBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbWF0Y2ggPSByZW5kZXJlZE1hdGNoZXNbaV07XG4gICAgICAvLyBUcmFjayB0aGUgZGVlcGVzdCBmYWxsYmFjayB1cCB1bnRpbCB0aGUgZmlyc3Qgcm91dGUgd2l0aG91dCBkYXRhXG4gICAgICBpZiAobWF0Y2gucm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgZmFsbGJhY2tJbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzVG9SdW5Mb2FkZXIgPVxuICAgICAgICAgIG1hdGNoLnJvdXRlLmxvYWRlciAmJlxuICAgICAgICAgIGxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAoIWVycm9ycyB8fCBlcnJvcnNbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWF0Y2gucm91dGUubGF6eSB8fCBuZWVkc1RvUnVuTG9hZGVyKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGZpcnN0IHJvdXRlIHRoYXQncyBub3QgcmVhZHkgdG8gcmVuZGVyICh3YWl0aW5nIG9uXG4gICAgICAgICAgLy8gbGF6eSwgb3IgaGFzIGEgbG9hZGVyIHRoYXQgaGFzbid0IHJ1biB5ZXQpLiAgRmxhZyB0aGF0IHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyByZW5kZXIgYSBmYWxsYmFjayBhbmQgcmVuZGVyIHVwIHVudGlsIHRoZSBhcHByb3ByaWF0ZSBmYWxsYmFja1xuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgZmFsbGJhY2tJbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSBbcmVuZGVyZWRNYXRjaGVzWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIC8vIE9ubHkgZGF0YSByb3V0ZXJzIGhhbmRsZSBlcnJvcnMvZmFsbGJhY2tzXG4gICAgbGV0IGVycm9yOiBhbnk7XG4gICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xuICAgIGxldCBlcnJvckVsZW1lbnQ6IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICBlcnJvciA9IGVycm9ycyAmJiBtYXRjaC5yb3V0ZS5pZCA/IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICBlcnJvckVsZW1lbnQgPSBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgZGVmYXVsdEVycm9yRWxlbWVudDtcblxuICAgICAgaWYgKHJlbmRlckZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHdhcm5pbmdPbmNlKFxuICAgICAgICAgICAgXCJyb3V0ZS1mYWxsYmFja1wiLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIk5vIGBIeWRyYXRlRmFsbGJhY2tgIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoZXMgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4ge1xuICAgICAgbGV0IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBlcnJvckVsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjaykge1xuICAgICAgICBjaGlsZHJlbiA9IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLkNvbXBvbmVudCkge1xuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZGUtb3B0aW1pemVkIHBhdGggc2luY2UgUmVhY3Qgd29uJ3QgcmUtdXNlIHRoZVxuICAgICAgICAvLyBSZWFjdEVsZW1lbnQgc2luY2UgaXQncyBpZGVudGl0eSBjaGFuZ2VzIHdpdGggZWFjaCBuZXdcbiAgICAgICAgLy8gUmVhY3QuY3JlYXRlRWxlbWVudCBjYWxsLiAgV2Uga2VlcCB0aGlzIHNvIGZvbGtzIGNhbiB1c2VcbiAgICAgICAgLy8gYDxSb3V0ZSBDb21wb25lbnQ9ey4uLn0+YCBpbiBgPFJvdXRlcz5gIGJ1dCBnZW5lcmFsbHkgYENvbXBvbmVudGBcbiAgICAgICAgLy8gdXNhZ2UgaXMgb25seSBhZHZpc2VkIGluIGBSb3V0ZXJQcm92aWRlcmAgd2hlbiB3ZSBjYW4gY29udmVydCBpdCB0b1xuICAgICAgICAvLyBgZWxlbWVudGAgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgY2hpbGRyZW4gPSA8bWF0Y2gucm91dGUuQ29tcG9uZW50IC8+O1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gbWF0Y2gucm91dGUuZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gb3V0bGV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFJlbmRlcmVkUm91dGVcbiAgICAgICAgICBtYXRjaD17bWF0Y2h9XG4gICAgICAgICAgcm91dGVDb250ZXh0PXt7XG4gICAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgaXNEYXRhUm91dGU6IGRhdGFSb3V0ZXJTdGF0ZSAhPSBudWxsLFxuICAgICAgICAgIH19XG4gICAgICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9O1xuICAgIC8vIE9ubHkgd3JhcCBpbiBhbiBlcnJvciBib3VuZGFyeSB3aXRoaW4gZGF0YSByb3V0ZXIgdXNhZ2VzIHdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IG9uIHRoaXMgcm91dGUuICBPdGhlcndpc2UgbGV0IGl0IGJ1YmJsZSB1cCB0b1xuICAgIC8vIGFuIGFuY2VzdG9yIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJlxuICAgICAgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IChcbiAgICAgIDxSZW5kZXJFcnJvckJvdW5kYXJ5XG4gICAgICAgIGxvY2F0aW9uPXtkYXRhUm91dGVyU3RhdGUubG9jYXRpb259XG4gICAgICAgIHJldmFsaWRhdGlvbj17ZGF0YVJvdXRlclN0YXRlLnJldmFsaWRhdGlvbn1cbiAgICAgICAgY29tcG9uZW50PXtlcnJvckVsZW1lbnR9XG4gICAgICAgIGVycm9yPXtlcnJvcn1cbiAgICAgICAgY2hpbGRyZW49e2dldENoaWxkcmVuKCl9XG4gICAgICAgIHJvdXRlQ29udGV4dD17eyBvdXRsZXQ6IG51bGwsIG1hdGNoZXMsIGlzRGF0YVJvdXRlOiB0cnVlIH19XG4gICAgICAvPlxuICAgICkgOiAoXG4gICAgICBnZXRDaGlsZHJlbigpXG4gICAgKTtcbiAgfSwgbnVsbCBhcyBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsKTtcbn1cblxuZW51bSBEYXRhUm91dGVySG9vayB7XG4gIFVzZUJsb2NrZXIgPSBcInVzZUJsb2NrZXJcIixcbiAgVXNlUmV2YWxpZGF0b3IgPSBcInVzZVJldmFsaWRhdG9yXCIsXG4gIFVzZU5hdmlnYXRlU3RhYmxlID0gXCJ1c2VOYXZpZ2F0ZVwiLFxufVxuXG5lbnVtIERhdGFSb3V0ZXJTdGF0ZUhvb2sge1xuICBVc2VCbG9ja2VyID0gXCJ1c2VCbG9ja2VyXCIsXG4gIFVzZUxvYWRlckRhdGEgPSBcInVzZUxvYWRlckRhdGFcIixcbiAgVXNlQWN0aW9uRGF0YSA9IFwidXNlQWN0aW9uRGF0YVwiLFxuICBVc2VSb3V0ZUVycm9yID0gXCJ1c2VSb3V0ZUVycm9yXCIsXG4gIFVzZU5hdmlnYXRpb24gPSBcInVzZU5hdmlnYXRpb25cIixcbiAgVXNlUm91dGVMb2FkZXJEYXRhID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIixcbiAgVXNlTWF0Y2hlcyA9IFwidXNlTWF0Y2hlc1wiLFxuICBVc2VSZXZhbGlkYXRvciA9IFwidXNlUmV2YWxpZGF0b3JcIixcbiAgVXNlTmF2aWdhdGVTdGFibGUgPSBcInVzZU5hdmlnYXRlXCIsXG4gIFVzZVJvdXRlSWQgPSBcInVzZVJvdXRlSWRcIixcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihcbiAgaG9va05hbWU6IERhdGFSb3V0ZXJIb29rIHwgRGF0YVJvdXRlclN0YXRlSG9va1xuKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZTogRGF0YVJvdXRlckhvb2spIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWU6IERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vLyBJbnRlcm5hbCB2ZXJzaW9uIHdpdGggaG9va05hbWUtYXdhcmUgZGVidWdnaW5nXG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICBsZXQgdGhpc1JvdXRlID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBpbnZhcmlhbnQoXG4gICAgdGhpc1JvdXRlLnJvdXRlLmlkLFxuICAgIGAke2hvb2tOYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiYFxuICApO1xuICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgbmVhcmVzdCBjb250ZXh0dWFsIHJvdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUlkKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24sIGRlZmF1bHRpbmcgdG8gYW4gXCJpZGxlXCIgbmF2aWdhdGlvbiB3aGVuXG4gKiBubyBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcbiAgcmV0dXJuIHN0YXRlLm5hdmlnYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJldmFsaWRhdGUgZnVuY3Rpb24gZm9yIG1hbnVhbGx5IHRyaWdnZXJpbmcgcmV2YWxpZGF0aW9uLCBhcyB3ZWxsXG4gKiBhcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbnkgbWFudWFsIHJldmFsaWRhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxuICAgICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvbixcbiAgICB9KSxcbiAgICBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3RpdmUgcm91dGUgbWF0Y2hlcywgdXNlZnVsIGZvciBhY2Nlc3NpbmcgbG9hZGVyRGF0YSBmb3JcbiAqIHBhcmVudC9jaGlsZCByb3V0ZXMgb3IgdGhlIHJvdXRlIFwiaGFuZGxlXCIgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hdGNoZXMoKTogVUlNYXRjaFtdIHtcbiAgbGV0IHsgbWF0Y2hlcywgbG9hZGVyRGF0YSB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTWF0Y2hlc1xuICApO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgbG9hZGVyRGF0YSkpLFxuICAgIFttYXRjaGVzLCBsb2FkZXJEYXRhXVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlciBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBsb2FkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG5cbiAgaWYgKHN0YXRlLmVycm9ycyAmJiBzdGF0ZS5lcnJvcnNbcm91dGVJZF0gIT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgWW91IGNhbm5vdCBcXGB1c2VMb2FkZXJEYXRhXFxgIGluIGFuIGVycm9yRWxlbWVudCAocm91dGVJZDogJHtyb3V0ZUlkfSlgXG4gICAgKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlckRhdGEgZm9yIHRoZSBnaXZlbiByb3V0ZUlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZDogc3RyaW5nKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGlvbiBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKTogdW5rbm93biB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGVycm9yLCB3aGljaCBjb3VsZCBiZSBhIGxvYWRlci9hY3Rpb25cbiAqIGVycm9yIG9yIGEgcmVuZGVyIGVycm9yLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSB5b3VyXG4gKiBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudCB0byBkaXNwbGF5IGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCk6IHVua25vd24ge1xuICBsZXQgZXJyb3IgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcblxuICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAvLyBvZiBSZW5kZXJFcnJvckJvdW5kYXJ5XG4gIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGVycm9ycyBmcm9tIG91ciBkYXRhIHJvdXRlciBzdGF0ZVxuICByZXR1cm4gc3RhdGUuZXJyb3JzPy5bcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaGFwcHktcGF0aCBkYXRhIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgYDxBd2FpdCAvPmAgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKTogdW5rbm93biB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY0Vycm9yKCk6IHVua25vd24ge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2Vycm9yO1xufVxuXG5sZXQgYmxvY2tlcklkID0gMDtcblxuLyoqXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXG4gKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAqIHVzaW5nIGhhbGYtZmlsbGVkIGZvcm0gZGF0YS4gIFRoaXMgZG9lcyBub3QgaGFuZGxlIGhhcmQtcmVsb2FkcyBvclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jazogYm9vbGVhbiB8IEJsb2NrZXJGdW5jdGlvbik6IEJsb2NrZXIge1xuICBsZXQgeyByb3V0ZXIsIGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VCbG9ja2VyKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQmxvY2tlcik7XG5cbiAgbGV0IFtibG9ja2VyS2V5LCBzZXRCbG9ja2VyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpO1xuICBsZXQgYmxvY2tlckZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2s8QmxvY2tlckZ1bmN0aW9uPihcbiAgICAoYXJnKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGV5IHByb3ZpZGVkIHVzIGEgZnVuY3Rpb24gYW5kIHdlJ3ZlIGdvdCBhbiBhY3RpdmUgYmFzZW5hbWUsIHN0cmlwXG4gICAgICAvLyBpdCBmcm9tIHRoZSBsb2NhdGlvbnMgd2UgZXhwb3NlIHRvIHRoZSB1c2VyIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZlxuICAgICAgLy8gdXNlTG9jYXRpb25cbiAgICAgIGxldCB7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0gPSBhcmc7XG4gICAgICByZXR1cm4gc2hvdWxkQmxvY2soe1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHtcbiAgICAgICAgICAuLi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6XG4gICAgICAgICAgICBzdHJpcEJhc2VuYW1lKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIG5leHRMb2NhdGlvbjoge1xuICAgICAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTpcbiAgICAgICAgICAgIHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHxcbiAgICAgICAgICAgIG5leHRMb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgaGlzdG9yeUFjdGlvbixcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja11cbiAgKTtcblxuICAvLyBUaGlzIGVmZmVjdCBpcyBpbiBjaGFyZ2Ugb2YgYmxvY2tlciBrZXkgYXNzaWdubWVudCBhbmQgZGVsZXRpb24gKHdoaWNoIGlzXG4gIC8vIHRpZ2h0bHkgY291cGxlZCB0byB0aGUga2V5KVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIC8vIFRoaXMgZWZmZWN0IGhhbmRsZXMgYXNzaWduaW5nIHRoZSBibG9ja2VyRnVuY3Rpb24uICBUaGlzIGlzIHRvIGhhbmRsZVxuICAvLyB1bnN0YWJsZSBibG9ja2VyIGZ1bmN0aW9uIGlkZW50aXRpZXMsIGFuZCBoYXBwZW5zIG9ubHkgYWZ0ZXIgdGhlIHByaW9yXG4gIC8vIGVmZmVjdCBzbyB3ZSBkb24ndCBnZXQgYW4gb3JwaGFuZWQgYmxvY2tlckZ1bmN0aW9uIGluIHRoZSByb3V0ZXIgd2l0aCBhXG4gIC8vIGtleSBvZiBcIlwiLiAgVW50aWwgdGhlbiB3ZSBqdXN0IGhhdmUgdGhlIElETEVfQkxPQ0tFUi5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuXG4gIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XG4gIC8vIGlzIG1lbW9pemVkIHNvIHRoaXMgZW5zdXJlcyB3ZSB1cGRhdGUgb24gYmxvY2tlciBzdGF0ZSB1cGRhdGVzXG4gIHJldHVybiBibG9ja2VyS2V5ICYmIHN0YXRlLmJsb2NrZXJzLmhhcyhibG9ja2VyS2V5KVxuICAgID8gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpIVxuICAgIDogSURMRV9CTE9DS0VSO1xufVxuXG4vKipcbiAqIFN0YWJsZSB2ZXJzaW9uIG9mIHVzZU5hdmlnYXRlIHRoYXQgaXMgdXNlZCB3aGVuIHdlIGFyZSBpbiB0aGUgY29udGV4dCBvZlxuICogYSBSb3V0ZXJQcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGVTdGFibGUoKTogTmF2aWdhdGVGdW5jdGlvbiB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcblxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgcm91dGVyIHN1YnNjcmliZXIgeWV0XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywgeyBmcm9tUm91dGVJZDogaWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLCBpZF1cbiAgKTtcblxuICByZXR1cm4gbmF2aWdhdGU7XG59XG5cbmNvbnN0IGFscmVhZHlXYXJuZWQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleTogc3RyaW5nLCBjb25kOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIEluaXRpYWxFbnRyeSxcbiAgTGF6eVJvdXRlRnVuY3Rpb24sXG4gIExvY2F0aW9uLFxuICBNZW1vcnlIaXN0b3J5LFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZXIgYXMgUmVtaXhSb3V0ZXIsXG4gIFJvdXRlclN0YXRlLFxuICBSb3V0ZXJTdWJzY3JpYmVyLFxuICBUbyxcbiAgVHJhY2tlZFByb21pc2UsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgY3JlYXRlTWVtb3J5SGlzdG9yeSxcbiAgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMgYXMgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyxcbiAgVU5TQUZFX2ludmFyaWFudCBhcyBpbnZhcmlhbnQsXG4gIHBhcnNlUGF0aCxcbiAgcmVzb2x2ZVRvLFxuICBzdHJpcEJhc2VuYW1lLFxuICBVTlNBRkVfd2FybmluZyBhcyB3YXJuaW5nLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgQXdhaXRDb250ZXh0LFxuICBEYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0LFxufSBmcm9tIFwiLi9jb250ZXh0XCI7XG5pbXBvcnQge1xuICBfcmVuZGVyTWF0Y2hlcyxcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUm91dGVzLFxuICB1c2VSb3V0ZXNJbXBsLFxufSBmcm9tIFwiLi9ob29rc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1dHVyZUNvbmZpZyB7XG4gIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBib29sZWFuO1xuICB2N19zdGFydFRyYW5zaXRpb246IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvdmlkZXJQcm9wcyB7XG4gIGZhbGxiYWNrRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcm91dGVyOiBSZW1peFJvdXRlcjtcbiAgLy8gT25seSBhY2NlcHQgZnV0dXJlIGZsYWdzIHJlbGV2YW50IHRvIHJlbmRlcmluZyBiZWhhdmlvclxuICAvLyByb3V0aW5nIGZsYWdzIHNob3VsZCBiZSBhY2Nlc3NlZCB2aWEgcm91dGVyLmZ1dHVyZVxuICBmdXR1cmU/OiBQYXJ0aWFsPFBpY2s8RnV0dXJlQ29uZmlnLCBcInY3X3N0YXJ0VHJhbnNpdGlvblwiPj47XG59XG5cbi8qKlxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgY29tcGxhaW5zIHRoYXQgYHN0YXJ0VHJhbnNpdGlvbmAgZG9lc24ndCBleGlzdCBpbiBgUmVhY3RgOlxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xuICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuKi9cbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xuXG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcih7XG4gIGZhbGxiYWNrRWxlbWVudCxcbiAgcm91dGVyLFxuICBmdXR1cmUsXG59OiBSb3V0ZXJQcm92aWRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuXG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrPFJvdXRlclN1YnNjcmliZXI+KFxuICAgIChuZXdTdGF0ZTogUm91dGVyU3RhdGUpID0+IHtcbiAgICAgIGlmICh2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCkge1xuICAgICAgICBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl1cbiAgKTtcblxuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgLy8gcGljayB1cCBvbiBhbnkgcmVuZGVyLWRyaXZlbiByZWRpcmVjdHMvbmF2aWdhdGlvbnMgKHVzZUVmZmVjdC88TmF2aWdhdGU+KVxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsbGJhY2tFbGVtZW50ID09IG51bGwgfHwgIXJvdXRlci5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbixcbiAgICAgIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgK1xuICAgICAgICBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIlxuICAgICk7XG4gICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKTogTmF2aWdhdG9yID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IChuKSA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PlxuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PlxuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB9KSxcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG5cbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuXG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvdXRlcixcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICB9KSxcbiAgICBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXVxuICApO1xuXG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17ZGF0YVJvdXRlckNvbnRleHR9PlxuICAgICAgICA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGV9PlxuICAgICAgICAgIDxSb3V0ZXJcbiAgICAgICAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgICAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgICAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5oaXN0b3J5QWN0aW9ufVxuICAgICAgICAgICAgbmF2aWdhdG9yPXtuYXZpZ2F0b3J9XG4gICAgICAgICAgICBmdXR1cmU9e3tcbiAgICAgICAgICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IHJvdXRlci5mdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzdGF0ZS5pbml0aWFsaXplZCB8fCByb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gPyAoXG4gICAgICAgICAgICAgIDxEYXRhUm91dGVzXG4gICAgICAgICAgICAgICAgcm91dGVzPXtyb3V0ZXIucm91dGVzfVxuICAgICAgICAgICAgICAgIGZ1dHVyZT17cm91dGVyLmZ1dHVyZX1cbiAgICAgICAgICAgICAgICBzdGF0ZT17c3RhdGV9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICBmYWxsYmFja0VsZW1lbnRcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9Sb3V0ZXI+XG4gICAgICAgIDwvRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICB7bnVsbH1cbiAgICA8Lz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gRGF0YVJvdXRlcyh7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZSxcbn06IHtcbiAgcm91dGVzOiBEYXRhUm91dGVPYmplY3RbXTtcbiAgZnV0dXJlOiBSZW1peFJvdXRlcltcImZ1dHVyZVwiXTtcbiAgc3RhdGU6IFJvdXRlclN0YXRlO1xufSk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHVuZGVmaW5lZCwgc3RhdGUsIGZ1dHVyZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gIGluaXRpYWxJbmRleD86IG51bWJlcjtcbiAgZnV0dXJlPzogUGFydGlhbDxGdXR1cmVDb25maWc+O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9tZW1vcnktcm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXgsXG4gIGZ1dHVyZSxcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgICAgZnV0dXJlPXtmdXR1cmV9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZVByb3BzIHtcbiAgdG86IFRvO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcbiAqIGB1c2VOYXZpZ2F0ZWAgaG9vayBpbnN0ZWFkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9uYXZpZ2F0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTmF2aWdhdGUoe1xuICB0byxcbiAgcmVwbGFjZSxcbiAgc3RhdGUsXG4gIHJlbGF0aXZlLFxufTogTmF2aWdhdGVQcm9wcyk6IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGA8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGZ1dHVyZSwgc3RhdGljOiBpc1N0YXRpYyB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG5cbiAgd2FybmluZyhcbiAgICAhaXNTdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuXG4gIC8vIFJlc29sdmUgdGhlIHBhdGggb3V0c2lkZSBvZiB0aGUgZWZmZWN0IHNvIHRoYXQgd2hlbiBlZmZlY3RzIHJ1biB0d2ljZSBpblxuICAvLyBTdHJpY3RNb2RlIHRoZXkgbmF2aWdhdGUgdG8gdGhlIHNhbWUgcGxhY2VcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8sXG4gICAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpLFxuICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChcbiAgICAoKSA9PiBuYXZpZ2F0ZShKU09OLnBhcnNlKGpzb25QYXRoKSwgeyByZXBsYWNlLCBzdGF0ZSwgcmVsYXRpdmUgfSksXG4gICAgW25hdmlnYXRlLCBqc29uUGF0aCwgcmVsYXRpdmUsIHJlcGxhY2UsIHN0YXRlXVxuICApO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dGxldFByb3BzIHtcbiAgY29udGV4dD86IHVua25vd247XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL291dGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gT3V0bGV0KHByb3BzOiBPdXRsZXRQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IE5vbkluZGV4Um91dGVPYmplY3RbXCJjYXNlU2Vuc2l0aXZlXCJdO1xuICBwYXRoPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcInBhdGhcIl07XG4gIGlkPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImlkXCJdO1xuICBsYXp5PzogTGF6eVJvdXRlRnVuY3Rpb248Tm9uSW5kZXhSb3V0ZU9iamVjdD47XG4gIGxvYWRlcj86IE5vbkluZGV4Um91dGVPYmplY3RbXCJsb2FkZXJcIl07XG4gIGFjdGlvbj86IE5vbkluZGV4Um91dGVPYmplY3RbXCJhY3Rpb25cIl07XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFzRXJyb3JCb3VuZGFyeVwiXTtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IE5vbkluZGV4Um91dGVPYmplY3RbXCJzaG91bGRSZXZhbGlkYXRlXCJdO1xuICBoYW5kbGU/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiaGFuZGxlXCJdO1xuICBpbmRleD86IGZhbHNlO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBDb21wb25lbnQ/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbiAgSHlkcmF0ZUZhbGxiYWNrPzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIEVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXlvdXRSb3V0ZVByb3BzIGV4dGVuZHMgUGF0aFJvdXRlUHJvcHMge31cblxuZXhwb3J0IGludGVyZmFjZSBJbmRleFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogSW5kZXhSb3V0ZU9iamVjdFtcImNhc2VTZW5zaXRpdmVcIl07XG4gIHBhdGg/OiBJbmRleFJvdXRlT2JqZWN0W1wicGF0aFwiXTtcbiAgaWQ/OiBJbmRleFJvdXRlT2JqZWN0W1wiaWRcIl07XG4gIGxhenk/OiBMYXp5Um91dGVGdW5jdGlvbjxJbmRleFJvdXRlT2JqZWN0PjtcbiAgbG9hZGVyPzogSW5kZXhSb3V0ZU9iamVjdFtcImxvYWRlclwiXTtcbiAgYWN0aW9uPzogSW5kZXhSb3V0ZU9iamVjdFtcImFjdGlvblwiXTtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IEluZGV4Um91dGVPYmplY3RbXCJoYXNFcnJvckJvdW5kYXJ5XCJdO1xuICBzaG91bGRSZXZhbGlkYXRlPzogSW5kZXhSb3V0ZU9iamVjdFtcInNob3VsZFJldmFsaWRhdGVcIl07XG4gIGhhbmRsZT86IEluZGV4Um91dGVPYmplY3RbXCJoYW5kbGVcIl07XG4gIGluZGV4OiB0cnVlO1xuICBjaGlsZHJlbj86IHVuZGVmaW5lZDtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBDb21wb25lbnQ/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbiAgSHlkcmF0ZUZhbGxiYWNrPzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIEVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgUm91dGVQcm9wcyA9IFBhdGhSb3V0ZVByb3BzIHwgTGF5b3V0Um91dGVQcm9wcyB8IEluZGV4Um91dGVQcm9wcztcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlKF9wcm9wczogUm91dGVQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgYCArXG4gICAgICBgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb246IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xuICBuYXZpZ2F0aW9uVHlwZT86IE5hdmlnYXRpb25UeXBlO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljPzogYm9vbGVhbjtcbiAgZnV0dXJlPzogUGFydGlhbDxQaWNrPEZ1dHVyZUNvbmZpZywgXCJ2N19yZWxhdGl2ZVNwbGF0UGF0aFwiPj47XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAqXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSBgPFJvdXRlcj5gIGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgYDxCcm93c2VyUm91dGVyPmBcbiAqIGluIHdlYiBicm93c2VycyBvciBhIGA8U3RhdGljUm91dGVyPmAgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9yb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcih7XG4gIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICBuYXZpZ2F0aW9uVHlwZSA9IE5hdmlnYXRpb25UeXBlLlBvcCxcbiAgbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZSxcbiAgZnV0dXJlLFxufTogUm91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5gICtcbiAgICAgIGAgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuXG4gIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxuICAvLyB0aGUgZW5mb3JjZW1lbnQgb2YgdHJhaWxpbmcgc2xhc2hlcyB0aHJvdWdob3V0IHRoZSBhcHBcbiAgbGV0IGJhc2VuYW1lID0gYmFzZW5hbWVQcm9wLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogc3RhdGljUHJvcCxcbiAgICAgIGZ1dHVyZToge1xuICAgICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2UsXG4gICAgICAgIC4uLmZ1dHVyZSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgW2Jhc2VuYW1lLCBmdXR1cmUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF1cbiAgKTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG5cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiLFxuICB9ID0gbG9jYXRpb25Qcm9wO1xuXG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAga2V5LFxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlLFxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcblxuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBgICtcbiAgICAgIGBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYCArXG4gICAgICBgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuXG4gIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25hdmlnYXRpb25Db250ZXh0fT5cbiAgICAgIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgY2hpbGRyZW49e2NoaWxkcmVufSB2YWx1ZT17bG9jYXRpb25Db250ZXh0fSAvPlxuICAgIDwvTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVzUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb24/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiBgPFJvdXRlPmAgZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbixcbn06IFJvdXRlc1Byb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF3YWl0UmVzb2x2ZVJlbmRlckZ1bmN0aW9uIHtcbiAgKGRhdGE6IEF3YWl0ZWQ8YW55Pik6IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBd2FpdFByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB8IEF3YWl0UmVzb2x2ZVJlbmRlckZ1bmN0aW9uO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlc29sdmU6IFRyYWNrZWRQcm9taXNlIHwgYW55O1xufVxuXG4vKipcbiAqIENvbXBvbmVudCB0byB1c2UgZm9yIHJlbmRlcmluZyBsYXppbHkgbG9hZGVkIGRhdGEgZnJvbSByZXR1cm5pbmcgZGVmZXIoKVxuICogaW4gYSBsb2FkZXIgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEF3YWl0KHsgY2hpbGRyZW4sIGVycm9yRWxlbWVudCwgcmVzb2x2ZSB9OiBBd2FpdFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPEF3YWl0RXJyb3JCb3VuZGFyeSByZXNvbHZlPXtyZXNvbHZlfSBlcnJvckVsZW1lbnQ9e2Vycm9yRWxlbWVudH0+XG4gICAgICA8UmVzb2x2ZUF3YWl0PntjaGlsZHJlbn08L1Jlc29sdmVBd2FpdD5cbiAgICA8L0F3YWl0RXJyb3JCb3VuZGFyeT5cbiAgKTtcbn1cblxudHlwZSBBd2FpdEVycm9yQm91bmRhcnlQcm9wcyA9IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICByZXNvbHZlOiBUcmFja2VkUHJvbWlzZSB8IGFueTtcbn0+O1xuXG50eXBlIEF3YWl0RXJyb3JCb3VuZGFyeVN0YXRlID0ge1xuICBlcnJvcjogYW55O1xufTtcblxuZW51bSBBd2FpdFJlbmRlclN0YXR1cyB7XG4gIHBlbmRpbmcsXG4gIHN1Y2Nlc3MsXG4gIGVycm9yLFxufVxuXG5jb25zdCBuZXZlclNldHRsZWRQcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuXG5jbGFzcyBBd2FpdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIEF3YWl0RXJyb3JCb3VuZGFyeVByb3BzLFxuICBBd2FpdEVycm9yQm91bmRhcnlTdGF0ZVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBBd2FpdEVycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yOiBhbnksIGVycm9ySW5mbzogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiPEF3YWl0PiBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9ySW5mb1xuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4sIGVycm9yRWxlbWVudCwgcmVzb2x2ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGxldCBwcm9taXNlOiBUcmFja2VkUHJvbWlzZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBzdGF0dXM6IEF3YWl0UmVuZGVyU3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcblxuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgLy8gRGlkbid0IGdldCBhIHByb21pc2UgLSBwcm92aWRlIGFzIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IHJlc29sdmUgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAvLyBDYXVnaHQgYSByZW5kZXIgZXJyb3IsIHByb3ZpZGUgaXQgYXMgYSByZWplY3RlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcjtcbiAgICAgIGxldCByZW5kZXJFcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKS5jYXRjaCgoKSA9PiB7fSk7IC8vIEF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb24gd2FybmluZ3NcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiByZW5kZXJFcnJvciB9KTtcbiAgICB9IGVsc2UgaWYgKChyZXNvbHZlIGFzIFRyYWNrZWRQcm9taXNlKS5fdHJhY2tlZCkge1xuICAgICAgLy8gQWxyZWFkeSB0cmFja2VkIHByb21pc2UgLSBjaGVjayBjb250ZW50c1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICBzdGF0dXMgPVxuICAgICAgICBcIl9lcnJvclwiIGluIHByb21pc2VcbiAgICAgICAgICA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yXG4gICAgICAgICAgOiBcIl9kYXRhXCIgaW4gcHJvbWlzZVxuICAgICAgICAgID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzc1xuICAgICAgICAgIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmF3ICh1bnRyYWNrZWQpIHByb21pc2UgLSB0cmFjayBpdFxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihcbiAgICAgICAgKGRhdGE6IGFueSkgPT5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YSB9KSxcbiAgICAgICAgKGVycm9yOiBhbnkpID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmXG4gICAgICBwcm9taXNlLl9lcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yXG4gICAgKSB7XG4gICAgICAvLyBGcmVlemUgdGhlIFVJIGJ5IHRocm93aW5nIGEgbmV2ZXIgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgdGhyb3cgbmV2ZXJTZXR0bGVkUHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xuICAgICAgLy8gUmVuZGVyIHZpYSBvdXIgZXJyb3JFbGVtZW50XG4gICAgICByZXR1cm4gPEF3YWl0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHJvbWlzZX0gY2hpbGRyZW49e2Vycm9yRWxlbWVudH0gLz47XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgIHJldHVybiA8QXdhaXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwcm9taXNlfSBjaGlsZHJlbj17Y2hpbGRyZW59IC8+O1xuICAgIH1cblxuICAgIC8vIFRocm93IHRvIHRoZSBzdXNwZW5zZSBib3VuZGFyeVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW5kaXJlY3Rpb24gdG8gbGV2ZXJhZ2UgdXNlQXN5bmNWYWx1ZSBmb3IgYSByZW5kZXItcHJvcCBBUEkgb24gYDxBd2FpdD5gXG4gKi9cbmZ1bmN0aW9uIFJlc29sdmVBd2FpdCh7XG4gIGNoaWxkcmVuLFxufToge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIHwgQXdhaXRSZXNvbHZlUmVuZGVyRnVuY3Rpb247XG59KSB7XG4gIGxldCBkYXRhID0gdXNlQXN5bmNWYWx1ZSgpO1xuICBsZXQgdG9SZW5kZXIgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGRhdGEpIDogY2hpbGRyZW47XG4gIHJldHVybiA8Pnt0b1JlbmRlcn08Lz47XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2NyZWF0ZS1yb3V0ZXMtZnJvbS1jaGlsZHJlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlLFxuICBwYXJlbnRQYXRoOiBudW1iZXJbXSA9IFtdXG4pOiBSb3V0ZU9iamVjdFtdIHtcbiAgbGV0IHJvdXRlczogUm91dGVPYmplY3RbXSA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHtcbiAgICAgICAgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lXG4gICAgICB9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICAhZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgIFwiQW4gaW5kZXggcm91dGUgY2Fubm90IGhhdmUgY2hpbGQgcm91dGVzLlwiXG4gICAgKTtcblxuICAgIGxldCByb3V0ZTogUm91dGVPYmplY3QgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6XG4gICAgICAgIGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8XG4gICAgICAgIGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5LFxuICAgIH07XG5cbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRyZWVQYXRoXG4gICAgICApO1xuICAgIH1cblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbFxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBBY3Rpb25GdW5jdGlvbixcbiAgQWN0aW9uRnVuY3Rpb25BcmdzLFxuICBCbG9ja2VyLFxuICBCbG9ja2VyRnVuY3Rpb24sXG4gIHVuc3RhYmxlX0RhdGFTdHJhdGVneUZ1bmN0aW9uLFxuICB1bnN0YWJsZV9EYXRhU3RyYXRlZ3lGdW5jdGlvbkFyZ3MsXG4gIHVuc3RhYmxlX0RhdGFTdHJhdGVneU1hdGNoLFxuICBFcnJvclJlc3BvbnNlLFxuICBGZXRjaGVyLFxuICBIeWRyYXRpb25TdGF0ZSxcbiAgSW5pdGlhbEVudHJ5LFxuICBKc29uRnVuY3Rpb24sXG4gIExhenlSb3V0ZUZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTmF2aWdhdGlvbixcbiAgUGFyYW1QYXJzZUtleSxcbiAgUGFyYW1zLFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhQYXJhbSxcbiAgUGF0aFBhdHRlcm4sXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlciBhcyBSZW1peFJvdXRlcixcbiAgRnV0dXJlQ29uZmlnIGFzIFJvdXRlckZ1dHVyZUNvbmZpZyxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzLFxuICBUbyxcbiAgVUlNYXRjaCxcbiAgdW5zdGFibGVfSGFuZGxlclJlc3VsdCxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBjcmVhdGVNZW1vcnlIaXN0b3J5LFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGRlZmVyLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50LFxuICByZXNvbHZlUGF0aCxcbiAgVU5TQUZFX3dhcm5pbmcgYXMgd2FybmluZyxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgQXdhaXRQcm9wcyxcbiAgRnV0dXJlQ29uZmlnLFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIExheW91dFJvdXRlUHJvcHMsXG4gIE1lbW9yeVJvdXRlclByb3BzLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBPdXRsZXRQcm9wcyxcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBSb3V0ZXJQcm92aWRlclByb3BzLFxuICBSb3V0ZXNQcm9wcyxcbn0gZnJvbSBcIi4vbGliL2NvbXBvbmVudHNcIjtcbmltcG9ydCB7XG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgcmVuZGVyTWF0Y2hlcyxcbn0gZnJvbSBcIi4vbGliL2NvbXBvbmVudHNcIjtcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0b3IsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxufSBmcm9tIFwiLi9saWIvY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCxcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCxcbn0gZnJvbSBcIi4vbGliL2NvbnRleHRcIjtcbmltcG9ydCB0eXBlIHsgTmF2aWdhdGVGdW5jdGlvbiB9IGZyb20gXCIuL2xpYi9ob29rc1wiO1xuaW1wb3J0IHtcbiAgdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlQmxvY2tlcixcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUmV2YWxpZGF0b3IsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZVJvdXRlSWQsXG4gIHVzZVJvdXRlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVzLFxuICB1c2VSb3V0ZXNJbXBsLFxufSBmcm9tIFwiLi9saWIvaG9va3NcIjtcblxuLy8gRXhwb3J0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBidXQgbm90IGJlaW5nIHVzZWQgaW50ZXJuYWxseSBhbnltb3JlXG50eXBlIEhhc2ggPSBzdHJpbmc7XG50eXBlIFBhdGhuYW1lID0gc3RyaW5nO1xudHlwZSBTZWFyY2ggPSBzdHJpbmc7XG5cbi8vIEV4cG9zZSByZWFjdC1yb3V0ZXIgcHVibGljIEFQSVxuZXhwb3J0IHR5cGUge1xuICBBY3Rpb25GdW5jdGlvbixcbiAgQWN0aW9uRnVuY3Rpb25BcmdzLFxuICBBd2FpdFByb3BzLFxuICBEYXRhUm91dGVNYXRjaCxcbiAgRGF0YVJvdXRlT2JqZWN0LFxuICB1bnN0YWJsZV9EYXRhU3RyYXRlZ3lGdW5jdGlvbixcbiAgdW5zdGFibGVfRGF0YVN0cmF0ZWd5RnVuY3Rpb25BcmdzLFxuICB1bnN0YWJsZV9EYXRhU3RyYXRlZ3lNYXRjaCxcbiAgRXJyb3JSZXNwb25zZSxcbiAgRmV0Y2hlcixcbiAgRnV0dXJlQ29uZmlnLFxuICBIYXNoLFxuICBJbmRleFJvdXRlT2JqZWN0LFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIEpzb25GdW5jdGlvbixcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgTGF6eVJvdXRlRnVuY3Rpb24sXG4gIExvYWRlckZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbkFyZ3MsXG4gIExvY2F0aW9uLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0aW9uLFxuICBOYXZpZ2F0b3IsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXJhbXMsXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aFBhcmFtLFxuICBQYXRoUGF0dGVybixcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFBhdGhuYW1lLFxuICBSZWRpcmVjdEZ1bmN0aW9uLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUm91dGVQcm9wcyxcbiAgUm91dGVyUHJvcHMsXG4gIFJvdXRlclByb3ZpZGVyUHJvcHMsXG4gIFJvdXRlc1Byb3BzLFxuICBTZWFyY2gsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyxcbiAgVG8sXG4gIFVJTWF0Y2gsXG4gIEJsb2NrZXIsXG4gIEJsb2NrZXJGdW5jdGlvbixcbiAgdW5zdGFibGVfSGFuZGxlclJlc3VsdCxcbn07XG5leHBvcnQge1xuICBBYm9ydGVkRGVmZXJyZWRFcnJvcixcbiAgQXdhaXQsXG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIGFzIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgZGVmZXIsXG4gIGdlbmVyYXRlUGF0aCxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpzb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlZGlyZWN0RG9jdW1lbnQsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VCbG9ja2VyLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG59O1xuXG5mdW5jdGlvbiBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGU6IFJvdXRlT2JqZWN0KSB7XG4gIGxldCB1cGRhdGVzOiBQYXJ0aWFsPFJvdXRlT2JqZWN0PiAmIHsgaGFzRXJyb3JCb3VuZGFyeTogYm9vbGVhbiB9ID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gIH07XG5cbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICtcbiAgICAgICAgICAgIFwiYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEh5ZHJhdGVGYWxsYmFja2AgYW5kIGBoeWRyYXRlRmFsbGJhY2tFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgK1xuICAgICAgICAgICAgXCJgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgRXJyb3JCb3VuZGFyeWAgYW5kIGBlcnJvckVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArXG4gICAgICAgICAgICBcImBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlcnJvckVsZW1lbnQ6IFJlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzoge1xuICAgIGJhc2VuYW1lPzogc3RyaW5nO1xuICAgIGZ1dHVyZT86IFBhcnRpYWw8T21pdDxSb3V0ZXJGdXR1cmVDb25maWcsIFwidjdfcHJlcGVuZEJhc2VuYW1lXCI+PjtcbiAgICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG4gICAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5PzogdW5zdGFibGVfRGF0YVN0cmF0ZWd5RnVuY3Rpb247XG4gIH1cbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllczogb3B0cz8uaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXg6IG9wdHM/LmluaXRpYWxJbmRleCxcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5OiBvcHRzPy51bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIERhdGFSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIG1hcFJvdXRlUHJvcGVydGllcyBhcyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICB1c2VSb3V0ZUlkIGFzIFVOU0FGRV91c2VSb3V0ZUlkLFxuICB1c2VSb3V0ZXNJbXBsIGFzIFVOU0FGRV91c2VSb3V0ZXNJbXBsLFxufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnQkE7RUFDQTtFQStETyxNQUFNQSxpQkFBaUIsZ0JBQzVCQyxnQkFBSyxDQUFDQyxhQUFhLENBQWlDLElBQUk7RUFDN0M7SUFDWEYs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