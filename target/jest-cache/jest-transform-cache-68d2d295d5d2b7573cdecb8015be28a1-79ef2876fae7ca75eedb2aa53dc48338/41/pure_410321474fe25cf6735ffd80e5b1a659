1d0f47be9e652820708a28ee279a1e41
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  render: true,
  renderHook: true,
  cleanup: true,
  act: true,
  fireEvent: true,
  getConfig: true,
  configure: true
};
Object.defineProperty(exports, "act", {
  enumerable: true,
  get: function () {
    return _actCompat.default;
  }
});
exports.cleanup = cleanup;
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function () {
    return _config.configure;
  }
});
Object.defineProperty(exports, "fireEvent", {
  enumerable: true,
  get: function () {
    return _fireEvent.fireEvent;
  }
});
Object.defineProperty(exports, "getConfig", {
  enumerable: true,
  get: function () {
    return _config.getConfig;
  }
});
exports.render = render;
exports.renderHook = renderHook;
var React = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var ReactDOMClient = _interopRequireWildcard(require("react-dom/client"));
var _dom = require("@testing-library/dom");
Object.keys(_dom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _dom[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dom[key];
    }
  });
});
var _actCompat = _interopRequireWildcard(require("./act-compat"));
var _fireEvent = require("./fire-event");
var _config = require("./config");
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function jestFakeTimersAreEnabled() {
  /* istanbul ignore else */
  if (typeof jest !== 'undefined' && jest !== null) {
    return (
      // legacy timers
      setTimeout._isMockFunction === true ||
      // modern timers
      // eslint-disable-next-line prefer-object-has-own -- No Object.hasOwn in all target environments we support.
      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    );
  } // istanbul ignore next

  return false;
}
(0, _dom.configure)({
  unstable_advanceTimersWrapper: cb => {
    return (0, _actCompat.default)(cb);
  },
  // We just want to run `waitFor` without IS_REACT_ACT_ENVIRONMENT
  // But that's not necessarily how `asyncWrapper` is used since it's a public method.
  // Let's just hope nobody else is using it.
  asyncWrapper: async cb => {
    const previousActEnvironment = (0, _actCompat.getIsReactActEnvironment)();
    (0, _actCompat.setReactActEnvironment)(false);
    try {
      const result = await cb();
      // Drain microtask queue.
      // Otherwise we'll restore the previous act() environment, before we resolve the `waitFor` call.
      // The caller would have no chance to wrap the in-flight Promises in `act()`
      await new Promise(resolve => {
        setTimeout(() => {
          resolve();
        }, 0);
        if (jestFakeTimersAreEnabled()) {
          jest.advanceTimersByTime(0);
        }
      });
      return result;
    } finally {
      (0, _actCompat.setReactActEnvironment)(previousActEnvironment);
    }
  },
  eventWrapper: cb => {
    let result;
    (0, _actCompat.default)(() => {
      result = cb();
    });
    return result;
  }
});

// Ideally we'd just use a WeakMap where containers are keys and roots are values.
// We use two variables so that we can bail out in constant time when we render with a new container (most common use case)
/**
 * @type {Set<import('react-dom').Container>}
 */
const mountedContainers = new Set();
/**
 * @type Array<{container: import('react-dom').Container, root: ReturnType<typeof createConcurrentRoot>}>
 */
const mountedRootEntries = [];
function strictModeIfNeeded(innerElement) {
  return (0, _config.getConfig)().reactStrictMode ? /*#__PURE__*/React.createElement(React.StrictMode, null, innerElement) : innerElement;
}
function wrapUiIfNeeded(innerElement, wrapperComponent) {
  return wrapperComponent ? /*#__PURE__*/React.createElement(wrapperComponent, null, innerElement) : innerElement;
}
function createConcurrentRoot(container, {
  hydrate,
  ui,
  wrapper: WrapperComponent
}) {
  let root;
  if (hydrate) {
    (0, _actCompat.default)(() => {
      root = ReactDOMClient.hydrateRoot(container, strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent)));
    });
  } else {
    root = ReactDOMClient.createRoot(container);
  }
  return {
    hydrate() {
      /* istanbul ignore if */
      if (!hydrate) {
        throw new Error('Attempted to hydrate a non-hydrateable root. This is a bug in `@testing-library/react`.');
      }
      // Nothing to do since hydration happens when creating the root object.
    },
    render(element) {
      root.render(element);
    },
    unmount() {
      root.unmount();
    }
  };
}
function createLegacyRoot(container) {
  return {
    hydrate(element) {
      _reactDom.default.hydrate(element, container);
    },
    render(element) {
      _reactDom.default.render(element, container);
    },
    unmount() {
      _reactDom.default.unmountComponentAtNode(container);
    }
  };
}
function renderRoot(ui, {
  baseElement,
  container,
  hydrate,
  queries,
  root,
  wrapper: WrapperComponent
}) {
  (0, _actCompat.default)(() => {
    if (hydrate) {
      root.hydrate(strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent)), container);
    } else {
      root.render(strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent)), container);
    }
  });
  return {
    container,
    baseElement,
    debug: (el = baseElement, maxLength, options) => Array.isArray(el) ?
    // eslint-disable-next-line no-console
    el.forEach(e => console.log((0, _dom.prettyDOM)(e, maxLength, options))) :
    // eslint-disable-next-line no-console,
    console.log((0, _dom.prettyDOM)(el, maxLength, options)),
    unmount: () => {
      (0, _actCompat.default)(() => {
        root.unmount();
      });
    },
    rerender: rerenderUi => {
      renderRoot(rerenderUi, {
        container,
        baseElement,
        root,
        wrapper: WrapperComponent
      });
      // Intentionally do not return anything to avoid unnecessarily complicating the API.
      // folks can use all the same utilities we return in the first place that are bound to the container
    },
    asFragment: () => {
      /* istanbul ignore else (old jsdom limitation) */
      if (typeof document.createRange === 'function') {
        return document.createRange().createContextualFragment(container.innerHTML);
      } else {
        const template = document.createElement('template');
        template.innerHTML = container.innerHTML;
        return template.content;
      }
    },
    ...(0, _dom.getQueriesForElement)(baseElement, queries)
  };
}
function render(ui, {
  container,
  baseElement = container,
  legacyRoot = false,
  queries,
  hydrate = false,
  wrapper
} = {}) {
  if (legacyRoot && typeof _reactDom.default.render !== 'function') {
    const error = new Error('`legacyRoot: true` is not supported in this version of React. ' + 'If your app runs React 19 or later, you should remove this flag. ' + 'If your app runs React 18 or earlier, visit https://react.dev/blog/2022/03/08/react-18-upgrade-guide for upgrade instructions.');
    Error.captureStackTrace(error, render);
    throw error;
  }
  if (!baseElement) {
    // default to document.body instead of documentElement to avoid output of potentially-large
    // head elements (such as JSS style blocks) in debug output
    baseElement = document.body;
  }
  if (!container) {
    container = baseElement.appendChild(document.createElement('div'));
  }
  let root;
  // eslint-disable-next-line no-negated-condition -- we want to map the evolution of this over time. The root is created first. Only later is it re-used so we don't want to read the case that happens later first.
  if (!mountedContainers.has(container)) {
    const createRootImpl = legacyRoot ? createLegacyRoot : createConcurrentRoot;
    root = createRootImpl(container, {
      hydrate,
      ui,
      wrapper
    });
    mountedRootEntries.push({
      container,
      root
    });
    // we'll add it to the mounted containers regardless of whether it's actually
    // added to document.body so the cleanup method works regardless of whether
    // they're passing us a custom container or not.
    mountedContainers.add(container);
  } else {
    mountedRootEntries.forEach(rootEntry => {
      // Else is unreachable since `mountedContainers` has the `container`.
      // Only reachable if one would accidentally add the container to `mountedContainers` but not the root to `mountedRootEntries`
      /* istanbul ignore else */
      if (rootEntry.container === container) {
        root = rootEntry.root;
      }
    });
  }
  return renderRoot(ui, {
    container,
    baseElement,
    queries,
    hydrate,
    wrapper,
    root
  });
}
function cleanup() {
  mountedRootEntries.forEach(({
    root,
    container
  }) => {
    (0, _actCompat.default)(() => {
      root.unmount();
    });
    if (container.parentNode === document.body) {
      document.body.removeChild(container);
    }
  });
  mountedRootEntries.length = 0;
  mountedContainers.clear();
}
function renderHook(renderCallback, options = {}) {
  const {
    initialProps,
    ...renderOptions
  } = options;
  if (renderOptions.legacyRoot && typeof _reactDom.default.render !== 'function') {
    const error = new Error('`legacyRoot: true` is not supported in this version of React. ' + 'If your app runs React 19 or later, you should remove this flag. ' + 'If your app runs React 18 or earlier, visit https://react.dev/blog/2022/03/08/react-18-upgrade-guide for upgrade instructions.');
    Error.captureStackTrace(error, renderHook);
    throw error;
  }
  const result = /*#__PURE__*/React.createRef();
  function TestComponent({
    renderCallbackProps
  }) {
    const pendingResult = renderCallback(renderCallbackProps);
    React.useEffect(() => {
      result.current = pendingResult;
    });
    return null;
  }
  const {
    rerender: baseRerender,
    unmount
  } = render( /*#__PURE__*/React.createElement(TestComponent, {
    renderCallbackProps: initialProps
  }), renderOptions);
  function rerender(rerenderCallbackProps) {
    return baseRerender( /*#__PURE__*/React.createElement(TestComponent, {
      renderCallbackProps: rerenderCallbackProps
    }));
  }
  return {
    result,
    rerender,
    unmount
  };
}

// just re-export everything from dom-testing-library

/* eslint func-name-matching:0 */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2V4cG9ydE5hbWVzIiwicmVuZGVyIiwicmVuZGVySG9vayIsImNsZWFudXAiLCJhY3QiLCJmaXJlRXZlbnQiLCJnZXRDb25maWciLCJjb25maWd1cmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FjdENvbXBhdCIsImRlZmF1bHQiLCJfY29uZmlnIiwiX2ZpcmVFdmVudCIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfcmVhY3REb20iLCJSZWFjdERPTUNsaWVudCIsIl9kb20iLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiaGFzIiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaSIsInNldCIsImplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCIsImplc3QiLCJzZXRUaW1lb3V0IiwiX2lzTW9ja0Z1bmN0aW9uIiwidW5zdGFibGVfYWR2YW5jZVRpbWVyc1dyYXBwZXIiLCJjYiIsImFzeW5jV3JhcHBlciIsInByZXZpb3VzQWN0RW52aXJvbm1lbnQiLCJnZXRJc1JlYWN0QWN0RW52aXJvbm1lbnQiLCJzZXRSZWFjdEFjdEVudmlyb25tZW50IiwicmVzdWx0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwiZXZlbnRXcmFwcGVyIiwibW91bnRlZENvbnRhaW5lcnMiLCJTZXQiLCJtb3VudGVkUm9vdEVudHJpZXMiLCJzdHJpY3RNb2RlSWZOZWVkZWQiLCJpbm5lckVsZW1lbnQiLCJyZWFjdFN0cmljdE1vZGUiLCJjcmVhdGVFbGVtZW50IiwiU3RyaWN0TW9kZSIsIndyYXBVaUlmTmVlZGVkIiwid3JhcHBlckNvbXBvbmVudCIsImNyZWF0ZUNvbmN1cnJlbnRSb290IiwiY29udGFpbmVyIiwiaHlkcmF0ZSIsInVpIiwid3JhcHBlciIsIldyYXBwZXJDb21wb25lbnQiLCJyb290IiwiaHlkcmF0ZVJvb3QiLCJjcmVhdGVSb290IiwiRXJyb3IiLCJlbGVtZW50IiwidW5tb3VudCIsImNyZWF0ZUxlZ2FjeVJvb3QiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwicmVuZGVyUm9vdCIsImJhc2VFbGVtZW50IiwicXVlcmllcyIsImRlYnVnIiwiZWwiLCJtYXhMZW5ndGgiLCJvcHRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uc29sZSIsImxvZyIsInByZXR0eURPTSIsInJlcmVuZGVyIiwicmVyZW5kZXJVaSIsImFzRnJhZ21lbnQiLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiaW5uZXJIVE1MIiwidGVtcGxhdGUiLCJjb250ZW50IiwiZ2V0UXVlcmllc0ZvckVsZW1lbnQiLCJsZWdhY3lSb290IiwiZXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVJvb3RJbXBsIiwicHVzaCIsImFkZCIsInJvb3RFbnRyeSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImxlbmd0aCIsImNsZWFyIiwicmVuZGVyQ2FsbGJhY2siLCJpbml0aWFsUHJvcHMiLCJyZW5kZXJPcHRpb25zIiwiY3JlYXRlUmVmIiwiVGVzdENvbXBvbmVudCIsInJlbmRlckNhbGxiYWNrUHJvcHMiLCJwZW5kaW5nUmVzdWx0IiwidXNlRWZmZWN0IiwiY3VycmVudCIsImJhc2VSZXJlbmRlciIsInJlcmVuZGVyQ2FsbGJhY2tQcm9wcyJdLCJzb3VyY2VzIjpbInB1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHJlbmRlcjogdHJ1ZSxcbiAgcmVuZGVySG9vazogdHJ1ZSxcbiAgY2xlYW51cDogdHJ1ZSxcbiAgYWN0OiB0cnVlLFxuICBmaXJlRXZlbnQ6IHRydWUsXG4gIGdldENvbmZpZzogdHJ1ZSxcbiAgY29uZmlndXJlOiB0cnVlXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hY3RDb21wYXQuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLmNsZWFudXAgPSBjbGVhbnVwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jb25maWcuY29uZmlndXJlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpcmVFdmVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZmlyZUV2ZW50LmZpcmVFdmVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDb25maWdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NvbmZpZy5nZXRDb25maWc7XG4gIH1cbn0pO1xuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLnJlbmRlckhvb2sgPSByZW5kZXJIb29rO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIFJlYWN0RE9NQ2xpZW50ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0LWRvbS9jbGllbnRcIikpO1xudmFyIF9kb20gPSByZXF1aXJlKFwiQHRlc3RpbmctbGlicmFyeS9kb21cIik7XG5PYmplY3Qua2V5cyhfZG9tKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZG9tW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2RvbVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfYWN0Q29tcGF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vYWN0LWNvbXBhdFwiKSk7XG52YXIgX2ZpcmVFdmVudCA9IHJlcXVpcmUoXCIuL2ZpcmUtZXZlbnRcIik7XG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBkZWZhdWx0OiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG4uZGVmYXVsdCA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIGplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBqZXN0ICE9PSAndW5kZWZpbmVkJyAmJiBqZXN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGxlZ2FjeSB0aW1lcnNcbiAgICAgIHNldFRpbWVvdXQuX2lzTW9ja0Z1bmN0aW9uID09PSB0cnVlIHx8XG4gICAgICAvLyBtb2Rlcm4gdGltZXJzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLW9iamVjdC1oYXMtb3duIC0tIE5vIE9iamVjdC5oYXNPd24gaW4gYWxsIHRhcmdldCBlbnZpcm9ubWVudHMgd2Ugc3VwcG9ydC5cbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXRUaW1lb3V0LCAnY2xvY2snKVxuICAgICk7XG4gIH0gLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuICByZXR1cm4gZmFsc2U7XG59XG4oMCwgX2RvbS5jb25maWd1cmUpKHtcbiAgdW5zdGFibGVfYWR2YW5jZVRpbWVyc1dyYXBwZXI6IGNiID0+IHtcbiAgICByZXR1cm4gKDAsIF9hY3RDb21wYXQuZGVmYXVsdCkoY2IpO1xuICB9LFxuICAvLyBXZSBqdXN0IHdhbnQgdG8gcnVuIGB3YWl0Rm9yYCB3aXRob3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVFxuICAvLyBCdXQgdGhhdCdzIG5vdCBuZWNlc3NhcmlseSBob3cgYGFzeW5jV3JhcHBlcmAgaXMgdXNlZCBzaW5jZSBpdCdzIGEgcHVibGljIG1ldGhvZC5cbiAgLy8gTGV0J3MganVzdCBob3BlIG5vYm9keSBlbHNlIGlzIHVzaW5nIGl0LlxuICBhc3luY1dyYXBwZXI6IGFzeW5jIGNiID0+IHtcbiAgICBjb25zdCBwcmV2aW91c0FjdEVudmlyb25tZW50ID0gKDAsIF9hY3RDb21wYXQuZ2V0SXNSZWFjdEFjdEVudmlyb25tZW50KSgpO1xuICAgICgwLCBfYWN0Q29tcGF0LnNldFJlYWN0QWN0RW52aXJvbm1lbnQpKGZhbHNlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2IoKTtcbiAgICAgIC8vIERyYWluIG1pY3JvdGFzayBxdWV1ZS5cbiAgICAgIC8vIE90aGVyd2lzZSB3ZSdsbCByZXN0b3JlIHRoZSBwcmV2aW91cyBhY3QoKSBlbnZpcm9ubWVudCwgYmVmb3JlIHdlIHJlc29sdmUgdGhlIGB3YWl0Rm9yYCBjYWxsLlxuICAgICAgLy8gVGhlIGNhbGxlciB3b3VsZCBoYXZlIG5vIGNoYW5jZSB0byB3cmFwIHRoZSBpbi1mbGlnaHQgUHJvbWlzZXMgaW4gYGFjdCgpYFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmIChqZXN0RmFrZVRpbWVyc0FyZUVuYWJsZWQoKSkge1xuICAgICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAoMCwgX2FjdENvbXBhdC5zZXRSZWFjdEFjdEVudmlyb25tZW50KShwcmV2aW91c0FjdEVudmlyb25tZW50KTtcbiAgICB9XG4gIH0sXG4gIGV2ZW50V3JhcHBlcjogY2IgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgKDAsIF9hY3RDb21wYXQuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgcmVzdWx0ID0gY2IoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuLy8gSWRlYWxseSB3ZSdkIGp1c3QgdXNlIGEgV2Vha01hcCB3aGVyZSBjb250YWluZXJzIGFyZSBrZXlzIGFuZCByb290cyBhcmUgdmFsdWVzLlxuLy8gV2UgdXNlIHR3byB2YXJpYWJsZXMgc28gdGhhdCB3ZSBjYW4gYmFpbCBvdXQgaW4gY29uc3RhbnQgdGltZSB3aGVuIHdlIHJlbmRlciB3aXRoIGEgbmV3IGNvbnRhaW5lciAobW9zdCBjb21tb24gdXNlIGNhc2UpXG4vKipcbiAqIEB0eXBlIHtTZXQ8aW1wb3J0KCdyZWFjdC1kb20nKS5Db250YWluZXI+fVxuICovXG5jb25zdCBtb3VudGVkQ29udGFpbmVycyA9IG5ldyBTZXQoKTtcbi8qKlxuICogQHR5cGUgQXJyYXk8e2NvbnRhaW5lcjogaW1wb3J0KCdyZWFjdC1kb20nKS5Db250YWluZXIsIHJvb3Q6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUNvbmN1cnJlbnRSb290Pn0+XG4gKi9cbmNvbnN0IG1vdW50ZWRSb290RW50cmllcyA9IFtdO1xuZnVuY3Rpb24gc3RyaWN0TW9kZUlmTmVlZGVkKGlubmVyRWxlbWVudCkge1xuICByZXR1cm4gKDAsIF9jb25maWcuZ2V0Q29uZmlnKSgpLnJlYWN0U3RyaWN0TW9kZSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN0cmljdE1vZGUsIG51bGwsIGlubmVyRWxlbWVudCkgOiBpbm5lckVsZW1lbnQ7XG59XG5mdW5jdGlvbiB3cmFwVWlJZk5lZWRlZChpbm5lckVsZW1lbnQsIHdyYXBwZXJDb21wb25lbnQpIHtcbiAgcmV0dXJuIHdyYXBwZXJDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudCh3cmFwcGVyQ29tcG9uZW50LCBudWxsLCBpbm5lckVsZW1lbnQpIDogaW5uZXJFbGVtZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29uY3VycmVudFJvb3QoY29udGFpbmVyLCB7XG4gIGh5ZHJhdGUsXG4gIHVpLFxuICB3cmFwcGVyOiBXcmFwcGVyQ29tcG9uZW50XG59KSB7XG4gIGxldCByb290O1xuICBpZiAoaHlkcmF0ZSkge1xuICAgICgwLCBfYWN0Q29tcGF0LmRlZmF1bHQpKCgpID0+IHtcbiAgICAgIHJvb3QgPSBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChjb250YWluZXIsIHN0cmljdE1vZGVJZk5lZWRlZCh3cmFwVWlJZk5lZWRlZCh1aSwgV3JhcHBlckNvbXBvbmVudCkpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdChjb250YWluZXIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaHlkcmF0ZSgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoeWRyYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGh5ZHJhdGUgYSBub24taHlkcmF0ZWFibGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBgQHRlc3RpbmctbGlicmFyeS9yZWFjdGAuJyk7XG4gICAgICB9XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIHNpbmNlIGh5ZHJhdGlvbiBoYXBwZW5zIHdoZW4gY3JlYXRpbmcgdGhlIHJvb3Qgb2JqZWN0LlxuICAgIH0sXG4gICAgcmVuZGVyKGVsZW1lbnQpIHtcbiAgICAgIHJvb3QucmVuZGVyKGVsZW1lbnQpO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHJvb3QudW5tb3VudCgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyKSB7XG4gIHJldHVybiB7XG4gICAgaHlkcmF0ZShlbGVtZW50KSB7XG4gICAgICBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lcik7XG4gICAgfSxcbiAgICByZW5kZXIoZWxlbWVudCkge1xuICAgICAgX3JlYWN0RG9tLmRlZmF1bHQucmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lcik7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgX3JlYWN0RG9tLmRlZmF1bHQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJvb3QodWksIHtcbiAgYmFzZUVsZW1lbnQsXG4gIGNvbnRhaW5lcixcbiAgaHlkcmF0ZSxcbiAgcXVlcmllcyxcbiAgcm9vdCxcbiAgd3JhcHBlcjogV3JhcHBlckNvbXBvbmVudFxufSkge1xuICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgaWYgKGh5ZHJhdGUpIHtcbiAgICAgIHJvb3QuaHlkcmF0ZShzdHJpY3RNb2RlSWZOZWVkZWQod3JhcFVpSWZOZWVkZWQodWksIFdyYXBwZXJDb21wb25lbnQpKSwgY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5yZW5kZXIoc3RyaWN0TW9kZUlmTmVlZGVkKHdyYXBVaUlmTmVlZGVkKHVpLCBXcmFwcGVyQ29tcG9uZW50KSksIGNvbnRhaW5lcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjb250YWluZXIsXG4gICAgYmFzZUVsZW1lbnQsXG4gICAgZGVidWc6IChlbCA9IGJhc2VFbGVtZW50LCBtYXhMZW5ndGgsIG9wdGlvbnMpID0+IEFycmF5LmlzQXJyYXkoZWwpID9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGVsLmZvckVhY2goZSA9PiBjb25zb2xlLmxvZygoMCwgX2RvbS5wcmV0dHlET00pKGUsIG1heExlbmd0aCwgb3B0aW9ucykpKSA6XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGUsXG4gICAgY29uc29sZS5sb2coKDAsIF9kb20ucHJldHR5RE9NKShlbCwgbWF4TGVuZ3RoLCBvcHRpb25zKSksXG4gICAgdW5tb3VudDogKCkgPT4ge1xuICAgICAgKDAsIF9hY3RDb21wYXQuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgICByb290LnVubW91bnQoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVyZW5kZXI6IHJlcmVuZGVyVWkgPT4ge1xuICAgICAgcmVuZGVyUm9vdChyZXJlbmRlclVpLCB7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYmFzZUVsZW1lbnQsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHdyYXBwZXI6IFdyYXBwZXJDb21wb25lbnRcbiAgICAgIH0pO1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBkbyBub3QgcmV0dXJuIGFueXRoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgY29tcGxpY2F0aW5nIHRoZSBBUEkuXG4gICAgICAvLyBmb2xrcyBjYW4gdXNlIGFsbCB0aGUgc2FtZSB1dGlsaXRpZXMgd2UgcmV0dXJuIGluIHRoZSBmaXJzdCBwbGFjZSB0aGF0IGFyZSBib3VuZCB0byB0aGUgY29udGFpbmVyXG4gICAgfSxcbiAgICBhc0ZyYWdtZW50OiAoKSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAob2xkIGpzZG9tIGxpbWl0YXRpb24pICovXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmNyZWF0ZVJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChjb250YWluZXIuaW5uZXJIVE1MKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAuLi4oMCwgX2RvbS5nZXRRdWVyaWVzRm9yRWxlbWVudCkoYmFzZUVsZW1lbnQsIHF1ZXJpZXMpXG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIodWksIHtcbiAgY29udGFpbmVyLFxuICBiYXNlRWxlbWVudCA9IGNvbnRhaW5lcixcbiAgbGVnYWN5Um9vdCA9IGZhbHNlLFxuICBxdWVyaWVzLFxuICBoeWRyYXRlID0gZmFsc2UsXG4gIHdyYXBwZXJcbn0gPSB7fSkge1xuICBpZiAobGVnYWN5Um9vdCAmJiB0eXBlb2YgX3JlYWN0RG9tLmRlZmF1bHQucmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2BsZWdhY3lSb290OiB0cnVlYCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBSZWFjdC4gJyArICdJZiB5b3VyIGFwcCBydW5zIFJlYWN0IDE5IG9yIGxhdGVyLCB5b3Ugc2hvdWxkIHJlbW92ZSB0aGlzIGZsYWcuICcgKyAnSWYgeW91ciBhcHAgcnVucyBSZWFjdCAxOCBvciBlYXJsaWVyLCB2aXNpdCBodHRwczovL3JlYWN0LmRldi9ibG9nLzIwMjIvMDMvMDgvcmVhY3QtMTgtdXBncmFkZS1ndWlkZSBmb3IgdXBncmFkZSBpbnN0cnVjdGlvbnMuJyk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHJlbmRlcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYgKCFiYXNlRWxlbWVudCkge1xuICAgIC8vIGRlZmF1bHQgdG8gZG9jdW1lbnQuYm9keSBpbnN0ZWFkIG9mIGRvY3VtZW50RWxlbWVudCB0byBhdm9pZCBvdXRwdXQgb2YgcG90ZW50aWFsbHktbGFyZ2VcbiAgICAvLyBoZWFkIGVsZW1lbnRzIChzdWNoIGFzIEpTUyBzdHlsZSBibG9ja3MpIGluIGRlYnVnIG91dHB1dFxuICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lciA9IGJhc2VFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgfVxuICBsZXQgcm9vdDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uIC0tIHdlIHdhbnQgdG8gbWFwIHRoZSBldm9sdXRpb24gb2YgdGhpcyBvdmVyIHRpbWUuIFRoZSByb290IGlzIGNyZWF0ZWQgZmlyc3QuIE9ubHkgbGF0ZXIgaXMgaXQgcmUtdXNlZCBzbyB3ZSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIGNhc2UgdGhhdCBoYXBwZW5zIGxhdGVyIGZpcnN0LlxuICBpZiAoIW1vdW50ZWRDb250YWluZXJzLmhhcyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgY3JlYXRlUm9vdEltcGwgPSBsZWdhY3lSb290ID8gY3JlYXRlTGVnYWN5Um9vdCA6IGNyZWF0ZUNvbmN1cnJlbnRSb290O1xuICAgIHJvb3QgPSBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHtcbiAgICAgIGh5ZHJhdGUsXG4gICAgICB1aSxcbiAgICAgIHdyYXBwZXJcbiAgICB9KTtcbiAgICBtb3VudGVkUm9vdEVudHJpZXMucHVzaCh7XG4gICAgICBjb250YWluZXIsXG4gICAgICByb290XG4gICAgfSk7XG4gICAgLy8gd2UnbGwgYWRkIGl0IHRvIHRoZSBtb3VudGVkIGNvbnRhaW5lcnMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0J3MgYWN0dWFsbHlcbiAgICAvLyBhZGRlZCB0byBkb2N1bWVudC5ib2R5IHNvIHRoZSBjbGVhbnVwIG1ldGhvZCB3b3JrcyByZWdhcmRsZXNzIG9mIHdoZXRoZXJcbiAgICAvLyB0aGV5J3JlIHBhc3NpbmcgdXMgYSBjdXN0b20gY29udGFpbmVyIG9yIG5vdC5cbiAgICBtb3VudGVkQ29udGFpbmVycy5hZGQoY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBtb3VudGVkUm9vdEVudHJpZXMuZm9yRWFjaChyb290RW50cnkgPT4ge1xuICAgICAgLy8gRWxzZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSBgbW91bnRlZENvbnRhaW5lcnNgIGhhcyB0aGUgYGNvbnRhaW5lcmAuXG4gICAgICAvLyBPbmx5IHJlYWNoYWJsZSBpZiBvbmUgd291bGQgYWNjaWRlbnRhbGx5IGFkZCB0aGUgY29udGFpbmVyIHRvIGBtb3VudGVkQ29udGFpbmVyc2AgYnV0IG5vdCB0aGUgcm9vdCB0byBgbW91bnRlZFJvb3RFbnRyaWVzYFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChyb290RW50cnkuY29udGFpbmVyID09PSBjb250YWluZXIpIHtcbiAgICAgICAgcm9vdCA9IHJvb3RFbnRyeS5yb290O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJSb290KHVpLCB7XG4gICAgY29udGFpbmVyLFxuICAgIGJhc2VFbGVtZW50LFxuICAgIHF1ZXJpZXMsXG4gICAgaHlkcmF0ZSxcbiAgICB3cmFwcGVyLFxuICAgIHJvb3RcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhbnVwKCkge1xuICBtb3VudGVkUm9vdEVudHJpZXMuZm9yRWFjaCgoe1xuICAgIHJvb3QsXG4gICAgY29udGFpbmVyXG4gIH0pID0+IHtcbiAgICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICByb290LnVubW91bnQoKTtcbiAgICB9KTtcbiAgICBpZiAoY29udGFpbmVyLnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG4gIH0pO1xuICBtb3VudGVkUm9vdEVudHJpZXMubGVuZ3RoID0gMDtcbiAgbW91bnRlZENvbnRhaW5lcnMuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckhvb2socmVuZGVyQ2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW5pdGlhbFByb3BzLFxuICAgIC4uLnJlbmRlck9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChyZW5kZXJPcHRpb25zLmxlZ2FjeVJvb3QgJiYgdHlwZW9mIF9yZWFjdERvbS5kZWZhdWx0LnJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdgbGVnYWN5Um9vdDogdHJ1ZWAgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIHZlcnNpb24gb2YgUmVhY3QuICcgKyAnSWYgeW91ciBhcHAgcnVucyBSZWFjdCAxOSBvciBsYXRlciwgeW91IHNob3VsZCByZW1vdmUgdGhpcyBmbGFnLiAnICsgJ0lmIHlvdXIgYXBwIHJ1bnMgUmVhY3QgMTggb3IgZWFybGllciwgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvYmxvZy8yMDIyLzAzLzA4L3JlYWN0LTE4LXVwZ3JhZGUtZ3VpZGUgZm9yIHVwZ3JhZGUgaW5zdHJ1Y3Rpb25zLicpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCByZW5kZXJIb29rKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBjb25zdCByZXN1bHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gIGZ1bmN0aW9uIFRlc3RDb21wb25lbnQoe1xuICAgIHJlbmRlckNhbGxiYWNrUHJvcHNcbiAgfSkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXN1bHQgPSByZW5kZXJDYWxsYmFjayhyZW5kZXJDYWxsYmFja1Byb3BzKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgcmVzdWx0LmN1cnJlbnQgPSBwZW5kaW5nUmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtcbiAgICByZXJlbmRlcjogYmFzZVJlcmVuZGVyLFxuICAgIHVubW91bnRcbiAgfSA9IHJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGVzdENvbXBvbmVudCwge1xuICAgIHJlbmRlckNhbGxiYWNrUHJvcHM6IGluaXRpYWxQcm9wc1xuICB9KSwgcmVuZGVyT3B0aW9ucyk7XG4gIGZ1bmN0aW9uIHJlcmVuZGVyKHJlcmVuZGVyQ2FsbGJhY2tQcm9wcykge1xuICAgIHJldHVybiBiYXNlUmVyZW5kZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRlc3RDb21wb25lbnQsIHtcbiAgICAgIHJlbmRlckNhbGxiYWNrUHJvcHM6IHJlcmVuZGVyQ2FsbGJhY2tQcm9wc1xuICAgIH0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3VsdCxcbiAgICByZXJlbmRlcixcbiAgICB1bm1vdW50XG4gIH07XG59XG5cbi8vIGp1c3QgcmUtZXhwb3J0IGV2ZXJ5dGhpbmcgZnJvbSBkb20tdGVzdGluZy1saWJyYXJ5XG5cbi8qIGVzbGludCBmdW5jLW5hbWUtbWF0Y2hpbmc6MCAqLyJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWixJQUFJ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