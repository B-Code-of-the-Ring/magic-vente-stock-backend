4fee558dcd63dfd5b12b038704efd7b2
// Axios v1.7.2 Copyright (c) 2024 Matt Zabriskie and contributors
'use strict';

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {
  toString
} = Object.prototype;
const {
  getPrototypeOf
} = Object;
const kindOf = (cache => thing => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
const kindOfTest = type => {
  type = type.toLowerCase();
  return thing => kindOf(thing) === type;
};
const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {
  isArray
} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = thing => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = val => {
  if (kindOf(val) !== 'object') {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = val => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = thing => {
  let kind;
  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
  // detect form-data instance
  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');
const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {
  allOwnKeys = false
} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }
  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }
  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();
const isContextDefined = context => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge( /* obj1, obj2, obj3, ... */
) {
  const {
    caseless
  } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {
  allOwnKeys
} = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {
    allOwnKeys
  });
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = content => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};

/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = thing => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');
const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({
  hasOwnProperty
}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');
const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = obj => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = arr => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
const DIGIT = '0123456789';
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {
    length
  } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}
const toJSONObject = obj => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest('AsyncFunction');
const isThenable = thing => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {
  value: true
});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }
  function convertValue(value) {
    if (value === null) return '';
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
          // eslint-disable-next-line no-nested-ternary
          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }
  build(obj);
  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function (value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager$1 = InterceptorManager;
var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;
var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;
var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;
var platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = (product => {
  return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0;
})(typeof navigator !== 'undefined' && navigator.product);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== 'undefined' &&
  // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();
const origin = hasBrowserEnv && window.location.href || 'http://localhost';
var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv,
  origin: origin
});
var platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function (value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === '__proto__') return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData = utils$1.isFormData(data);
    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }
    let isFileList;
    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(isFileList ? {
          'files[]': data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};
utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], method => {
  defaults.headers[method] = {};
});
var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol('internals');
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }
  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);
  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }
      const key = utils$1.findKey(self, lHeader);
      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
        self[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self, _header);
        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self[header];
      }
      self[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach(target => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({
  value
}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1000 / freq;
  let timer = null;
  return function throttled() {
    const force = this === true;
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, arguments);
      }, threshold - (now - timestamp));
    }
  };
}
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null
    };
    data[isDownloadStream ? 'download' : 'upload'] = true;
    listener(data);
  }, freq);
};
var isURLSameOrigin = platform.hasStandardBrowserEnv ?
// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement('a');
  let originURL;

  /**
  * Parse a URL to discover its components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    let href = url;
    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :
// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();
var cookies = platform.hasStandardBrowserEnv ?
// Standard browser envs support document.cookie
{
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + '=' + encodeURIComponent(value)];
    utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
    utils$1.isString(path) && cookie.push('path=' + path);
    utils$1.isString(domain) && cookie.push('domain=' + domain);
    secure === true && cookie.push('secure');
    document.cookie = cookie.join('; ');
  },
  read(name) {
    const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, '', Date.now() - 86400000);
  }
} :
// Non-standard browser env (web workers, react-native) lack needed support.
{
  write() {},
  read() {
    return null;
  },
  remove() {}
};

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = thing => thing instanceof AxiosHeaders$1 ? {
  ...thing
} : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({
        caseless
      }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
var resolveConfig = config => {
  const newConfig = mergeConfig({}, config);
  let {
    data,
    withXSRFToken,
    xsrfHeaderName,
    xsrfCookieName,
    headers,
    auth
  } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {
      responseType
    } = _config;
    let onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener('abort', onCanceled);
      }
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }
    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, _config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, _config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, _config, request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (typeof _config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(_config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof _config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function (cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach(signal => {
        signal && (signal.removeEventListener ? signal.removeEventListener('abort', onabort) : signal.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach(signal => signal && signal.addEventListener && signal.addEventListener('abort', onabort));
  const {
    signal
  } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
var composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize, encode) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode(String(chunk)), chunkSize);
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {
  const iterator = readBytes(stream, chunkSize, encode);
  let bytes = 0;
  return new ReadableStream({
    type: 'bytes',
    async pull(controller) {
      const {
        done,
        value
      } = await iterator.next();
      if (done) {
        controller.close();
        onFinish();
        return;
      }
      let len = value.byteLength;
      onProgress && onProgress(bytes += len);
      controller.enqueue(new Uint8Array(value));
    },
    cancel(reason) {
      onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const fetchProgressDecorator = (total, fn) => {
  const lengthComputable = total != null;
  return loaded => setTimeout(() => fn({
    lengthComputable,
    total,
    loaded
  }));
};
const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Response(str).arrayBuffer()));
const supportsRequestStream = isReadableStreamSupported && (() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    }
  }).headers.has('Content-Type');
  return duplexAccessed && !hasContentType;
})();
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && !!(() => {
  try {
    return utils$1.isReadableStream(new Response('').body);
  } catch (err) {
    // return undefined
  }
})();
const resolvers = {
  stream: supportsResponseStream && (res => res.body)
};
isFetchSupported && (res => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? res => res[type]() : (_, config) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async body => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + '';
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetchAdapter = isFetchSupported && (async config => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + '').toLowerCase() : 'text';
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals$1([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(requestContentLength, progressEventReducer(onUploadProgress)), null, encodeText);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'cors' : 'omit';
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));
      response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(responseContentLength, progressEventReducer(onDownloadProgress, true)), isStreamResponse && onFinish, encodeText), options);
    }
    responseType = responseType || 'text';
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {
        cause: err.cause || err
      });
    }
    throw AxiosError.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {
        value
      });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {
      value
    });
  }
});
const renderReason = reason => `- ${reason}`;
const isResolvedHandle = adapter => utils$1.isFunction(adapter) || adapter === null || adapter === false;
var adapters = {
  getAdapter: adapters => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];
    const {
      length
    } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || '#' + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
      let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
      throw new AxiosError(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
    }
    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(config, config.transformRequest);
  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.2";
const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const {
      transitional,
      paramsSerializer,
      headers
    } = config;
    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(headers.common, headers[config.method]);
    headers && utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
      delete headers[method];
    });
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {
    allOwnKeys: true
  });

  // Copy context to instance
  utils$1.extend(instance, context, null, {
    allOwnKeys: true
  });

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
module.exports = axios;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiaW5kIiwiZm4iLCJ0aGlzQXJnIiwid3JhcCIsImFwcGx5IiwiYXJndW1lbnRzIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsImtpbmRPZiIsImNhY2hlIiwidGhpbmciLCJzdHIiLCJjYWxsIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsImNyZWF0ZSIsImtpbmRPZlRlc3QiLCJ0eXBlIiwidHlwZU9mVGVzdCIsImlzQXJyYXkiLCJBcnJheSIsImlzVW5kZWZpbmVkIiwiaXNCdWZmZXIiLCJ2YWwiLCJjb25zdHJ1Y3RvciIsImlzRnVuY3Rpb24iLCJpc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc09iamVjdCIsImlzQm9vbGVhbiIsImlzUGxhaW5PYmplY3QiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIml0ZXJhdG9yIiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGaWxlTGlzdCIsImlzU3RyZWFtIiwicGlwZSIsImlzRm9ybURhdGEiLCJraW5kIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJpc1VSTFNlYXJjaFBhcmFtcyIsImlzUmVhZGFibGVTdHJlYW0iLCJpc1JlcXVlc3QiLCJpc1Jlc3BvbnNlIiwiaXNIZWFkZXJzIiwibWFwIiwidHJpbSIsInJlcGxhY2UiLCJmb3JFYWNoIiwib2JqIiwiYWxsT3duS2V5cyIsImkiLCJsIiwibGVuZ3RoIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW4iLCJrZXkiLCJmaW5kS2V5IiwiX2tleSIsIl9nbG9iYWwiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImlzQ29udGV4dERlZmluZWQiLCJjb250ZXh0IiwibWVyZ2UiLCJjYXNlbGVzcyIsImFzc2lnblZhbHVlIiwidGFyZ2V0S2V5IiwiZXh0ZW5kIiwiYSIsImIiLCJzdHJpcEJPTSIsImNvbnRlbnQiLCJjaGFyQ29kZUF0IiwiaW5oZXJpdHMiLCJzdXBlckNvbnN0cnVjdG9yIiwicHJvcHMiLCJkZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJhc3NpZ24iLCJ0b0ZsYXRPYmplY3QiLCJzb3VyY2VPYmoiLCJkZXN0T2JqIiwiZmlsdGVyIiwicHJvcEZpbHRlciIsInByb3AiLCJtZXJnZWQiLCJlbmRzV2l0aCIsInNlYXJjaFN0cmluZyIsInBvc2l0aW9uIiwiU3RyaW5nIiwidW5kZWZpbmVkIiwibGFzdEluZGV4IiwiaW5kZXhPZiIsInRvQXJyYXkiLCJhcnIiLCJpc1R5cGVkQXJyYXkiLCJUeXBlZEFycmF5IiwiVWludDhBcnJheSIsImZvckVhY2hFbnRyeSIsImdlbmVyYXRvciIsIm5leHQiLCJkb25lIiwicGFpciIsIm1hdGNoQWxsIiwicmVnRXhwIiwibWF0Y2hlcyIsImV4ZWMiLCJwdXNoIiwiaXNIVE1MRm9ybSIsInRvQ2FtZWxDYXNlIiwicmVwbGFjZXIiLCJtIiwicDEiLCJwMiIsInRvVXBwZXJDYXNlIiwiaGFzT3duUHJvcGVydHkiLCJpc1JlZ0V4cCIsInJlZHVjZURlc2NyaXB0b3JzIiwicmVkdWNlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJyZWR1Y2VkRGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwibmFtZSIsInJldCIsImRlZmluZVByb3BlcnRpZXMiLCJmcmVlemVNZXRob2RzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwic2V0IiwiRXJyb3IiLCJ0b09iamVjdFNldCIsImFycmF5T3JTdHJpbmciLCJkZWxpbWl0ZXIiLCJkZWZpbmUiLCJzcGxpdCIsIm5vb3AiLCJ0b0Zpbml0ZU51bWJlciIsImRlZmF1bHRWYWx1ZSIsIk51bWJlciIsImlzRmluaXRlIiwiQUxQSEEiLCJESUdJVCIsIkFMUEhBQkVUIiwiQUxQSEFfRElHSVQiLCJnZW5lcmF0ZVN0cmluZyIsInNpemUiLCJhbHBoYWJldCIsIk1hdGgiLCJyYW5kb20iLCJpc1NwZWNDb21wbGlhbnRGb3JtIiwidG9KU09OT2JqZWN0Iiwic3RhY2siLCJ2aXNpdCIsInNvdXJjZSIsInRhcmdldCIsInJlZHVjZWRWYWx1ZSIsImlzQXN5bmNGbiIsImlzVGhlbmFibGUiLCJ0aGVuIiwiY2F0Y2giLCJ1dGlscyQxIiwiaGFzT3duUHJvcCIsIkF4aW9zRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsImNvbmZpZyIsInJlcXVlc3QiLCJyZXNwb25zZSIsImNhcHR1cmVTdGFja1RyYWNlIiwidG9KU09OIiwiZGVzY3JpcHRpb24iLCJudW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJzdGF0dXMiLCJwcm90b3R5cGUkMSIsImZyb20iLCJlcnJvciIsImN1c3RvbVByb3BzIiwiYXhpb3NFcnJvciIsImNhdXNlIiwiaHR0cEFkYXB0ZXIiLCJpc1Zpc2l0YWJsZSIsInJlbW92ZUJyYWNrZXRzIiwicmVuZGVyS2V5IiwicGF0aCIsImRvdHMiLCJjb25jYXQiLCJlYWNoIiwidG9rZW4iLCJqb2luIiwiaXNGbGF0QXJyYXkiLCJzb21lIiwicHJlZGljYXRlcyIsInRlc3QiLCJ0b0Zvcm1EYXRhIiwiZm9ybURhdGEiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwibWV0YVRva2VucyIsImluZGV4ZXMiLCJkZWZpbmVkIiwib3B0aW9uIiwidmlzaXRvciIsImRlZmF1bHRWaXNpdG9yIiwiX0Jsb2IiLCJCbG9iIiwidXNlQmxvYiIsImNvbnZlcnRWYWx1ZSIsInRvSVNPU3RyaW5nIiwiQnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImVsIiwiaW5kZXgiLCJleHBvc2VkSGVscGVycyIsImJ1aWxkIiwicG9wIiwiZW5jb2RlJDEiLCJlbmNvZGUiLCJjaGFyTWFwIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJBeGlvc1VSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsIl9wYWlycyIsImVuY29kZXIiLCJfZW5jb2RlIiwiYnVpbGRVUkwiLCJ1cmwiLCJzZXJpYWxpemVGbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZWRQYXJhbXMiLCJoYXNobWFya0luZGV4IiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiaGFuZGxlcnMiLCJ1c2UiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInN5bmNocm9ub3VzIiwicnVuV2hlbiIsImVqZWN0IiwiaWQiLCJjbGVhciIsImZvckVhY2hIYW5kbGVyIiwiaCIsIkludGVyY2VwdG9yTWFuYWdlciQxIiwidHJhbnNpdGlvbmFsRGVmYXVsdHMiLCJzaWxlbnRKU09OUGFyc2luZyIsImZvcmNlZEpTT05QYXJzaW5nIiwiY2xhcmlmeVRpbWVvdXRFcnJvciIsIlVSTFNlYXJjaFBhcmFtcyQxIiwiVVJMU2VhcmNoUGFyYW1zIiwiRm9ybURhdGEkMSIsIkJsb2IkMSIsInBsYXRmb3JtJDEiLCJpc0Jyb3dzZXIiLCJjbGFzc2VzIiwicHJvdG9jb2xzIiwiaGFzQnJvd3NlckVudiIsImRvY3VtZW50IiwiaGFzU3RhbmRhcmRCcm93c2VyRW52IiwicHJvZHVjdCIsIm5hdmlnYXRvciIsImhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudiIsIldvcmtlckdsb2JhbFNjb3BlIiwiaW1wb3J0U2NyaXB0cyIsIm9yaWdpbiIsImxvY2F0aW9uIiwiaHJlZiIsInBsYXRmb3JtIiwidXRpbHMiLCJ0b1VSTEVuY29kZWRGb3JtIiwiZGF0YSIsImhlbHBlcnMiLCJpc05vZGUiLCJwYXJzZVByb3BQYXRoIiwiYXJyYXlUb09iamVjdCIsImZvcm1EYXRhVG9KU09OIiwiYnVpbGRQYXRoIiwiaXNOdW1lcmljS2V5IiwiaXNMYXN0IiwiZW50cmllcyIsInN0cmluZ2lmeVNhZmVseSIsInJhd1ZhbHVlIiwicGFyc2VyIiwicGFyc2UiLCJlIiwiZGVmYXVsdHMiLCJ0cmFuc2l0aW9uYWwiLCJhZGFwdGVyIiwidHJhbnNmb3JtUmVxdWVzdCIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsImdldENvbnRlbnRUeXBlIiwiaGFzSlNPTkNvbnRlbnRUeXBlIiwiaXNPYmplY3RQYXlsb2FkIiwic2V0Q29udGVudFR5cGUiLCJmb3JtU2VyaWFsaXplciIsIl9Gb3JtRGF0YSIsImVudiIsInRyYW5zZm9ybVJlc3BvbnNlIiwiSlNPTlJlcXVlc3RlZCIsInJlc3BvbnNlVHlwZSIsInN0cmljdEpTT05QYXJzaW5nIiwiRVJSX0JBRF9SRVNQT05TRSIsInRpbWVvdXQiLCJ4c3JmQ29va2llTmFtZSIsInhzcmZIZWFkZXJOYW1lIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsImNvbW1vbiIsIm1ldGhvZCIsImRlZmF1bHRzJDEiLCJpZ25vcmVEdXBsaWNhdGVPZiIsInBhcnNlSGVhZGVycyIsInJhd0hlYWRlcnMiLCJwYXJzZWQiLCJsaW5lIiwic3Vic3RyaW5nIiwiJGludGVybmFscyIsIm5vcm1hbGl6ZUhlYWRlciIsImhlYWRlciIsIm5vcm1hbGl6ZVZhbHVlIiwicGFyc2VUb2tlbnMiLCJ0b2tlbnMiLCJ0b2tlbnNSRSIsImlzVmFsaWRIZWFkZXJOYW1lIiwibWF0Y2hIZWFkZXJWYWx1ZSIsImlzSGVhZGVyTmFtZUZpbHRlciIsImZvcm1hdEhlYWRlciIsInciLCJjaGFyIiwiYnVpbGRBY2Nlc3NvcnMiLCJhY2Nlc3Nvck5hbWUiLCJtZXRob2ROYW1lIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiY29uZmlndXJhYmxlIiwiQXhpb3NIZWFkZXJzIiwidmFsdWVPclJld3JpdGUiLCJyZXdyaXRlIiwic2V0SGVhZGVyIiwiX3ZhbHVlIiwiX2hlYWRlciIsIl9yZXdyaXRlIiwibEhlYWRlciIsInNldEhlYWRlcnMiLCJnZXQiLCJoYXMiLCJtYXRjaGVyIiwiZGVsZXRlIiwiZGVsZXRlZCIsImRlbGV0ZUhlYWRlciIsIm5vcm1hbGl6ZSIsImZvcm1hdCIsIm5vcm1hbGl6ZWQiLCJ0YXJnZXRzIiwiYXNTdHJpbmdzIiwiZmlyc3QiLCJjb21wdXRlZCIsImFjY2Vzc29yIiwiaW50ZXJuYWxzIiwiYWNjZXNzb3JzIiwiZGVmaW5lQWNjZXNzb3IiLCJtYXBwZWQiLCJoZWFkZXJWYWx1ZSIsIkF4aW9zSGVhZGVycyQxIiwidHJhbnNmb3JtRGF0YSIsImZucyIsInRyYW5zZm9ybSIsImlzQ2FuY2VsIiwiX19DQU5DRUxfXyIsIkNhbmNlbGVkRXJyb3IiLCJFUlJfQ0FOQ0VMRUQiLCJzZXR0bGUiLCJyZXNvbHZlIiwicmVqZWN0IiwiRVJSX0JBRF9SRVFVRVNUIiwiZmxvb3IiLCJwYXJzZVByb3RvY29sIiwic3BlZWRvbWV0ZXIiLCJzYW1wbGVzQ291bnQiLCJtaW4iLCJieXRlcyIsInRpbWVzdGFtcHMiLCJoZWFkIiwidGFpbCIsImZpcnN0U2FtcGxlVFMiLCJjaHVua0xlbmd0aCIsIm5vdyIsIkRhdGUiLCJzdGFydGVkQXQiLCJieXRlc0NvdW50IiwicGFzc2VkIiwicm91bmQiLCJ0aHJvdHRsZSIsImZyZXEiLCJ0aW1lc3RhbXAiLCJ0aHJlc2hvbGQiLCJ0aW1lciIsInRocm90dGxlZCIsImZvcmNlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInByb2dyZXNzRXZlbnRSZWR1Y2VyIiwibGlzdGVuZXIiLCJpc0Rvd25sb2FkU3RyZWFtIiwiYnl0ZXNOb3RpZmllZCIsIl9zcGVlZG9tZXRlciIsImxvYWRlZCIsInRvdGFsIiwibGVuZ3RoQ29tcHV0YWJsZSIsInByb2dyZXNzQnl0ZXMiLCJyYXRlIiwiaW5SYW5nZSIsInByb2dyZXNzIiwiZXN0aW1hdGVkIiwiZXZlbnQiLCJpc1VSTFNhbWVPcmlnaW4iLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJtc2llIiwidXNlckFnZW50IiwidXJsUGFyc2luZ05vZGUiLCJjcmVhdGVFbGVtZW50Iiwib3JpZ2luVVJMIiwicmVzb2x2ZVVSTCIsInNldEF0dHJpYnV0ZSIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhhc2giLCJob3N0bmFtZSIsInBvcnQiLCJwYXRobmFtZSIsImNoYXJBdCIsInJlcXVlc3RVUkwiLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJjb29raWVzIiwid3JpdGUiLCJleHBpcmVzIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwidG9HTVRTdHJpbmciLCJyZWFkIiwiUmVnRXhwIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVtb3ZlIiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiYmFzZVVSTCIsInJlbGF0aXZlVVJMIiwiYnVpbGRGdWxsUGF0aCIsInJlcXVlc3RlZFVSTCIsImhlYWRlcnNUb09iamVjdCIsIm1lcmdlQ29uZmlnIiwiY29uZmlnMSIsImNvbmZpZzIiLCJnZXRNZXJnZWRWYWx1ZSIsIm1lcmdlRGVlcFByb3BlcnRpZXMiLCJ2YWx1ZUZyb21Db25maWcyIiwiZGVmYXVsdFRvQ29uZmlnMiIsIm1lcmdlRGlyZWN0S2V5cyIsIm1lcmdlTWFwIiwicGFyYW1zU2VyaWFsaXplciIsInRpbWVvdXRNZXNzYWdlIiwid2l0aENyZWRlbnRpYWxzIiwid2l0aFhTUkZUb2tlbiIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJkZWNvbXByZXNzIiwiYmVmb3JlUmVkaXJlY3QiLCJ0cmFuc3BvcnQiLCJodHRwQWdlbnQiLCJodHRwc0FnZW50IiwiY2FuY2VsVG9rZW4iLCJzb2NrZXRQYXRoIiwicmVzcG9uc2VFbmNvZGluZyIsImNvbXB1dGVDb25maWdWYWx1ZSIsImNvbmZpZ1ZhbHVlIiwicmVzb2x2ZUNvbmZpZyIsIm5ld0NvbmZpZyIsImF1dGgiLCJidG9hIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVuZXNjYXBlIiwiQm9vbGVhbiIsInhzcmZWYWx1ZSIsImlzWEhSQWRhcHRlclN1cHBvcnRlZCIsIlhNTEh0dHBSZXF1ZXN0IiwieGhyQWRhcHRlciIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJfY29uZmlnIiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsIm9uQ2FuY2VsZWQiLCJ1bnN1YnNjcmliZSIsInNpZ25hbCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvcGVuIiwib25sb2FkZW5kIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VEYXRhIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsIl9yZXNvbHZlIiwiX3JlamVjdCIsImVyciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJvbmFib3J0IiwiaGFuZGxlQWJvcnQiLCJFQ09OTkFCT1JURUQiLCJvbmVycm9yIiwiaGFuZGxlRXJyb3IiLCJFUlJfTkVUV09SSyIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJ0aW1lb3V0RXJyb3JNZXNzYWdlIiwiRVRJTUVET1VUIiwic2V0UmVxdWVzdEhlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1cGxvYWQiLCJjYW5jZWwiLCJhYm9ydCIsInN1YnNjcmliZSIsImFib3J0ZWQiLCJzZW5kIiwiY29tcG9zZVNpZ25hbHMiLCJzaWduYWxzIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInJlYXNvbiIsImNvbXBvc2VTaWduYWxzJDEiLCJzdHJlYW1DaHVuayIsImNodW5rIiwiY2h1bmtTaXplIiwiYnl0ZUxlbmd0aCIsInBvcyIsImVuZCIsInJlYWRCeXRlcyIsIml0ZXJhYmxlIiwidHJhY2tTdHJlYW0iLCJzdHJlYW0iLCJvblByb2dyZXNzIiwib25GaW5pc2giLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjbG9zZSIsImVucXVldWUiLCJyZXR1cm4iLCJoaWdoV2F0ZXJNYXJrIiwiZmV0Y2hQcm9ncmVzc0RlY29yYXRvciIsImlzRmV0Y2hTdXBwb3J0ZWQiLCJmZXRjaCIsIlJlcXVlc3QiLCJSZXNwb25zZSIsImlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQiLCJlbmNvZGVUZXh0IiwiVGV4dEVuY29kZXIiLCJhcnJheUJ1ZmZlciIsInN1cHBvcnRzUmVxdWVzdFN0cmVhbSIsImR1cGxleEFjY2Vzc2VkIiwiaGFzQ29udGVudFR5cGUiLCJib2R5IiwiZHVwbGV4IiwiREVGQVVMVF9DSFVOS19TSVpFIiwic3VwcG9ydHNSZXNwb25zZVN0cmVhbSIsInJlc29sdmVycyIsInJlcyIsIl8iLCJFUlJfTk9UX1NVUFBPUlQiLCJnZXRCb2R5TGVuZ3RoIiwicmVzb2x2ZUJvZHlMZW5ndGgiLCJnZXRDb250ZW50TGVuZ3RoIiwiZmV0Y2hBZGFwdGVyIiwiZmV0Y2hPcHRpb25zIiwiY29tcG9zZWRTaWduYWwiLCJzdG9wVGltZW91dCIsImZpbmlzaGVkIiwicmVxdWVzdENvbnRlbnRMZW5ndGgiLCJfcmVxdWVzdCIsImNvbnRlbnRUeXBlSGVhZGVyIiwiaXNTdHJlYW1SZXNwb25zZSIsInJlc3BvbnNlQ29udGVudExlbmd0aCIsImtub3duQWRhcHRlcnMiLCJodHRwIiwieGhyIiwicmVuZGVyUmVhc29uIiwiaXNSZXNvbHZlZEhhbmRsZSIsImFkYXB0ZXJzIiwiZ2V0QWRhcHRlciIsIm5hbWVPckFkYXB0ZXIiLCJyZWplY3RlZFJlYXNvbnMiLCJyZWFzb25zIiwic3RhdGUiLCJzIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsInRocm93SWZSZXF1ZXN0ZWQiLCJkaXNwYXRjaFJlcXVlc3QiLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwib25BZGFwdGVyUmVqZWN0aW9uIiwiVkVSU0lPTiIsInZhbGlkYXRvcnMkMSIsInZhbGlkYXRvciIsImRlcHJlY2F0ZWRXYXJuaW5ncyIsInZlcnNpb24iLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsIm9wdHMiLCJFUlJfREVQUkVDQVRFRCIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0T3B0aW9ucyIsInNjaGVtYSIsImFsbG93VW5rbm93biIsIkVSUl9CQURfT1BUSU9OX1ZBTFVFIiwiRVJSX0JBRF9PUFRJT04iLCJ2YWxpZGF0b3JzIiwiQXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsImludGVyY2VwdG9ycyIsImNvbmZpZ09yVXJsIiwiZHVtbXkiLCJib29sZWFuIiwiZnVuY3Rpb24iLCJjb250ZXh0SGVhZGVycyIsInJlcXVlc3RJbnRlcmNlcHRvckNoYWluIiwic3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsInVuc2hpZnQiLCJyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4iLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJwcm9taXNlIiwiY2hhaW4iLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJnZXRVcmkiLCJmdWxsUGF0aCIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJnZW5lcmF0ZUhUVFBNZXRob2QiLCJpc0Zvcm0iLCJodHRwTWV0aG9kIiwiQXhpb3MkMSIsIkNhbmNlbFRva2VuIiwiZXhlY3V0b3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2VFeGVjdXRvciIsIl9saXN0ZW5lcnMiLCJvbmZ1bGZpbGxlZCIsInNwbGljZSIsImMiLCJDYW5jZWxUb2tlbiQxIiwic3ByZWFkIiwiY2FsbGJhY2siLCJpc0F4aW9zRXJyb3IiLCJwYXlsb2FkIiwiSHR0cFN0YXR1c0NvZGUiLCJDb250aW51ZSIsIlN3aXRjaGluZ1Byb3RvY29scyIsIlByb2Nlc3NpbmciLCJFYXJseUhpbnRzIiwiT2siLCJDcmVhdGVkIiwiQWNjZXB0ZWQiLCJOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb24iLCJOb0NvbnRlbnQiLCJSZXNldENvbnRlbnQiLCJQYXJ0aWFsQ29udGVudCIsIk11bHRpU3RhdHVzIiwiQWxyZWFkeVJlcG9ydGVkIiwiSW1Vc2VkIiwiTXVsdGlwbGVDaG9pY2VzIiwiTW92ZWRQZXJtYW5lbnRseSIsIkZvdW5kIiwiU2VlT3RoZXIiLCJOb3RNb2RpZmllZCIsIlVzZVByb3h5IiwiVW51c2VkIiwiVGVtcG9yYXJ5UmVkaXJlY3QiLCJQZXJtYW5lbnRSZWRpcmVjdCIsIkJhZFJlcXVlc3QiLCJVbmF1dGhvcml6ZWQiLCJQYXltZW50UmVxdWlyZWQiLCJGb3JiaWRkZW4iLCJOb3RGb3VuZCIsIk1ldGhvZE5vdEFsbG93ZWQiLCJOb3RBY2NlcHRhYmxlIiwiUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkIiwiUmVxdWVzdFRpbWVvdXQiLCJDb25mbGljdCIsIkdvbmUiLCJMZW5ndGhSZXF1aXJlZCIsIlByZWNvbmRpdGlvbkZhaWxlZCIsIlBheWxvYWRUb29MYXJnZSIsIlVyaVRvb0xvbmciLCJVbnN1cHBvcnRlZE1lZGlhVHlwZSIsIlJhbmdlTm90U2F0aXNmaWFibGUiLCJFeHBlY3RhdGlvbkZhaWxlZCIsIkltQVRlYXBvdCIsIk1pc2RpcmVjdGVkUmVxdWVzdCIsIlVucHJvY2Vzc2FibGVFbnRpdHkiLCJMb2NrZWQiLCJGYWlsZWREZXBlbmRlbmN5IiwiVG9vRWFybHkiLCJVcGdyYWRlUmVxdWlyZWQiLCJQcmVjb25kaXRpb25SZXF1aXJlZCIsIlRvb01hbnlSZXF1ZXN0cyIsIlJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZSIsIlVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zIiwiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIk5vdEltcGxlbWVudGVkIiwiQmFkR2F0ZXdheSIsIlNlcnZpY2VVbmF2YWlsYWJsZSIsIkdhdGV3YXlUaW1lb3V0IiwiSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQiLCJWYXJpYW50QWxzb05lZ290aWF0ZXMiLCJJbnN1ZmZpY2llbnRTdG9yYWdlIiwiTG9vcERldGVjdGVkIiwiTm90RXh0ZW5kZWQiLCJOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZCIsIkh0dHBTdGF0dXNDb2RlJDEiLCJjcmVhdGVJbnN0YW5jZSIsImRlZmF1bHRDb25maWciLCJpbnN0YW5jZSIsImF4aW9zIiwiQ2FuY2VsIiwiYWxsIiwicHJvbWlzZXMiLCJmb3JtVG9KU09OIiwiZGVmYXVsdCJdLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9oZWxwZXJzL2JpbmQuanMiLCIuLi8uLi9saWIvdXRpbHMuanMiLCIuLi8uLi9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvbnVsbC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanMiLCIuLi8uLi9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwiLi4vLi4vbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwiLi4vLi4vbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzIiwiLi4vLi4vbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9Gb3JtRGF0YS5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvQmxvYi5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9icm93c2VyL2luZGV4LmpzIiwiLi4vLi4vbGliL3BsYXRmb3JtL2NvbW1vbi91dGlscy5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMiLCIuLi8uLi9saWIvaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyIsIi4uLy4uL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIi4uLy4uL2xpYi9jb3JlL0F4aW9zSGVhZGVycy5qcyIsIi4uLy4uL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCIuLi8uLi9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiLi4vLi4vbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzIiwiLi4vLi4vbGliL2NvcmUvc2V0dGxlLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvdGhyb3R0bGUuanMiLCIuLi8uLi9saWIvaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCIuLi8uLi9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCIuLi8uLi9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwiLi4vLi4vbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCIuLi8uLi9saWIvaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzIiwiLi4vLi4vbGliL2FkYXB0ZXJzL3hoci5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvdHJhY2tTdHJlYW0uanMiLCIuLi8uLi9saWIvYWRhcHRlcnMvZmV0Y2guanMiLCIuLi8uLi9saWIvYWRhcHRlcnMvYWRhcHRlcnMuanMiLCIuLi8uLi9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCIuLi8uLi9saWIvZW52L2RhdGEuanMiLCIuLi8uLi9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCIuLi8uLi9saWIvY29yZS9BeGlvcy5qcyIsIi4uLy4uL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCIuLi8uLi9saWIvaGVscGVycy9zcHJlYWQuanMiLCIuLi8uLi9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCIuLi8uLi9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsIi4uLy4uL2xpYi9heGlvcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBsZXQga2luZDtcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcbiAgICAgIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiAoXG4gICAgICAgIChraW5kID0ga2luZE9mKHRoaW5nKSkgPT09ICdmb3JtZGF0YScgfHxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICAgICAgICAoa2luZCA9PT0gJ29iamVjdCcgJiYgaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbmNvbnN0IFtpc1JlYWRhYmxlU3RyZWFtLCBpc1JlcXVlc3QsIGlzUmVzcG9uc2UsIGlzSGVhZGVyc10gPSBbJ1JlYWRhYmxlU3RyZWFtJywgJ1JlcXVlc3QnLCAnUmVzcG9uc2UnLCAnSGVhZGVycyddLm1hcChraW5kT2ZUZXN0KTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuY29uc3QgdHJpbSA9IChzdHIpID0+IHN0ci50cmltID9cbiAgc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5cyA9IGZhbHNlXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCB7YWxsT3duS2V5cyA9IGZhbHNlfSA9IHt9KSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yIChpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBjb25zdCBrZXlzID0gYWxsT3duS2V5cyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrZXk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqLCBrZXkpIHtcbiAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgX2tleTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBfa2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ID09PSBfa2V5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiBfa2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgX2dsb2JhbCA9ICgoKSA9PiB7XG4gIC8qZXNsaW50IG5vLXVuZGVmOjAqL1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBnbG9iYWxUaGlzO1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxufSkoKTtcblxuY29uc3QgaXNDb250ZXh0RGVmaW5lZCA9IChjb250ZXh0KSA9PiAhaXNVbmRlZmluZWQoY29udGV4dCkgJiYgY29udGV4dCAhPT0gX2dsb2JhbDtcblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKlxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICBjb25zdCB7Y2FzZWxlc3N9ID0gaXNDb250ZXh0RGVmaW5lZCh0aGlzKSAmJiB0aGlzIHx8IHt9O1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYXNzaWduVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBjYXNlbGVzcyAmJiBmaW5kS2V5KHJlc3VsdCwga2V5KSB8fCBrZXk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W3RhcmdldEtleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZShyZXN1bHRbdGFyZ2V0S2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldICYmIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0sIHthbGxPd25LZXlzfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBpbmhlcml0cyA9IChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSA9PiB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9KTtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbnxCb29sZWFufSBbZmlsdGVyXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BGaWx0ZXJdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgdG9GbGF0T2JqZWN0ID0gKHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyLCBwcm9wRmlsdGVyKSA9PiB7XG4gIGxldCBwcm9wcztcbiAgbGV0IGk7XG4gIGxldCBwcm9wO1xuICBjb25zdCBtZXJnZWQgPSB7fTtcblxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIGlmIChzb3VyY2VPYmogPT0gbnVsbCkgcmV0dXJuIGRlc3RPYmo7XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoKCFwcm9wRmlsdGVyIHx8IHByb3BGaWx0ZXIocHJvcCwgc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBmaWx0ZXIgIT09IGZhbHNlICYmIGdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICpcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICpcbiAqIEByZXR1cm5zIHs/QXJyYXl9XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSAodGhpbmcpID0+IHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBsZXQgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKCFpc051bWJlcihpKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENoZWNraW5nIGlmIHRoZSBVaW50OEFycmF5IGV4aXN0cyBhbmQgaWYgaXQgZG9lcywgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICogdGhpbmcgcGFzc2VkIGluIGlzIGFuIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXlcbiAqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9XG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuY29uc3QgaXNUeXBlZEFycmF5ID0gKFR5cGVkQXJyYXkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gdGhpbmcgPT4ge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbi8qKlxuICogRm9yIGVhY2ggZW50cnkgaW4gdGhlIG9iamVjdCwgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUga2V5IGFuZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBlbnRyeS5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaEVudHJ5ID0gKG9iaiwgZm4pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gb2JqICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ2VuZXJhdG9yLmNhbGwob2JqKTtcblxuICBsZXQgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBwYWlyID0gcmVzdWx0LnZhbHVlO1xuICAgIGZuLmNhbGwob2JqLCBwYWlyWzBdLCBwYWlyWzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ0V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj59XG4gKi9cbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuICBjb25zdCBhcnIgPSBbXTtcblxuICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyci5wdXNoKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuLyogQ2hlY2tpbmcgaWYgdGhlIGtpbmRPZlRlc3QgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4gcGFzc2VkIGFuIEhUTUxGb3JtRWxlbWVudC4gKi9cbmNvbnN0IGlzSFRNTEZvcm0gPSBraW5kT2ZUZXN0KCdIVE1MRm9ybUVsZW1lbnQnKTtcblxuY29uc3QgdG9DYW1lbENhc2UgPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXFxzXShbYS16XFxkXSkoXFx3KikvZyxcbiAgICBmdW5jdGlvbiByZXBsYWNlcihtLCBwMSwgcDIpIHtcbiAgICAgIHJldHVybiBwMS50b1VwcGVyQ2FzZSgpICsgcDI7XG4gICAgfVxuICApO1xufTtcblxuLyogQ3JlYXRpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY2hlY2sgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSAoKHtoYXNPd25Qcm9wZXJ0eX0pID0+IChvYmosIHByb3ApID0+IGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkoT2JqZWN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1JlZ0V4cCA9IGtpbmRPZlRlc3QoJ1JlZ0V4cCcpO1xuXG5jb25zdCByZWR1Y2VEZXNjcmlwdG9ycyA9IChvYmosIHJlZHVjZXIpID0+IHtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopO1xuICBjb25zdCByZWR1Y2VkRGVzY3JpcHRvcnMgPSB7fTtcblxuICBmb3JFYWNoKGRlc2NyaXB0b3JzLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKChyZXQgPSByZWR1Y2VyKGRlc2NyaXB0b3IsIG5hbWUsIG9iaikpICE9PSBmYWxzZSkge1xuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gcmV0IHx8IGRlc2NyaXB0b3I7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHJlZHVjZWREZXNjcmlwdG9ycyk7XG59XG5cbi8qKlxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuY29uc3QgZnJlZXplTWV0aG9kcyA9IChvYmopID0+IHtcbiAgcmVkdWNlRGVzY3JpcHRvcnMob2JqLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIC8vIHNraXAgcmVzdHJpY3RlZCBwcm9wcyBpbiBzdHJpY3QgbW9kZVxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikgJiYgWydhcmd1bWVudHMnLCAnY2FsbGVyJywgJ2NhbGxlZSddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm47XG5cbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcblxuICAgIGlmICgnd3JpdGFibGUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldCA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3QgcmV3cml0ZSByZWFkLW9ubHkgbWV0aG9kIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB0b09iamVjdFNldCA9IChhcnJheU9yU3RyaW5nLCBkZWxpbWl0ZXIpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG5cbiAgY29uc3QgZGVmaW5lID0gKGFycikgPT4ge1xuICAgIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIG9ialt2YWx1ZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgaXNBcnJheShhcnJheU9yU3RyaW5nKSA/IGRlZmluZShhcnJheU9yU3RyaW5nKSA6IGRlZmluZShTdHJpbmcoYXJyYXlPclN0cmluZykuc3BsaXQoZGVsaW1pdGVyKSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNvbnN0IHRvRmluaXRlTnVtYmVyID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlID0gK3ZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBBTFBIQSA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcblxuY29uc3QgRElHSVQgPSAnMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IEFMUEhBQkVUID0ge1xuICBESUdJVCxcbiAgQUxQSEEsXG4gIEFMUEhBX0RJR0lUOiBBTFBIQSArIEFMUEhBLnRvVXBwZXJDYXNlKCkgKyBESUdJVFxufVxuXG5jb25zdCBnZW5lcmF0ZVN0cmluZyA9IChzaXplID0gMTYsIGFscGhhYmV0ID0gQUxQSEFCRVQuQUxQSEFfRElHSVQpID0+IHtcbiAgbGV0IHN0ciA9ICcnO1xuICBjb25zdCB7bGVuZ3RofSA9IGFscGhhYmV0O1xuICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgc3RyICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBsZW5ndGh8MF1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJyAmJiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdKTtcbn1cblxuY29uc3QgdG9KU09OT2JqZWN0ID0gKG9iaikgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBBcnJheSgxMCk7XG5cbiAgY29uc3QgdmlzaXQgPSAoc291cmNlLCBpKSA9PiB7XG5cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgaWYgKHN0YWNrLmluZGV4T2Yoc291cmNlKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoISgndG9KU09OJyBpbiBzb3VyY2UpKSB7XG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZWRWYWx1ZSA9IHZpc2l0KHZhbHVlLCBpICsgMSk7XG4gICAgICAgICAgIWlzVW5kZWZpbmVkKHJlZHVjZWRWYWx1ZSkgJiYgKHRhcmdldFtrZXldID0gcmVkdWNlZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tbaV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59XG5cbmNvbnN0IGlzQXN5bmNGbiA9IGtpbmRPZlRlc3QoJ0FzeW5jRnVuY3Rpb24nKTtcblxuY29uc3QgaXNUaGVuYWJsZSA9ICh0aGluZykgPT5cbiAgdGhpbmcgJiYgKGlzT2JqZWN0KHRoaW5nKSB8fCBpc0Z1bmN0aW9uKHRoaW5nKSkgJiYgaXNGdW5jdGlvbih0aGluZy50aGVuKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmNhdGNoKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNSZXF1ZXN0LFxuICBpc1Jlc3BvbnNlLFxuICBpc0hlYWRlcnMsXG4gIGlzVW5kZWZpbmVkLFxuICBpc0RhdGUsXG4gIGlzRmlsZSxcbiAgaXNCbG9iLFxuICBpc1JlZ0V4cCxcbiAgaXNGdW5jdGlvbixcbiAgaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1R5cGVkQXJyYXksXG4gIGlzRmlsZUxpc3QsXG4gIGZvckVhY2gsXG4gIG1lcmdlLFxuICBleHRlbmQsXG4gIHRyaW0sXG4gIHN0cmlwQk9NLFxuICBpbmhlcml0cyxcbiAgdG9GbGF0T2JqZWN0LFxuICBraW5kT2YsXG4gIGtpbmRPZlRlc3QsXG4gIGVuZHNXaXRoLFxuICB0b0FycmF5LFxuICBmb3JFYWNoRW50cnksXG4gIG1hdGNoQWxsLFxuICBpc0hUTUxGb3JtLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaGFzT3duUHJvcDogaGFzT3duUHJvcGVydHksIC8vIGFuIGFsaWFzIHRvIGF2b2lkIEVTTGludCBuby1wcm90b3R5cGUtYnVpbHRpbnMgZGV0ZWN0aW9uXG4gIHJlZHVjZURlc2NyaXB0b3JzLFxuICBmcmVlemVNZXRob2RzLFxuICB0b09iamVjdFNldCxcbiAgdG9DYW1lbENhc2UsXG4gIG5vb3AsXG4gIHRvRmluaXRlTnVtYmVyLFxuICBmaW5kS2V5LFxuICBnbG9iYWw6IF9nbG9iYWwsXG4gIGlzQ29udGV4dERlZmluZWQsXG4gIEFMUEhBQkVULFxuICBnZW5lcmF0ZVN0cmluZyxcbiAgaXNTcGVjQ29tcGxpYW50Rm9ybSxcbiAgdG9KU09OT2JqZWN0LFxuICBpc0FzeW5jRm4sXG4gIGlzVGhlbmFibGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgcmVzcG9uc2UgJiYgKHRoaXMucmVzcG9uc2UgPSByZXNwb25zZSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHV0aWxzLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMucmVzcG9uc2UgJiYgdGhpcy5yZXNwb25zZS5zdGF0dXMgPyB0aGlzLnJlc3BvbnNlLnN0YXR1cyA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJyxcbiAgJ0VSUl9OT1RfU1VQUE9SVCcsXG4gICdFUlJfSU5WQUxJRF9VUkwnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGNvZGUgPT4ge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gKGVycm9yLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlLCBjdXN0b21Qcm9wcykgPT4ge1xuICBjb25zdCBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSwgcHJvcCA9PiB7XG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5jYXVzZSA9IGVycm9yO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0Vycm9yO1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxuZXhwb3J0IGRlZmF1bHQgbnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG4vLyB0ZW1wb3JhcnkgaG90Zml4IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMgdW50aWwgQXhpb3NVUkxTZWFyY2hQYXJhbXMgaXMgcmVmYWN0b3JlZFxuaW1wb3J0IFBsYXRmb3JtRm9ybURhdGEgZnJvbSAnLi4vcGxhdGZvcm0vbm9kZS9jbGFzc2VzL0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB0aGluZyBpcyBhIGFycmF5IG9yIGpzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhpbmcgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIHZpc2l0ZWQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmlzaXRhYmxlKHRoaW5nKSB7XG4gIHJldHVybiB1dGlscy5pc1BsYWluT2JqZWN0KHRoaW5nKSB8fCB1dGlscy5pc0FycmF5KHRoaW5nKTtcbn1cblxuLyoqXG4gKiBJdCByZW1vdmVzIHRoZSBicmFja2V0cyBmcm9tIHRoZSBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBrZXkgd2l0aG91dCB0aGUgYnJhY2tldHMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJyYWNrZXRzKGtleSkge1xuICByZXR1cm4gdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSA/IGtleS5zbGljZSgwLCAtMikgOiBrZXk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXRoLCBhIGtleSwgYW5kIGEgYm9vbGVhbiwgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjdXJyZW50IG9iamVjdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdHMgLSBJZiB0cnVlLCB0aGUga2V5IHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBkb3RzIGluc3RlYWQgb2YgYnJhY2tldHMuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICovXG5mdW5jdGlvbiByZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSB7XG4gIGlmICghcGF0aCkgcmV0dXJuIGtleTtcbiAgcmV0dXJuIHBhdGguY29uY2F0KGtleSkubWFwKGZ1bmN0aW9uIGVhY2godG9rZW4sIGkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB0b2tlbiA9IHJlbW92ZUJyYWNrZXRzKHRva2VuKTtcbiAgICByZXR1cm4gIWRvdHMgJiYgaSA/ICdbJyArIHRva2VuICsgJ10nIDogdG9rZW47XG4gIH0pLmpvaW4oZG90cyA/ICcuJyA6ICcnKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgYXJyYXkgaXMgYW4gYXJyYXkgYW5kIG5vbmUgb2YgaXRzIGVsZW1lbnRzIGFyZSB2aXNpdGFibGUsIHRoZW4gaXQncyBhIGZsYXQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGbGF0QXJyYXkoYXJyKSB7XG4gIHJldHVybiB1dGlscy5pc0FycmF5KGFycikgJiYgIWFyci5zb21lKGlzVmlzaXRhYmxlKTtcbn1cblxuY29uc3QgcHJlZGljYXRlcyA9IHV0aWxzLnRvRmxhdE9iamVjdCh1dGlscywge30sIG51bGwsIGZ1bmN0aW9uIGZpbHRlcihwcm9wKSB7XG4gIHJldHVybiAvXmlzW0EtWl0vLnRlc3QocHJvcCk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gez9PYmplY3R9IFtmb3JtRGF0YV1cbiAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52aXNpdG9yXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXRhVG9rZW5zID0gdHJ1ZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG90cyA9IGZhbHNlXVxuICogQHBhcmFtIHs/Qm9vbGVhbn0gW29wdGlvbnMuaW5kZXhlcyA9IGZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiovXG5cbi8qKlxuICogSXQgY29udmVydHMgYW4gb2JqZWN0IGludG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gY29udmVydCB0byBmb3JtIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgLSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRvRm9ybURhdGEob2JqLCBmb3JtRGF0YSwgb3B0aW9ucykge1xuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyAoUGxhdGZvcm1Gb3JtRGF0YSB8fCBGb3JtRGF0YSkoKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgb3B0aW9ucyA9IHV0aWxzLnRvRmxhdE9iamVjdChvcHRpb25zLCB7XG4gICAgbWV0YVRva2VuczogdHJ1ZSxcbiAgICBkb3RzOiBmYWxzZSxcbiAgICBpbmRleGVzOiBmYWxzZVxuICB9LCBmYWxzZSwgZnVuY3Rpb24gZGVmaW5lZChvcHRpb24sIHNvdXJjZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIHJldHVybiAhdXRpbHMuaXNVbmRlZmluZWQoc291cmNlW29wdGlvbl0pO1xuICB9KTtcblxuICBjb25zdCBtZXRhVG9rZW5zID0gb3B0aW9ucy5tZXRhVG9rZW5zO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgY29uc3QgdmlzaXRvciA9IG9wdGlvbnMudmlzaXRvciB8fCBkZWZhdWx0VmlzaXRvcjtcbiAgY29uc3QgZG90cyA9IG9wdGlvbnMuZG90cztcbiAgY29uc3QgaW5kZXhlcyA9IG9wdGlvbnMuaW5kZXhlcztcbiAgY29uc3QgX0Jsb2IgPSBvcHRpb25zLkJsb2IgfHwgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIEJsb2I7XG4gIGNvbnN0IHVzZUJsb2IgPSBfQmxvYiAmJiB1dGlscy5pc1NwZWNDb21wbGlhbnRGb3JtKGZvcm1EYXRhKTtcblxuICBpZiAoIXV0aWxzLmlzRnVuY3Rpb24odmlzaXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aXNpdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAodXRpbHMuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VCbG9iICYmIHV0aWxzLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdXNlQmxvYiAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmd8TnVtYmVyPn0gcGF0aFxuICAgKiBAdGhpcyB7Rm9ybURhdGF9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB0byB2aXNpdCB0aGUgZWFjaCBwcm9wIG9mIHRoZSB2YWx1ZSByZWN1cnNpdmVseVxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xuICAgIGxldCBhcnIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gbWV0YVRva2VucyA/IGtleSA6IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh1dGlscy5pc0FycmF5KHZhbHVlKSAmJiBpc0ZsYXRBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICgodXRpbHMuaXNGaWxlTGlzdCh2YWx1ZSkgfHwgdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSkgJiYgKGFyciA9IHV0aWxzLnRvQXJyYXkodmFsdWUpKVxuICAgICAgICApKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSByZW1vdmVCcmFja2V0cyhrZXkpO1xuXG4gICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIGVhY2goZWwsIGluZGV4KSB7XG4gICAgICAgICAgISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgaW5kZXhlcyA9PT0gdHJ1ZSA/IHJlbmRlcktleShba2V5XSwgaW5kZXgsIGRvdHMpIDogKGluZGV4ZXMgPT09IG51bGwgPyBrZXkgOiBrZXkgKyAnW10nKSxcbiAgICAgICAgICAgIGNvbnZlcnRWYWx1ZShlbClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2l0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvcm1EYXRhLmFwcGVuZChyZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSwgY29udmVydFZhbHVlKHZhbHVlKSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGFjayA9IFtdO1xuXG4gIGNvbnN0IGV4cG9zZWRIZWxwZXJzID0gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGVzLCB7XG4gICAgZGVmYXVsdFZpc2l0b3IsXG4gICAgY29udmVydFZhbHVlLFxuICAgIGlzVmlzaXRhYmxlXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkKHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGF0aC5qb2luKCcuJykpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgdXRpbHMuZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gZWFjaChlbCwga2V5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgdmlzaXRvci5jYWxsKFxuICAgICAgICBmb3JtRGF0YSwgZWwsIHV0aWxzLmlzU3RyaW5nKGtleSkgPyBrZXkudHJpbSgpIDoga2V5LCBwYXRoLCBleHBvc2VkSGVscGVyc1xuICAgICAgKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICBidWlsZChlbCwgcGF0aCA/IHBhdGguY29uY2F0KGtleSkgOiBba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zvcm1EYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIEl0IGVuY29kZXMgYSBzdHJpbmcgYnkgcmVwbGFjaW5nIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBpbiB0aGUgdW5yZXNlcnZlZCBzZXQgd2l0aFxuICogdGhlaXIgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICBjb25zdCBjaGFyTWFwID0ge1xuICAgICchJzogJyUyMScsXG4gICAgXCInXCI6ICclMjcnLFxuICAgICcoJzogJyUyOCcsXG4gICAgJyknOiAnJTI5JyxcbiAgICAnfic6ICclN0UnLFxuICAgICclMjAnOiAnKycsXG4gICAgJyUwMCc6ICdcXHgwMCdcbiAgfTtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpfl18JTIwfCUwMC9nLCBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xuICAgIHJldHVybiBjaGFyTWFwW21hdGNoXTtcbiAgfSk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXJhbXMgb2JqZWN0IGFuZCBjb252ZXJ0cyBpdCB0byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gYmUgY29udmVydGVkIHRvIGEgRm9ybURhdGEgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgQXhpb3MgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykge1xuICB0aGlzLl9wYWlycyA9IFtdO1xuXG4gIHBhcmFtcyAmJiB0b0Zvcm1EYXRhKHBhcmFtcywgdGhpcywgb3B0aW9ucyk7XG59XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9wYWlycy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xufTtcblxucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoZW5jb2Rlcikge1xuICBjb25zdCBfZW5jb2RlID0gZW5jb2RlciA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZXIuY2FsbCh0aGlzLCB2YWx1ZSwgZW5jb2RlKTtcbiAgfSA6IGVuY29kZTtcblxuICByZXR1cm4gdGhpcy5fcGFpcnMubWFwKGZ1bmN0aW9uIGVhY2gocGFpcikge1xuICAgIHJldHVybiBfZW5jb2RlKHBhaXJbMF0pICsgJz0nICsgX2VuY29kZShwYWlyWzFdKTtcbiAgfSwgJycpLmpvaW4oJyYnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuXG4vKipcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxuICogVVJJIGVuY29kZWQgY291bnRlcnBhcnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7P29iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgXG4gIGNvbnN0IF9lbmNvZGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RlIHx8IGVuY29kZTtcblxuICBjb25zdCBzZXJpYWxpemVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIGNvbnN0IGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG5cbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBJbnRlcmNlcHRvck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAgICovXG4gIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJjZXB0b3Igd2FzIHJlbW92ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuICBlamVjdChpZCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgaW50ZXJjZXB0b3JzIGZyb20gdGhlIHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAgICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZm9yRWFjaChmbikge1xuICAgIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgICAgZm4oaCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnID8gVVJMU2VhcmNoUGFyYW1zIDogQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IG51bGw7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IG51bGxcbiIsImltcG9ydCBVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcydcbmltcG9ydCBGb3JtRGF0YSBmcm9tICcuL2NsYXNzZXMvRm9ybURhdGEuanMnXG5pbXBvcnQgQmxvYiBmcm9tICcuL2NsYXNzZXMvQmxvYi5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Jyb3dzZXI6IHRydWUsXG4gIGNsYXNzZXM6IHtcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgRm9ybURhdGEsXG4gICAgQmxvYlxuICB9LFxuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2Jsb2InLCAndXJsJywgJ2RhdGEnXVxufTtcbiIsImNvbnN0IGhhc0Jyb3dzZXJFbnYgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyRW52ID0gKFxuICAocHJvZHVjdCkgPT4ge1xuICAgIHJldHVybiBoYXNCcm93c2VyRW52ICYmIFsnUmVhY3ROYXRpdmUnLCAnTmF0aXZlU2NyaXB0JywgJ05TJ10uaW5kZXhPZihwcm9kdWN0KSA8IDBcbiAgfSkodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIG9yaWdpblxufVxuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vbm9kZS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2NvbW1vbi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLi4udXRpbHMsXG4gIC4uLnBsYXRmb3JtXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aXNpdG9yOiBmdW5jdGlvbih2YWx1ZSwga2V5LCBwYXRoLCBoZWxwZXJzKSB7XG4gICAgICBpZiAocGxhdGZvcm0uaXNOb2RlICYmIHV0aWxzLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscy5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscy5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscy5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGUsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSwgdGhpcywgbnVsbCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIGVudjoge1xuICAgIEZvcm1EYXRhOiBwbGF0Zm9ybS5jbGFzc2VzLkZvcm1EYXRhLFxuICAgIEJsb2I6IHBsYXRmb3JtLmNsYXNzZXMuQmxvYlxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddLCAobWV0aG9kKSA9PiB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuY29uc3QgaXNWYWxpZEhlYWRlck5hbWUgPSAoc3RyKSA9PiAvXlstX2EtekEtWjAtOV5gfH4sISMkJSYnKisuXSskLy50ZXN0KHN0ci50cmltKCkpO1xuXG5mdW5jdGlvbiBtYXRjaEhlYWRlclZhbHVlKGNvbnRleHQsIHZhbHVlLCBoZWFkZXIsIGZpbHRlciwgaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyKSAhPT0gLTE7XG4gIH1cblxuICBpZiAodXRpbHMuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBBeGlvc0hlYWRlcnMge1xuICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcbiAgfVxuXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBsSGVhZGVyKTtcblxuICAgICAgaWYoIWtleSB8fCBzZWxmW2tleV0gPT09IHVuZGVmaW5lZCB8fCBfcmV3cml0ZSA9PT0gdHJ1ZSB8fCAoX3Jld3JpdGUgPT09IHVuZGVmaW5lZCAmJiBzZWxmW2tleV0gIT09IGZhbHNlKSkge1xuICAgICAgICBzZWxmW2tleSB8fCBfaGVhZGVyXSA9IG5vcm1hbGl6ZVZhbHVlKF92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0SGVhZGVycyA9IChoZWFkZXJzLCBfcmV3cml0ZSkgPT5cbiAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGhlYWRlcikgfHwgaGVhZGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSBpZih1dGlscy5pc1N0cmluZyhoZWFkZXIpICYmIChoZWFkZXIgPSBoZWFkZXIudHJpbSgpKSAmJiAhaXNWYWxpZEhlYWRlck5hbWUoaGVhZGVyKSkge1xuICAgICAgc2V0SGVhZGVycyhwYXJzZUhlYWRlcnMoaGVhZGVyKSwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNIZWFkZXJzKGhlYWRlcikpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGhlYWRlci5lbnRyaWVzKCkpIHtcbiAgICAgICAgc2V0SGVhZGVyKHZhbHVlLCBrZXksIHJld3JpdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgIT0gbnVsbCAmJiBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQoaGVhZGVyLCBwYXJzZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbnModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1JlZ0V4cChwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlciBtdXN0IGJlIGJvb2xlYW58cmVnZXhwfGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlSGVhZGVyKF9oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmIChfaGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgX2hlYWRlcik7XG5cbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcblxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyLmZvckVhY2goZGVsZXRlSGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBjbGVhcihtYXRjaGVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZighbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25jYXQodGhpcywgLi4udGFyZ2V0cyk7XG4gIH1cblxuICB0b0pTT04oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIChvYmpbaGVhZGVyXSA9IGFzU3RyaW5ncyAmJiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtoZWFkZXIsIHZhbHVlXSkgPT4gaGVhZGVyICsgJzogJyArIHZhbHVlKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcblxuLy8gcmVzZXJ2ZWQgbmFtZXMgaG90Zml4XG51dGlscy5yZWR1Y2VEZXNjcmlwdG9ycyhBeGlvc0hlYWRlcnMucHJvdG90eXBlLCAoe3ZhbHVlfSwga2V5KSA9PiB7XG4gIGxldCBtYXBwZWQgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsgLy8gbWFwIGBzZXRgID0+IGBTZXRgXG4gIHJldHVybiB7XG4gICAgZ2V0OiAoKSA9PiB2YWx1ZSxcbiAgICBzZXQoaGVhZGVyVmFsdWUpIHtcbiAgICAgIHRoaXNbbWFwcGVkXSA9IGhlYWRlclZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NIZWFkZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7P09iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmbnMsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIGNvbnN0IGNvbnRleHQgPSByZXNwb25zZSB8fCBjb25maWc7XG4gIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb250ZXh0LmhlYWRlcnMpO1xuICBsZXQgZGF0YSA9IGNvbnRleHQuZGF0YTtcblxuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29uZmlnLCBkYXRhLCBoZWFkZXJzLm5vcm1hbGl6ZSgpLCByZXNwb25zZSA/IHJlc3BvbnNlLnN0YXR1cyA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuXG4gIGhlYWRlcnMubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscy5pbmhlcml0cyhDYW5jZWxlZEVycm9yLCBBeGlvc0Vycm9yLCB7XG4gIF9fQ0FOQ0VMX186IHRydWVcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL0F4aW9zRXJyb3IuanMnO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSByZXNwb25zZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKHJlc3BvbnNlLnN0YXR1cyAvIDEwMCkgLSA0XSxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XG4gIGNvbnN0IG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlc0NvdW50PSAxMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPSAxMDAwXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcGVlZG9tZXRlcihzYW1wbGVzQ291bnQsIG1pbikge1xuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgbGV0IGhlYWQgPSAwO1xuICBsZXQgdGFpbCA9IDA7XG4gIGxldCBmaXJzdFNhbXBsZVRTO1xuXG4gIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogMTAwMDtcblxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xuXG4gICAgaWYgKCFmaXJzdFNhbXBsZVRTKSB7XG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xuICAgIH1cblxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XG4gICAgdGltZXN0YW1wc1toZWFkXSA9IG5vdztcblxuICAgIGxldCBpID0gdGFpbDtcbiAgICBsZXQgYnl0ZXNDb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xuICAgICAgYnl0ZXNDb3VudCArPSBieXRlc1tpKytdO1xuICAgICAgaSA9IGkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaGVhZCA9IChoZWFkICsgMSkgJSBzYW1wbGVzQ291bnQ7XG5cbiAgICBpZiAoaGVhZCA9PT0gdGFpbCkge1xuICAgICAgdGFpbCA9ICh0YWlsICsgMSkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIGZpcnN0U2FtcGxlVFMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xuXG4gICAgcmV0dXJuIHBhc3NlZCA/IE1hdGgucm91bmQoYnl0ZXNDb3VudCAqIDEwMDAgLyBwYXNzZWQpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzcGVlZG9tZXRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBmcmVxKSB7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBjb25zdCB0aHJlc2hvbGQgPSAxMDAwIC8gZnJlcTtcbiAgbGV0IHRpbWVyID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcbiAgICBjb25zdCBmb3JjZSA9IHRoaXMgPT09IHRydWU7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChmb3JjZSB8fCBub3cgLSB0aW1lc3RhbXAgPiB0aHJlc2hvbGQpIHtcbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aW1lc3RhbXAgPSBub3c7XG4gICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0sIHRocmVzaG9sZCAtIChub3cgLSB0aW1lc3RhbXApKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRocm90dGxlO1xuIiwiaW1wb3J0IHNwZWVkb21ldGVyIGZyb20gXCIuL3NwZWVkb21ldGVyLmpzXCI7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSBcIi4vdGhyb3R0bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGxpc3RlbmVyLCBpc0Rvd25sb2FkU3RyZWFtLCBmcmVxID0gMykgPT4ge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiB0aHJvdHRsZShlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdG90YWwgIT0gbnVsbFxuICAgIH07XG5cbiAgICBkYXRhW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddID0gdHJ1ZTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9LCBmcmVxKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4vLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICBjb25zdCBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBjb25zdCB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBsZXQgb3JpZ2luVVJMO1xuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdHMgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgbGV0IGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKCk7XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICBjb25zdCBjb29raWUgPSBbbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldO1xuXG4gICAgICB1dGlscy5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKHBhdGgpICYmIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcoZG9tYWluKSAmJiBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXG4gICAgICBzZWN1cmUgPT09IHRydWUgJiYgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICA6XG5cbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7fSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7fVxuICB9O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLz9cXC8kLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB7IC4uLnRoaW5nIH0gOiB0aGluZztcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgY29uc3QgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UsIGNhc2VsZXNzKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZS5jYWxsKHtjYXNlbGVzc30sIHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhhLCBiLCBjYXNlbGVzcykge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIGNhc2VsZXNzKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKGEsIGIsIHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYik7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1lcmdlTWFwID0ge1xuICAgIHVybDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBtZXRob2Q6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgZGF0YTogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBiYXNlVVJMOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcGFyYW1zU2VyaWFsaXplcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXRNZXNzYWdlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhDcmVkZW50aWFsczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoWFNSRlRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VUeXBlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZDb29raWVOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Q29udGVudExlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhCb2R5TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zcG9ydDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBjYW5jZWxUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBzb2NrZXRQYXRoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdmFsaWRhdGVTdGF0dXM6IG1lcmdlRGlyZWN0S2V5cyxcbiAgICBoZWFkZXJzOiAoYSwgYikgPT4gbWVyZ2VEZWVwUHJvcGVydGllcyhoZWFkZXJzVG9PYmplY3QoYSksIGhlYWRlcnNUb09iamVjdChiKSwgdHJ1ZSlcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZzEsIGNvbmZpZzIpKSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICBjb25zdCBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcbiAgICAodXRpbHMuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gXCIuL2lzVVJMU2FtZU9yaWdpbi5qc1wiO1xuaW1wb3J0IGNvb2tpZXMgZnJvbSBcIi4vY29va2llcy5qc1wiO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSBcIi4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qc1wiO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gXCIuLi9jb3JlL21lcmdlQ29uZmlnLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gXCIuL2J1aWxkVVJMLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHtkYXRhLCB3aXRoWFNSRlRva2VuLCB4c3JmSGVhZGVyTmFtZSwgeHNyZkNvb2tpZU5hbWUsIGhlYWRlcnMsIGF1dGh9ID0gbmV3Q29uZmlnO1xuXG4gIG5ld0NvbmZpZy5oZWFkZXJzID0gaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGhlYWRlcnMpO1xuXG4gIG5ld0NvbmZpZy51cmwgPSBidWlsZFVSTChidWlsZEZ1bGxQYXRoKG5ld0NvbmZpZy5iYXNlVVJMLCBuZXdDb25maWcudXJsKSwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYgKGF1dGgpIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcbiAgICAgIGJ0b2EoKGF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKGF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYXV0aC5wYXNzd29yZCkpIDogJycpKVxuICAgICk7XG4gIH1cblxuICBsZXQgY29udGVudFR5cGU7XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkpIHtcbiAgICBpZiAocGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudikge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSh1bmRlZmluZWQpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkpICE9PSBmYWxzZSkge1xuICAgICAgLy8gZml4IHNlbWljb2xvbiBkdXBsaWNhdGlvbiBpc3N1ZSBmb3IgUmVhY3ROYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cbiAgICAgIGNvbnN0IFt0eXBlLCAuLi50b2tlbnNdID0gY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpLm1hcCh0b2tlbiA9PiB0b2tlbi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShbdHlwZSB8fCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIC4uLnRva2Vuc10uam9pbignOyAnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuXG4gIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICB3aXRoWFNSRlRva2VuICYmIHV0aWxzLmlzRnVuY3Rpb24od2l0aFhTUkZUb2tlbikgJiYgKHdpdGhYU1JGVG9rZW4gPSB3aXRoWFNSRlRva2VuKG5ld0NvbmZpZykpO1xuXG4gICAgaWYgKHdpdGhYU1JGVG9rZW4gfHwgKHdpdGhYU1JGVG9rZW4gIT09IGZhbHNlICYmIGlzVVJMU2FtZU9yaWdpbihuZXdDb25maWcudXJsKSkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgY29uc3QgeHNyZlZhbHVlID0geHNyZkhlYWRlck5hbWUgJiYgeHNyZkNvb2tpZU5hbWUgJiYgY29va2llcy5yZWFkKHhzcmZDb29raWVOYW1lKTtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICBoZWFkZXJzLnNldCh4c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3Q29uZmlnO1xufVxuXG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgc2V0dGxlIGZyb20gJy4vLi4vY29yZS9zZXR0bGUuanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBwcm9ncmVzc0V2ZW50UmVkdWNlciBmcm9tICcuLi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzJztcbmltcG9ydCByZXNvbHZlQ29uZmlnIGZyb20gXCIuLi9oZWxwZXJzL3Jlc29sdmVDb25maWcuanNcIjtcblxuY29uc3QgaXNYSFJBZGFwdGVyU3VwcG9ydGVkID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgaXNYSFJBZGFwdGVyU3VwcG9ydGVkICYmIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCBfY29uZmlnID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuICAgIGxldCByZXF1ZXN0RGF0YSA9IF9jb25maWcuZGF0YTtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKF9jb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG4gICAgbGV0IHtyZXNwb25zZVR5cGV9ID0gX2NvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKF9jb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAgIF9jb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHJlcXVlc3Qub3BlbihfY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBfY29uZmlnLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IF9jb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBfY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgX2NvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBfY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gX2NvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgX2NvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgIHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQgJiYgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUobnVsbCk7XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycy50b0pTT04oKSwgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhX2NvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gX2NvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihfY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoX2NvbmZpZy5vblVwbG9hZFByb2dyZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKF9jb25maWcuY2FuY2VsVG9rZW4gfHwgX2NvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gY2FuY2VsID0+IHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdCghY2FuY2VsIHx8IGNhbmNlbC50eXBlID8gbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnLCByZXF1ZXN0KSA6IGNhbmNlbCk7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBfY29uZmlnLmNhbmNlbFRva2VuICYmIF9jb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAgIF9jb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBfY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb3RvY29sID0gcGFyc2VQcm90b2NvbChfY29uZmlnLnVybCk7XG5cbiAgICBpZiAocHJvdG9jb2wgJiYgcGxhdGZvcm0ucHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCAnICsgcHJvdG9jb2wgKyAnOicsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBjb25maWcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSBcIi4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzXCI7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbmNvbnN0IGNvbXBvc2VTaWduYWxzID0gKHNpZ25hbHMsIHRpbWVvdXQpID0+IHtcbiAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgbGV0IGFib3J0ZWQ7XG5cbiAgY29uc3Qgb25hYm9ydCA9IGZ1bmN0aW9uIChjYW5jZWwpIHtcbiAgICBpZiAoIWFib3J0ZWQpIHtcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIGNvbnN0IGVyciA9IGNhbmNlbCBpbnN0YW5jZW9mIEVycm9yID8gY2FuY2VsIDogdGhpcy5yZWFzb247XG4gICAgICBjb250cm9sbGVyLmFib3J0KGVyciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBvbmFib3J0KG5ldyBBeGlvc0Vycm9yKGB0aW1lb3V0ICR7dGltZW91dH0gb2YgbXMgZXhjZWVkZWRgLCBBeGlvc0Vycm9yLkVUSU1FRE9VVCkpXG4gIH0sIHRpbWVvdXQpXG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgaWYgKHNpZ25hbHMpIHtcbiAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBzaWduYWxzLmZvckVhY2goc2lnbmFsID0+IHtcbiAgICAgICAgc2lnbmFsICYmXG4gICAgICAgIChzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpIDogc2lnbmFsLnVuc3Vic2NyaWJlKG9uYWJvcnQpKTtcbiAgICAgIH0pO1xuICAgICAgc2lnbmFscyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbCAmJiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KSk7XG5cbiAgY29uc3Qge3NpZ25hbH0gPSBjb250cm9sbGVyO1xuXG4gIHNpZ25hbC51bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuXG4gIHJldHVybiBbc2lnbmFsLCAoKSA9PiB7XG4gICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IG51bGw7XG4gIH1dO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlU2lnbmFscztcbiIsIlxuXG5leHBvcnQgY29uc3Qgc3RyZWFtQ2h1bmsgPSBmdW5jdGlvbiogKGNodW5rLCBjaHVua1NpemUpIHtcbiAgbGV0IGxlbiA9IGNodW5rLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKCFjaHVua1NpemUgfHwgbGVuIDwgY2h1bmtTaXplKSB7XG4gICAgeWllbGQgY2h1bms7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBlbmQ7XG5cbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGVuZCA9IHBvcyArIGNodW5rU2l6ZTtcbiAgICB5aWVsZCBjaHVuay5zbGljZShwb3MsIGVuZCk7XG4gICAgcG9zID0gZW5kO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZWFkQnl0ZXMgPSBhc3luYyBmdW5jdGlvbiogKGl0ZXJhYmxlLCBjaHVua1NpemUsIGVuY29kZSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhYmxlKSB7XG4gICAgeWllbGQqIHN0cmVhbUNodW5rKEFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykgPyBjaHVuayA6IChhd2FpdCBlbmNvZGUoU3RyaW5nKGNodW5rKSkpLCBjaHVua1NpemUpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0cmFja1N0cmVhbSA9IChzdHJlYW0sIGNodW5rU2l6ZSwgb25Qcm9ncmVzcywgb25GaW5pc2gsIGVuY29kZSkgPT4ge1xuICBjb25zdCBpdGVyYXRvciA9IHJlYWRCeXRlcyhzdHJlYW0sIGNodW5rU2l6ZSwgZW5jb2RlKTtcblxuICBsZXQgYnl0ZXMgPSAwO1xuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHR5cGU6ICdieXRlcycsXG5cbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgIG9uUHJvZ3Jlc3MgJiYgb25Qcm9ncmVzcyhieXRlcyArPSBsZW4pO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgfSxcbiAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICBvbkZpbmlzaChyZWFzb24pO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLnJldHVybigpO1xuICAgIH1cbiAgfSwge1xuICAgIGhpZ2hXYXRlck1hcms6IDJcbiAgfSlcbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tIFwiLi4vcGxhdGZvcm0vaW5kZXguanNcIjtcbmltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcbmltcG9ydCBjb21wb3NlU2lnbmFscyBmcm9tIFwiLi4vaGVscGVycy9jb21wb3NlU2lnbmFscy5qc1wiO1xuaW1wb3J0IHt0cmFja1N0cmVhbX0gZnJvbSBcIi4uL2hlbHBlcnMvdHJhY2tTdHJlYW0uanNcIjtcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQgcHJvZ3Jlc3NFdmVudFJlZHVjZXIgZnJvbSBcIi4uL2hlbHBlcnMvcHJvZ3Jlc3NFdmVudFJlZHVjZXIuanNcIjtcbmltcG9ydCByZXNvbHZlQ29uZmlnIGZyb20gXCIuLi9oZWxwZXJzL3Jlc29sdmVDb25maWcuanNcIjtcbmltcG9ydCBzZXR0bGUgZnJvbSBcIi4uL2NvcmUvc2V0dGxlLmpzXCI7XG5cbmNvbnN0IGZldGNoUHJvZ3Jlc3NEZWNvcmF0b3IgPSAodG90YWwsIGZuKSA9PiB7XG4gIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPSBudWxsO1xuICByZXR1cm4gKGxvYWRlZCkgPT4gc2V0VGltZW91dCgoKSA9PiBmbih7XG4gICAgbGVuZ3RoQ29tcHV0YWJsZSxcbiAgICB0b3RhbCxcbiAgICBsb2FkZWRcbiAgfSkpO1xufVxuXG5jb25zdCBpc0ZldGNoU3VwcG9ydGVkID0gdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgPSBpc0ZldGNoU3VwcG9ydGVkICYmIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gdXNlZCBvbmx5IGluc2lkZSB0aGUgZmV0Y2ggYWRhcHRlclxuY29uc3QgZW5jb2RlVGV4dCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgKChlbmNvZGVyKSA9PiAoc3RyKSA9PiBlbmNvZGVyLmVuY29kZShzdHIpKShuZXcgVGV4dEVuY29kZXIoKSkgOlxuICAgIGFzeW5jIChzdHIpID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShzdHIpLmFycmF5QnVmZmVyKCkpXG4pO1xuXG5jb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmICgoKSA9PiB7XG4gIGxldCBkdXBsZXhBY2Nlc3NlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QocGxhdGZvcm0ub3JpZ2luLCB7XG4gICAgYm9keTogbmV3IFJlYWRhYmxlU3RyZWFtKCksXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZ2V0IGR1cGxleCgpIHtcbiAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnaGFsZic7XG4gICAgfSxcbiAgfSkuaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpO1xuXG4gIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XG59KSgpO1xuXG5jb25zdCBERUZBVUxUX0NIVU5LX1NJWkUgPSA2NCAqIDEwMjQ7XG5cbmNvbnN0IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmICEhKCgpPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKG5ldyBSZXNwb25zZSgnJykuYm9keSk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgLy8gcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59KSgpO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIHN0cmVhbTogc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAoKHJlcykgPT4gcmVzLmJvZHkpXG59O1xuXG5pc0ZldGNoU3VwcG9ydGVkICYmICgoKHJlcykgPT4ge1xuICBbJ3RleHQnLCAnYXJyYXlCdWZmZXInLCAnYmxvYicsICdmb3JtRGF0YScsICdzdHJlYW0nXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICFyZXNvbHZlcnNbdHlwZV0gJiYgKHJlc29sdmVyc1t0eXBlXSA9IHV0aWxzLmlzRnVuY3Rpb24ocmVzW3R5cGVdKSA/IChyZXMpID0+IHJlc1t0eXBlXSgpIDpcbiAgICAgIChfLCBjb25maWcpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFJlc3BvbnNlIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLCBBeGlvc0Vycm9yLkVSUl9OT1RfU1VQUE9SVCwgY29uZmlnKTtcbiAgICAgIH0pXG4gIH0pO1xufSkobmV3IFJlc3BvbnNlKSk7XG5cbmNvbnN0IGdldEJvZHlMZW5ndGggPSBhc3luYyAoYm9keSkgPT4ge1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZih1dGlscy5pc0Jsb2IoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5zaXplO1xuICB9XG5cbiAgaWYodXRpbHMuaXNTcGVjQ29tcGxpYW50Rm9ybShib2R5KSkge1xuICAgIHJldHVybiAoYXdhaXQgbmV3IFJlcXVlc3QoYm9keSkuYXJyYXlCdWZmZXIoKSkuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG4gICAgYm9keSA9IGJvZHkgKyAnJztcbiAgfVxuXG4gIGlmKHV0aWxzLmlzU3RyaW5nKGJvZHkpKSB7XG4gICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xuICB9XG59XG5cbmNvbnN0IHJlc29sdmVCb2R5TGVuZ3RoID0gYXN5bmMgKGhlYWRlcnMsIGJvZHkpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIoaGVhZGVycy5nZXRDb250ZW50TGVuZ3RoKCkpO1xuXG4gIHJldHVybiBsZW5ndGggPT0gbnVsbCA/IGdldEJvZHlMZW5ndGgoYm9keSkgOiBsZW5ndGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKGFzeW5jIChjb25maWcpID0+IHtcbiAgbGV0IHtcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIGRhdGEsXG4gICAgc2lnbmFsLFxuICAgIGNhbmNlbFRva2VuLFxuICAgIHRpbWVvdXQsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgcmVzcG9uc2VUeXBlLFxuICAgIGhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzID0gJ3NhbWUtb3JpZ2luJyxcbiAgICBmZXRjaE9wdGlvbnNcbiAgfSA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcblxuICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgPyAocmVzcG9uc2VUeXBlICsgJycpLnRvTG93ZXJDYXNlKCkgOiAndGV4dCc7XG5cbiAgbGV0IFtjb21wb3NlZFNpZ25hbCwgc3RvcFRpbWVvdXRdID0gKHNpZ25hbCB8fCBjYW5jZWxUb2tlbiB8fCB0aW1lb3V0KSA/XG4gICAgY29tcG9zZVNpZ25hbHMoW3NpZ25hbCwgY2FuY2VsVG9rZW5dLCB0aW1lb3V0KSA6IFtdO1xuXG4gIGxldCBmaW5pc2hlZCwgcmVxdWVzdDtcblxuICBjb25zdCBvbkZpbmlzaCA9ICgpID0+IHtcbiAgICAhZmluaXNoZWQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb21wb3NlZFNpZ25hbCAmJiBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuXG4gICAgZmluaXNoZWQgPSB0cnVlO1xuICB9XG5cbiAgbGV0IHJlcXVlc3RDb250ZW50TGVuZ3RoO1xuXG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgb25VcGxvYWRQcm9ncmVzcyAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gJiYgbWV0aG9kICE9PSAnZ2V0JyAmJiBtZXRob2QgIT09ICdoZWFkJyAmJlxuICAgICAgKHJlcXVlc3RDb250ZW50TGVuZ3RoID0gYXdhaXQgcmVzb2x2ZUJvZHlMZW5ndGgoaGVhZGVycywgZGF0YSkpICE9PSAwXG4gICAgKSB7XG4gICAgICBsZXQgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpICYmIChjb250ZW50VHlwZUhlYWRlciA9IF9yZXF1ZXN0LmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShjb250ZW50VHlwZUhlYWRlcilcbiAgICAgIH1cblxuICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgZmV0Y2hQcm9ncmVzc0RlY29yYXRvcihcbiAgICAgICAgICByZXF1ZXN0Q29udGVudExlbmd0aCxcbiAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihvblVwbG9hZFByb2dyZXNzKVxuICAgICAgICApLCBudWxsLCBlbmNvZGVUZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHdpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHdpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscyA/ICdjb3JzJyA6ICdvbWl0JztcbiAgICB9XG5cbiAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBzaWduYWw6IGNvbXBvc2VkU2lnbmFsLFxuICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMubm9ybWFsaXplKCkudG9KU09OKCksXG4gICAgICBib2R5OiBkYXRhLFxuICAgICAgZHVwbGV4OiBcImhhbGZcIixcbiAgICAgIHdpdGhDcmVkZW50aWFsc1xuICAgIH0pO1xuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG5cbiAgICBjb25zdCBpc1N0cmVhbVJlc3BvbnNlID0gc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJyB8fCByZXNwb25zZVR5cGUgPT09ICdyZXNwb25zZScpO1xuXG4gICAgaWYgKHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKG9uRG93bmxvYWRQcm9ncmVzcyB8fCBpc1N0cmVhbVJlc3BvbnNlKSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBbJ3N0YXR1cycsICdzdGF0dXNUZXh0JywgJ2hlYWRlcnMnXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gcmVzcG9uc2VbcHJvcF07XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50TGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXG4gICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShcbiAgICAgICAgdHJhY2tTdHJlYW0ocmVzcG9uc2UuYm9keSwgREVGQVVMVF9DSFVOS19TSVpFLCBvbkRvd25sb2FkUHJvZ3Jlc3MgJiYgZmV0Y2hQcm9ncmVzc0RlY29yYXRvcihcbiAgICAgICAgICByZXNwb25zZUNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIob25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKVxuICAgICAgICApLCBpc1N0cmVhbVJlc3BvbnNlICYmIG9uRmluaXNoLCBlbmNvZGVUZXh0KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgfHwgJ3RleHQnO1xuXG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc29sdmVyc1t1dGlscy5maW5kS2V5KHJlc29sdmVycywgcmVzcG9uc2VUeXBlKSB8fCAndGV4dCddKHJlc3BvbnNlLCBjb25maWcpO1xuXG4gICAgIWlzU3RyZWFtUmVzcG9uc2UgJiYgb25GaW5pc2goKTtcblxuICAgIHN0b3BUaW1lb3V0ICYmIHN0b3BUaW1lb3V0KCk7XG5cbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIGhlYWRlcnM6IEF4aW9zSGVhZGVycy5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG9uRmluaXNoKCk7XG5cbiAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiAvZmV0Y2gvaS50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpLFxuICAgICAgICB7XG4gICAgICAgICAgY2F1c2U6IGVyci5jYXVzZSB8fCBlcnJcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlcnIsIGVyciAmJiBlcnIuY29kZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgfVxufSk7XG5cblxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBodHRwQWRhcHRlciBmcm9tICcuL2h0dHAuanMnO1xuaW1wb3J0IHhockFkYXB0ZXIgZnJvbSAnLi94aHIuanMnO1xuaW1wb3J0IGZldGNoQWRhcHRlciBmcm9tICcuL2ZldGNoLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcblxuY29uc3Qga25vd25BZGFwdGVycyA9IHtcbiAgaHR0cDogaHR0cEFkYXB0ZXIsXG4gIHhocjogeGhyQWRhcHRlcixcbiAgZmV0Y2g6IGZldGNoQWRhcHRlclxufVxuXG51dGlscy5mb3JFYWNoKGtub3duQWRhcHRlcnMsIChmbiwgdmFsdWUpID0+IHtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7dmFsdWV9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7dmFsdWV9KTtcbiAgfVxufSk7XG5cbmNvbnN0IHJlbmRlclJlYXNvbiA9IChyZWFzb24pID0+IGAtICR7cmVhc29ufWA7XG5cbmNvbnN0IGlzUmVzb2x2ZWRIYW5kbGUgPSAoYWRhcHRlcikgPT4gdXRpbHMuaXNGdW5jdGlvbihhZGFwdGVyKSB8fCBhZGFwdGVyID09PSBudWxsIHx8IGFkYXB0ZXIgPT09IGZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldEFkYXB0ZXI6IChhZGFwdGVycykgPT4ge1xuICAgIGFkYXB0ZXJzID0gdXRpbHMuaXNBcnJheShhZGFwdGVycykgPyBhZGFwdGVycyA6IFthZGFwdGVyc107XG5cbiAgICBjb25zdCB7bGVuZ3RofSA9IGFkYXB0ZXJzO1xuICAgIGxldCBuYW1lT3JBZGFwdGVyO1xuICAgIGxldCBhZGFwdGVyO1xuXG4gICAgY29uc3QgcmVqZWN0ZWRSZWFzb25zID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lT3JBZGFwdGVyID0gYWRhcHRlcnNbaV07XG4gICAgICBsZXQgaWQ7XG5cbiAgICAgIGFkYXB0ZXIgPSBuYW1lT3JBZGFwdGVyO1xuXG4gICAgICBpZiAoIWlzUmVzb2x2ZWRIYW5kbGUobmFtZU9yQWRhcHRlcikpIHtcbiAgICAgICAgYWRhcHRlciA9IGtub3duQWRhcHRlcnNbKGlkID0gU3RyaW5nKG5hbWVPckFkYXB0ZXIpKS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoYWRhcHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFVua25vd24gYWRhcHRlciAnJHtpZH0nYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFkYXB0ZXIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdGVkUmVhc29uc1tpZCB8fCAnIycgKyBpXSA9IGFkYXB0ZXI7XG4gICAgfVxuXG4gICAgaWYgKCFhZGFwdGVyKSB7XG5cbiAgICAgIGNvbnN0IHJlYXNvbnMgPSBPYmplY3QuZW50cmllcyhyZWplY3RlZFJlYXNvbnMpXG4gICAgICAgIC5tYXAoKFtpZCwgc3RhdGVdKSA9PiBgYWRhcHRlciAke2lkfSBgICtcbiAgICAgICAgICAoc3RhdGUgPT09IGZhbHNlID8gJ2lzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50JyA6ICdpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBidWlsZCcpXG4gICAgICAgICk7XG5cbiAgICAgIGxldCBzID0gbGVuZ3RoID9cbiAgICAgICAgKHJlYXNvbnMubGVuZ3RoID4gMSA/ICdzaW5jZSA6XFxuJyArIHJlYXNvbnMubWFwKHJlbmRlclJlYXNvbikuam9pbignXFxuJykgOiAnICcgKyByZW5kZXJSZWFzb24ocmVhc29uc1swXSkpIDpcbiAgICAgICAgJ2FzIG5vIGFkYXB0ZXIgc3BlY2lmaWVkJztcblxuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBzdWl0YWJsZSBhZGFwdGVyIHRvIGRpc3BhdGNoIHRoZSByZXF1ZXN0IGAgKyBzLFxuICAgICAgICAnRVJSX05PVF9TVVBQT1JUJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRhcHRlcjtcbiAgfSxcbiAgYWRhcHRlcnM6IGtub3duQWRhcHRlcnNcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRyYW5zZm9ybURhdGEgZnJvbSAnLi90cmFuc2Zvcm1EYXRhLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuLi9jYW5jZWwvaXNDYW5jZWwuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IGFkYXB0ZXJzIGZyb20gXCIuLi9hZGFwdGVycy9hZGFwdGVycy5qc1wiO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaWduYWwgJiYgY29uZmlnLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpO1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgaWYgKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpICE9PSAtMSkge1xuICAgIGNvbmZpZy5oZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCBmYWxzZSk7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcihjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyKTtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShyZXNwb25zZS5oZWFkZXJzKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShyZWFzb24ucmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuNy4yXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXk7XG5cbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkdW1teSA9IHt9KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFwic3RhY2tcIiBpcyBhbiB1bi13cml0YWJsZSBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcblxuICAgIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXNTZXJpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgICAgZW5jb2RlOiB2YWxpZGF0b3JzLmZ1bmN0aW9uLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGxldCBjb250ZXh0SGVhZGVycyA9IGhlYWRlcnMgJiYgdXRpbHMubWVyZ2UoXG4gICAgICBoZWFkZXJzLmNvbW1vbixcbiAgICAgIGhlYWRlcnNbY29uZmlnLm1ldGhvZF1cbiAgICApO1xuXG4gICAgaGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW47XG5cbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LmJpbmQodGhpcyksIHVuZGVmaW5lZF07XG4gICAgICBjaGFpbi51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBjaGFpbi5wdXNoLmFwcGx5KGNoYWluLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBvbkZ1bGZpbGxlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBvblJlamVjdGVkLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdC5jYWxsKHRoaXMsIG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgbGVuID0gcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBnZXRVcmkoY29uZmlnKSB7XG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSFRUUE1ldGhvZChpc0Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cbiIsImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzJztcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlO1xuXG5heGlvcy5kZWZhdWx0ID0gYXhpb3M7XG5cbi8vIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGhhdmUgYSBk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