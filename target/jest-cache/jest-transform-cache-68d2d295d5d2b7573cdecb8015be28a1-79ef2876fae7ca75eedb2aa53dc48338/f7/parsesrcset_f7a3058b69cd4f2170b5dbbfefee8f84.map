{"version":3,"names":["root","factory","define","amd","module","exports","parseSrcset","input","isSpace","c","collectCharacters","regEx","chars","match","exec","substring","pos","length","inputLength","regexLeadingSpaces","regexLeadingCommasOrSpaces","regexLeadingNotSpaces","regexTrailingCommas","regexNonNegativeInteger","regexFloatingPoint","url","descriptors","currentDescriptor","state","candidates","slice","replace","parseDescriptors","tokenize","charAt","push","pError","w","d","h","i","candidate","desc","lastChar","value","intVal","floatVal","parseInt","parseFloat","test","console","log"],"sources":["parse-srcset.js"],"sourcesContent":["/**\n * Srcset Parser\n *\n * By Alex Bell |  MIT License\n *\n * JS Parser for the string value that appears in markup <img srcset=\"here\">\n *\n * @returns Array [{url: _, d: _, w: _, h:_}, ...]\n *\n * Based super duper closely on the reference algorithm at:\n * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n *\n * Most comments are copied in directly from the spec\n * (except for comments in parens).\n */\n\n(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t} else if (typeof module === 'object' && module.exports) {\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t} else {\n\t\t// Browser globals (root is window)\n\t\troot.parseSrcset = factory();\n\t}\n}(this, function () {\n\n\t// 1. Let input be the value passed to this algorithm.\n\treturn function (input) {\n\n\t\t// UTILITY FUNCTIONS\n\n\t\t// Manual is faster than RegEx\n\t\t// http://bjorn.tipling.com/state-and-regular-expressions-in-javascript\n\t\t// http://jsperf.com/whitespace-character/5\n\t\tfunction isSpace(c) {\n\t\t\treturn (c === \"\\u0020\" || // space\n\t\t\tc === \"\\u0009\" || // horizontal tab\n\t\t\tc === \"\\u000A\" || // new line\n\t\t\tc === \"\\u000C\" || // form feed\n\t\t\tc === \"\\u000D\");  // carriage return\n\t\t}\n\n\t\tfunction collectCharacters(regEx) {\n\t\t\tvar chars,\n\t\t\t\tmatch = regEx.exec(input.substring(pos));\n\t\t\tif (match) {\n\t\t\t\tchars = match[ 0 ];\n\t\t\t\tpos += chars.length;\n\t\t\t\treturn chars;\n\t\t\t}\n\t\t}\n\n\t\tvar inputLength = input.length,\n\n\t\t\t// (Don't use \\s, to avoid matching non-breaking space)\n\t\t\tregexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/,\n\t\t\tregexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/,\n\t\t\tregexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/,\n\t\t\tregexTrailingCommas = /[,]+$/,\n\t\t\tregexNonNegativeInteger = /^\\d+$/,\n\n\t\t\t// ( Positive or negative or unsigned integers or decimals, without or without exponents.\n\t\t\t// Must include at least one digit.\n\t\t\t// According to spec tests any decimal point must be followed by a digit.\n\t\t\t// No leading plus sign is allowed.)\n\t\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n\t\t\tregexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,\n\n\t\t\turl,\n\t\t\tdescriptors,\n\t\t\tcurrentDescriptor,\n\t\t\tstate,\n\t\t\tc,\n\n\t\t\t// 2. Let position be a pointer into input, initially pointing at the start\n\t\t\t//    of the string.\n\t\t\tpos = 0,\n\n\t\t\t// 3. Let candidates be an initially empty source set.\n\t\t\tcandidates = [];\n\n\t\t// 4. Splitting loop: Collect a sequence of characters that are space\n\t\t//    characters or U+002C COMMA characters. If any U+002C COMMA characters\n\t\t//    were collected, that is a parse error.\n\t\twhile (true) {\n\t\t\tcollectCharacters(regexLeadingCommasOrSpaces);\n\n\t\t\t// 5. If position is past the end of input, return candidates and abort these steps.\n\t\t\tif (pos >= inputLength) {\n\t\t\t\treturn candidates; // (we're done, this is the sole return path)\n\t\t\t}\n\n\t\t\t// 6. Collect a sequence of characters that are not space characters,\n\t\t\t//    and let that be url.\n\t\t\turl = collectCharacters(regexLeadingNotSpaces);\n\n\t\t\t// 7. Let descriptors be a new empty list.\n\t\t\tdescriptors = [];\n\n\t\t\t// 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n\t\t\t//\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n\t\t\t//         more than one character, that is a parse error.\n\t\t\tif (url.slice(-1) === \",\") {\n\t\t\t\turl = url.replace(regexTrailingCommas, \"\");\n\t\t\t\t// (Jump ahead to step 9 to skip tokenization and just push the candidate).\n\t\t\t\tparseDescriptors();\n\n\t\t\t\t//\tOtherwise, follow these substeps:\n\t\t\t} else {\n\t\t\t\ttokenize();\n\t\t\t} // (close else of step 8)\n\n\t\t\t// 16. Return to the step labeled splitting loop.\n\t\t} // (Close of big while loop.)\n\n\t\t/**\n\t\t * Tokenizes descriptor properties prior to parsing\n\t\t * Returns undefined.\n\t\t */\n\t\tfunction tokenize() {\n\n\t\t\t// 8.1. Descriptor tokeniser: Skip whitespace\n\t\t\tcollectCharacters(regexLeadingSpaces);\n\n\t\t\t// 8.2. Let current descriptor be the empty string.\n\t\t\tcurrentDescriptor = \"\";\n\n\t\t\t// 8.3. Let state be in descriptor.\n\t\t\tstate = \"in descriptor\";\n\n\t\t\twhile (true) {\n\n\t\t\t\t// 8.4. Let c be the character at position.\n\t\t\t\tc = input.charAt(pos);\n\n\t\t\t\t//  Do the following depending on the value of state.\n\t\t\t\t//  For the purpose of this step, \"EOF\" is a special character representing\n\t\t\t\t//  that position is past the end of input.\n\n\t\t\t\t// In descriptor\n\t\t\t\tif (state === \"in descriptor\") {\n\t\t\t\t\t// Do the following, depending on the value of c:\n\n\t\t\t\t\t// Space character\n\t\t\t\t\t// If current descriptor is not empty, append current descriptor to\n\t\t\t\t\t// descriptors and let current descriptor be the empty string.\n\t\t\t\t\t// Set state to after descriptor.\n\t\t\t\t\tif (isSpace(c)) {\n\t\t\t\t\t\tif (currentDescriptor) {\n\t\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\t\tcurrentDescriptor = \"\";\n\t\t\t\t\t\t\tstate = \"after descriptor\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// U+002C COMMA (,)\n\t\t\t\t\t\t// Advance position to the next character in input. If current descriptor\n\t\t\t\t\t\t// is not empty, append current descriptor to descriptors. Jump to the step\n\t\t\t\t\t\t// labeled descriptor parser.\n\t\t\t\t\t} else if (c === \",\") {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\tif (currentDescriptor) {\n\t\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t// U+0028 LEFT PARENTHESIS (()\n\t\t\t\t\t\t// Append c to current descriptor. Set state to in parens.\n\t\t\t\t\t} else if (c === \"\\u0028\") {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t\tstate = \"in parens\";\n\n\t\t\t\t\t\t// EOF\n\t\t\t\t\t\t// If current descriptor is not empty, append current descriptor to\n\t\t\t\t\t\t// descriptors. Jump to the step labeled descriptor parser.\n\t\t\t\t\t} else if (c === \"\") {\n\t\t\t\t\t\tif (currentDescriptor) {\n\t\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t// Anything else\n\t\t\t\t\t\t// Append c to current descriptor.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t}\n\t\t\t\t\t// (end \"in descriptor\"\n\n\t\t\t\t\t// In parens\n\t\t\t\t} else if (state === \"in parens\") {\n\n\t\t\t\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\t\t\t\t// Append c to current descriptor. Set state to in descriptor.\n\t\t\t\t\tif (c === \")\") {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t\tstate = \"in descriptor\";\n\n\t\t\t\t\t\t// EOF\n\t\t\t\t\t\t// Append current descriptor to descriptors. Jump to the step labeled\n\t\t\t\t\t\t// descriptor parser.\n\t\t\t\t\t} else if (c === \"\") {\n\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t// Anything else\n\t\t\t\t\t\t// Append c to current descriptor.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t}\n\n\t\t\t\t\t// After descriptor\n\t\t\t\t} else if (state === \"after descriptor\") {\n\n\t\t\t\t\t// Do the following, depending on the value of c:\n\t\t\t\t\t// Space character: Stay in this state.\n\t\t\t\t\tif (isSpace(c)) {\n\n\t\t\t\t\t\t// EOF: Jump to the step labeled descriptor parser.\n\t\t\t\t\t} else if (c === \"\") {\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t// Anything else\n\t\t\t\t\t\t// Set state to in descriptor. Set position to the previous character in input.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate = \"in descriptor\";\n\t\t\t\t\t\tpos -= 1;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Advance position to the next character in input.\n\t\t\t\tpos += 1;\n\n\t\t\t\t// Repeat this step.\n\t\t\t} // (close while true loop)\n\t\t}\n\n\t\t/**\n\t\t * Adds descriptor properties to a candidate, pushes to the candidates array\n\t\t * @return undefined\n\t\t */\n\t\t// Declared outside of the while loop so that it's only created once.\n\t\tfunction parseDescriptors() {\n\n\t\t\t// 9. Descriptor parser: Let error be no.\n\t\t\tvar pError = false,\n\n\t\t\t\t// 10. Let width be absent.\n\t\t\t\t// 11. Let density be absent.\n\t\t\t\t// 12. Let future-compat-h be absent. (We're implementing it now as h)\n\t\t\t\tw, d, h, i,\n\t\t\t\tcandidate = {},\n\t\t\t\tdesc, lastChar, value, intVal, floatVal;\n\n\t\t\t// 13. For each descriptor in descriptors, run the appropriate set of steps\n\t\t\t// from the following list:\n\t\t\tfor (i = 0 ; i < descriptors.length; i++) {\n\t\t\t\tdesc = descriptors[ i ];\n\n\t\t\t\tlastChar = desc[ desc.length - 1 ];\n\t\t\t\tvalue = desc.substring(0, desc.length - 1);\n\t\t\t\tintVal = parseInt(value, 10);\n\t\t\t\tfloatVal = parseFloat(value);\n\n\t\t\t\t// If the descriptor consists of a valid non-negative integer followed by\n\t\t\t\t// a U+0077 LATIN SMALL LETTER W character\n\t\t\t\tif (regexNonNegativeInteger.test(value) && (lastChar === \"w\")) {\n\n\t\t\t\t\t// If width and density are not both absent, then let error be yes.\n\t\t\t\t\tif (w || d) {pError = true;}\n\n\t\t\t\t\t// Apply the rules for parsing non-negative integers to the descriptor.\n\t\t\t\t\t// If the result is zero, let error be yes.\n\t\t\t\t\t// Otherwise, let width be the result.\n\t\t\t\t\tif (intVal === 0) {pError = true;} else {w = intVal;}\n\n\t\t\t\t\t// If the descriptor consists of a valid floating-point number followed by\n\t\t\t\t\t// a U+0078 LATIN SMALL LETTER X character\n\t\t\t\t} else if (regexFloatingPoint.test(value) && (lastChar === \"x\")) {\n\n\t\t\t\t\t// If width, density and future-compat-h are not all absent, then let error\n\t\t\t\t\t// be yes.\n\t\t\t\t\tif (w || d || h) {pError = true;}\n\n\t\t\t\t\t// Apply the rules for parsing floating-point number values to the descriptor.\n\t\t\t\t\t// If the result is less than zero, let error be yes. Otherwise, let density\n\t\t\t\t\t// be the result.\n\t\t\t\t\tif (floatVal < 0) {pError = true;} else {d = floatVal;}\n\n\t\t\t\t\t// If the descriptor consists of a valid non-negative integer followed by\n\t\t\t\t\t// a U+0068 LATIN SMALL LETTER H character\n\t\t\t\t} else if (regexNonNegativeInteger.test(value) && (lastChar === \"h\")) {\n\n\t\t\t\t\t// If height and density are not both absent, then let error be yes.\n\t\t\t\t\tif (h || d) {pError = true;}\n\n\t\t\t\t\t// Apply the rules for parsing non-negative integers to the descriptor.\n\t\t\t\t\t// If the result is zero, let error be yes. Otherwise, let future-compat-h\n\t\t\t\t\t// be the result.\n\t\t\t\t\tif (intVal === 0) {pError = true;} else {h = intVal;}\n\n\t\t\t\t\t// Anything else, Let error be yes.\n\t\t\t\t} else {pError = true;}\n\t\t\t} // (close step 13 for loop)\n\n\t\t\t// 15. If error is still no, then append a new image source to candidates whose\n\t\t\t// URL is url, associated with a width width if not absent and a pixel\n\t\t\t// density density if not absent. Otherwise, there is a parse error.\n\t\t\tif (!pError) {\n\t\t\t\tcandidate.url = url;\n\t\t\t\tif (w) { candidate.w = w;}\n\t\t\t\tif (d) { candidate.d = d;}\n\t\t\t\tif (h) { candidate.h = h;}\n\t\t\t\tcandidates.push(candidate);\n\t\t\t} else if (console && console.log) {\n\t\t\t\tconsole.log(\"Invalid srcset descriptor found in '\" +\n\t\t\t\t\tinput + \"' at '\" + desc + \"'.\");\n\t\t\t}\n\t\t} // (close parseDescriptors fn)\n\n\t}\n}));\n"],"mappings":"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","ignoreList":[]}