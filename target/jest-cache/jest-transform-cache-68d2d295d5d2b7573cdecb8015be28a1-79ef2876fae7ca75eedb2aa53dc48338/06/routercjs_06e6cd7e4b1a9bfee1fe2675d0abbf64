247b6a432a01178399bf6b0f4dcf0d0f
/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
let Action = /*#__PURE__*/function (Action) {
  Action["Pop"] = "POP";
  Action["Push"] = "PUSH";
  Action["Replace"] = "REPLACE";
  return Action;
}({});

/**
 * The pathname, search, and hash values of a URL.
 */

// TODO: (v7) Change the Location generic default from `any` to `unknown` and
// remove Remix `useLocation` wrapper.
/**
 * An entry in a history stack. A location contains information about the
 * URL path, as well as possibly some arbitrary state and a key.
 */
/**
 * A change to the current location.
 */
/**
 * A function that receives notifications about location changes.
 */
/**
 * Describes a location that is the destination of some navigation, either via
 * `history.push` or `history.replace`. This may be either a URL or the pieces
 * of a URL path.
 */
/**
 * A history is an interface to the navigation stack. The history serves as the
 * source of truth for the current location, as well as provides a set of
 * methods that may be used to change it.
 *
 * It is similar to the DOM's `window.history` object, but with a smaller, more
 * focused API.
 */
const PopStateEventType = "popstate";
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region Memory History
////////////////////////////////////////////////////////////////////////////////

/**
 * A user-supplied object that describes a location. Used when providing
 * entries to `createMemoryHistory` via its `initialEntries` option.
 */
/**
 * A memory history stores locations in memory. This is useful in stateful
 * environments where there is no web browser, such as node tests or React
 * Native.
 */
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation
  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region Browser History
////////////////////////////////////////////////////////////////////////////////

/**
 * A browser history stores the current location in regular URLs in a web
 * browser environment. This is the standard for most web apps and provides the
 * cleanest URLs the browser's address bar.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
 */
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region Hash History
////////////////////////////////////////////////////////////////////////////////

/**
 * A hash history stores the current location in the fragment identifier portion
 * of the URL in a web browser environment.
 *
 * This is ideal for apps that do not control the server for some reason
 * (because the fragment identifier is never sent to the server), including some
 * shared hosting environments that do not provide fine-grained controls over
 * which pages are served at which URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory
 */
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));

    // Hash URL should always have a leading / just like window.location.pathname
    // does, so if an app ends up at a route like /#something then we add a
    // leading slash so all of our path-matching behaves the same as if it would
    // in a browser router.  This is particularly important when there exists a
    // root splat route (<Route path="*">) since that matches internally against
    // "/*" and we'd expect /#something to 404 in a hash router app.
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region UTILS
////////////////////////////////////////////////////////////////////////////////

/**
 * @private
 */
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience, so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message);
      // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}

/**
 * For browser-based histories, we combine the state and key into an object
 */
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}

/**
 * Creates a Location object with a unique key from the given Path
 */
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}

/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}

/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);

    // try...catch because iOS limits us to 100 pushState calls :/
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // If the exception is because `state` can't be serialized, let that throw
      // outwards just like a replace call would so the dev knows the cause
      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps
      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    // Treating this as a full URL will strip any trailing spaces so we need to
    // pre-encode them since they might be part of a matching splat param from
    // an ancestor route
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}

//#endregion

/**
 * Map of routeId -> data returned from a loader/action/error
 */

let ResultType = /*#__PURE__*/function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
  return ResultType;
}({});

/**
 * Successful result from a loader or action
 */

/**
 * Successful defer() result from a loader or action
 */

/**
 * Redirect result from a loader or action
 */

/**
 * Unsuccessful result from a loader or action
 */

/**
 * Result from a loader or action - potentially successful or unsuccessful
 */

/**
 * Result from a loader or action called via dataStrategy
 */

/**
 * Users can specify either lowercase or uppercase form methods on `<Form>`,
 * useSubmit(), `<fetcher.Form>`, etc.
 */

/**
 * Active navigation/fetcher form methods are exposed in lowercase on the
 * RouterState
 */

/**
 * In v7, active navigation/fetcher form methods are exposed in uppercase on the
 * RouterState.  This is to align with the normalization done via fetch().
 */

// Thanks https://github.com/sindresorhus/type-fest!

/**
 * @private
 * Internal interface to pass around for action submissions, not intended for
 * external consumption
 */

/**
 * @private
 * Arguments passed to route loader/action functions.  Same for now but we keep
 * this as a private implementation detail in case they diverge in the future.
 */

// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:
//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs
//   Also, make them a type alias instead of an interface
/**
 * Arguments passed to loader functions
 */
/**
 * Arguments passed to action functions
 */
/**
 * Loaders and actions can return anything except `undefined` (`null` is a
 * valid return value if there is no data to return).  Responses are preferred
 * and will ease any future migration to Remix
 */
/**
 * Route loader function signature
 */
/**
 * Route action function signature
 */
/**
 * Arguments passed to shouldRevalidate function
 */
/**
 * Route shouldRevalidate function signature.  This runs after any submission
 * (navigation or fetcher), so we flatten the navigation/fetcher submission
 * onto the arguments.  It shouldn't matter whether it came from a navigation
 * or a fetcher, what really matters is the URLs and the formData since loaders
 * have to re-run based on the data models that were potentially mutated.
 */
/**
 * Function provided by the framework-aware layers to set `hasErrorBoundary`
 * from the framework-aware `errorElement` prop
 *
 * @deprecated Use `mapRouteProperties` instead
 */
/**
 * Function provided by the framework-aware layers to set any framework-specific
 * properties from framework-agnostic properties
 */
/**
 * Keys we cannot change from within a lazy() function. We spread all other keys
 * onto the route. Either they're meaningful to the router, or they'll get
 * ignored.
 */
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

/**
 * lazy() function to load a route definition, which can add non-matching
 * related properties to a route
 */

/**
 * Base RouteObject with common props shared by all types of routes
 */

/**
 * Index routes must not have children
 */

/**
 * Non-index routes may have children, but cannot have index
 */

/**
 * A route object represents a logical route, with (optionally) its child
 * routes organized in a tree-like structure.
 */

/**
 * A data route object, which is just a RouteObject with a required unique ID
 */

// Recursive helper for finding path parameters in the absence of wildcards

/**
 * Examples:
 * "/a/b/*" -> "*"
 * ":a" -> "a"
 * "/a/:b" -> "b"
 * "/a/blahblahblah:b" -> "b"
 * "/:a/:b" -> "a" | "b"
 * "/:a/b/:c/*" -> "a" | "c" | "*"
 */

// Attempt to parse the given string segment. If it fails, then just return the
// plain string type as a default fallback. Otherwise, return the union of the
// parsed string literals that were referenced as dynamic segments in the route.
/**
 * The parameters that were parsed from the URL path.
 */
/**
 * A RouteMatch contains info about how a route matched a URL.
 */
function isIndexRoute(route) {
  return route.index === true;
}

// Walk the route tree generating unique IDs where necessary, so we are working
// solely with AgnosticDataRouteObject's within the Router
function convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id], "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, mapRouteProperties(route), {
        id
      });
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
        id,
        children: undefined
      });
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}

/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded);
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);

    // Add the children before adding this route to the array, so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.
    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    }

    // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}

/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;

  // Optional path segments are denoted by a trailing `?`
  let isOptional = first.endsWith("?");
  // Compute the corresponding required segment: `foo?` -> `foo`
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];

  // All child paths with the prefix.  Do this for all children before the
  // optional version for all children, so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explode _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue
  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));

  // Then, if this is an optional value, add all child versions without
  if (isOptional) {
    result.push(...restExploded);
  }

  // for absolute paths, ensure `/` instead of empty segment
  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}

/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */
function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }

  // ensure `/` is added at the beginning if the path is absolute
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;

    // only apply the splat if it's the last segment
    if (isLastSegment && segment === "*") {
      const star = "*";
      // Apply the splat
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, "Missing \":" + key + "\" param");
      return stringify(param);
    }

    // Remove any optional markers from optional static segments
    return segment.replace(/\?$/g, "");
  })
  // Remove empty segments
  .filter(segment => !!segment);
  return prefix + segments.join("/");
}

/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */

/**
 * A PathMatch contains info about how a PathPattern matched on a URL pathname.
 */

/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo[paramName] = undefined;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex, so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}

/**
 * @private
 */
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}

/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}

/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}

// Return the array of pathnames for the current route matches - used to
// generate the routePathnames input for resolveTo()
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);

  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf
  // match so we include splat values for "." links.  See:
  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map(match => match.pathnameBase);
}

/**
 * @private
 */
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;

  // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    // With relative="route" (the default), each leading .. segment means
    // "go up one route" instead of "go up one URL segment".  This is a key
    // difference from how <a href> works and a major reason we call this a
    // "to" value instead of a "href".
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);

  // Ensure the pathname has a trailing slash if the original "to" had one
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  // Or if this was a link to the current path which has a trailing slash
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}

/**
 * @private
 */
function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}

/**
 * @private
 */
const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");

/**
 * @private
 */
const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

/**
 * @private
 */
const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;

/**
 * @private
 */
const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */
const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");

    // Set up an AbortController + Promise we can race against to exit early
    // cancellation
    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key);

    // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject
    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));

    // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values
    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }

    // If the promise was resolved/rejected with undefined, we'll throw an error as you
    // should always resolve with a value or null
    if (error === undefined && data === undefined) {
      let undefinedError = new Error("Deferred data for key \"" + key + "\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");
      Object.defineProperty(promise, "_error", {
        get: () => undefinedError
      });
      this.emit(false, key);
      return Promise.reject(undefinedError);
    }
    if (data === undefined) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref3) => {
      let [key, value] = _ref3;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};

/**
 * A redirect response that will force a document reload to the new location.
 * Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 *
 * We don't export the class for public use since it's an implementation
 * detail, but we export the interface above so folks can build their own
 * abstractions around instances via isRouteErrorResponse()
 */
class ErrorResponseImpl {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}

/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * A Router instance manages all navigation and data loading/mutations
 */
/**
 * State maintained internally by the router.  During a navigation, all states
 * reflect the the "old" location unless otherwise noted.
 */
/**
 * Data that can be passed into hydrate a Router from SSR
 */
/**
 * Future flags to toggle new feature behavior
 */
/**
 * Initialization options for createRouter
 */
/**
 * State returned from a server-side query() call
 */
/**
 * A StaticHandler instance manages a singular SSR navigation/fetch event
 */
/**
 * Subscriber function signature for changes to router state
 */
/**
 * Function signature for determining the key to be used in scroll restoration
 * for a given location
 */
/**
 * Function signature for determining the current scroll position
 */
// Allowed for any navigation or fetch
// Only allowed for navigations
// Only allowed for submission navigations
/**
 * Options for a navigate() call for a normal (non-submission) navigation
 */
/**
 * Options for a navigate() call for a submission navigation
 */
/**
 * Options to pass to navigate() for a navigation
 */
/**
 * Options for a fetch() load
 */
/**
 * Options for a fetch() submission
 */
/**
 * Options to pass to fetch()
 */
/**
 * Potential states for state.navigation
 */
/**
 * Potential states for fetchers
 */
/**
 * Cached info for active fetcher.load() instances so they can participate
 * in revalidation
 */
/**
 * Identified fetcher.load() calls that need to be revalidated
 */
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = route => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";

//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;
  const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser;
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties;
  if (init.mapRouteProperties) {
    mapRouteProperties = init.mapRouteProperties;
  } else if (init.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }

  // Routes keyed by ID
  let manifest = {};
  // Routes in tree format for matching
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let dataStrategyImpl = init.unstable_dataStrategy || defaultDataStrategy;
  // Config driven behavior flags
  let future = _extends({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false,
    unstable_skipActionErrorRevalidation: false
  }, init.future);
  // Cleanup function for history
  let unlistenHistory = null;
  // Externally-provided functions to call on all state changes
  let subscribers = new Set();
  // Externally-provided object to hold scroll restoration locations during routing
  let savedScrollPositions = null;
  // Externally-provided function to get scroll restoration keys
  let getScrollRestorationKey = null;
  // Externally-provided function to get current scroll position
  let getScrollPosition = null;
  // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized;
  let hasLazyRoutes = initialMatches.some(m => m.route.lazy);
  let hasLoaders = initialMatches.some(m => m.route.loader);
  if (hasLazyRoutes) {
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    initialized = false;
  } else if (!hasLoaders) {
    // If we've got no loaders to run, then we're good to go
    initialized = true;
  } else if (future.v7_partialHydration) {
    // If partial hydration is enabled, we're initialized so long as we were
    // provided with hydrationData for every route with a loader, and no loaders
    // were marked for explicit hydration
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    let isRouteInitialized = m => {
      // No loader, nothing to initialize
      if (!m.route.loader) {
        return true;
      }
      // Explicitly opting-in to running on hydration
      if (typeof m.route.loader === "function" && m.route.loader.hydrate === true) {
        return false;
      }
      // Otherwise, initialized if hydrated with data or an error
      return loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined;
    };

    // If errors exist, don't consider routes below the boundary
    if (errors) {
      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);
      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);
    } else {
      initialized = initialMatches.every(isRouteInitialized);
    }
  } else {
    // Without partial hydration - we're initialized if we were provided any
    // hydrationData - which is expected to be complete
    initialized = init.hydrationData != null;
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  };

  // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)
  let pendingAction = Action.Pop;

  // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?
  let pendingPreventScrollReset = false;

  // AbortController for the active navigation
  let pendingNavigationController;

  // Should the current navigation enable document.startViewTransition?
  let pendingViewTransitionEnabled = false;

  // Store applied view transitions so we can apply them on POP
  let appliedViewTransitions = new Map();

  // Cleanup function for persisting applied transitions to sessionStorage
  let removePageHideEventListener = null;

  // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted
  let isUninterruptedRevalidation = false;

  // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidator()
  //  - X-Remix-Revalidate (from redirect)
  let isRevalidationRequired = false;

  // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission
  let cancelledDeferredRoutes = [];

  // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation
  let cancelledFetcherLoads = [];

  // AbortControllers for any in-flight fetchers
  let fetchControllers = new Map();

  // Track loads based on the order in which they started
  let incrementingLoadId = 0;

  // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation
  let pendingNavigationLoadId = -1;

  // Fetchers that triggered data reloads as a result of their actions
  let fetchReloadIds = new Map();

  // Fetchers that triggered redirect navigations
  let fetchRedirectIds = new Set();

  // Most recent href/match for fetcher.load calls for fetchers
  let fetchLoadMatches = new Map();

  // Ref-count mounted fetchers so we know when it's ok to clean them up
  let activeFetchers = new Map();

  // Fetchers that have requested a delete when using v7_fetcherPersist,
  // they'll be officially removed after they return to idle
  let deletedFetchers = new Set();

  // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.
  let activeDeferreds = new Map();

  // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change
  let blockerFunctions = new Map();

  // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state
  let ignoreNextHistoryUpdate = false;

  // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();
  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1);

        // Put the blocker into a blocked state
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            });
            // Re-do the same POP navigation we just blocked
            init.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser) {
      // FIXME: This feels gross.  How can we cleanup the lines between
      // scrollRestoration/appliedTransitions persistance?
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }

    // Kick off initial data load if needed.  Use Pop to avoid modifying history
    // Note we don't do any handling of lazy here.  For SPA's it'll get handled
    // in the normal navigation flow.  For SSR it's expected that lazy modules are
    // resolved prior to router creation since we can't go into a fallbackElement
    // UI for SSR'd apps
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location, {
        initialHydration: true
      });
    }
    return router;
  }

  // Clean up a router and it's side effects
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }

  // Subscribe to state updates for the router
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }

  // Update our state and notify the calling context of the change
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends({}, state, newState);

    // Prep fetcher cleanup so we can tell the UI which fetcher data entries
    // can be removed
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            // Unmounted from the UI and can be totally removed
            deletedFetchersKeys.push(key);
          } else {
            // Returned to idle but still mounted in the UI, so semi-remains for
            // revalidations and such
            completedFetchers.push(key);
          }
        }
      });
    }

    // Iterate over a local copy so that if flushSync is used and we end up
    // removing and adding a new subscriber due to the useCallback dependencies,
    // we don't get ourselves into a loop calling the new subscriber immediately
    [...subscribers].forEach(subscriber => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      unstable_viewTransitionOpts: opts.viewTransitionOpts,
      unstable_flushSync: opts.flushSync === true
    }));

    // Remove idle fetchers from state since we only care about in-flight fetchers.
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach(key => state.fetchers.delete(key));
      deletedFetchersKeys.forEach(key => deleteFetcher(key));
    }
  }

  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState
  function completeNavigation(location, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp;
    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    }

    // Always preserve any existing loaderData from re-used routes
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;

    // On a successful navigation we can assume we got through all blockers
    // so we can start fresh
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
    }

    // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = undefined;
    }
    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;

    // On POP, enable transitions if they were enabled on the original navigation
    if (pendingAction === Action.Pop) {
      // Forward takes precedence so they behave like the original navigation
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        // If we don't have a previous forward nav, assume we're popping back to
        // the new location and enable if that location previously enabled
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      // Store the applied transition on PUSH/REPLACE
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends({}, newState, {
      // matches, errors, fetchers go through as-is
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === true
    });

    // Reset stateful navigation vars
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }

  // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);

    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history
    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          });
          // Send the same navigation through
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.unstable_viewTransition,
      flushSync
    });
  }

  // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });

    // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders
    if (state.navigation.state === "submitting") {
      return;
    }

    // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }

    // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }

  // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation
  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;

    // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;

    // Short circuit with a 404 on the root error boundary if we match nothing
    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      // Cancel all pending deferred on 404s since we don't keep any routes
      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }

    // Short circuit if it's only a hash change and not a revalidation or
    // mutation submission.
    //
    // Ignore on initial page loads because since the initial load will always
    // be "same hash".  For example, on /page#hash and submit a <Form method="post">
    // which will default to a navigation to /page
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      }, {
        flushSync
      });
      return;
    }

    // Create a controller/Request for this navigation
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionResult;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingActionResult = [findNearestBoundary(matches).route.id, {
        type: ResultType.error,
        error: opts.pendingError
      }];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionResult = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace,
        flushSync
      });
      if (actionResult.shortCircuited) {
        return;
      }
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;

      // Create a GET request for the loaders
      request = createClientSideRequest(init.history, request.url, request.signal);
    }

    // Call loaders
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
    if (shortCircuited) {
      return;
    }

    // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation
    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, getActionDataForCommit(pendingActionResult), {
      loaderData,
      errors
    }));
  }

  // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors
  async function handleAction(request, location, submission, matches, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();

    // Put us in a submitting state
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });

    // Call our action and get the result
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches);
      result = results[0];
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        let location = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
        replace = location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);

      // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      pendingActionResult: [actionMatch.route.id, result]
    };
  }

  // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);

    // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.unstable_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);

    // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op
    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;

    // Short circuit if we have no loaders to run
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers = markFetchRedirectsDone();
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null
      }, getActionDataForCommit(pendingActionResult), updatedFetchers ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }

    // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)
    // If we have partialHydration enabled, then don't update the state for the
    // initial data load since it's not a "navigation"
    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData;
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        // This is cast to `any` currently because `RouteData`uses any and it
        // would be a breaking change to use any.
        // TODO: v7 - change `RouteData` to use `unknown` instead of `any`
        actionData = {
          [pendingActionResult[0]]: pendingActionResult[1].data
        };
      } else if (state.actionData) {
        if (Object.keys(state.actionData).length === 0) {
          actionData = null;
        } else {
          actionData = state.actionData;
        }
      }
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData !== undefined ? {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
    }
    revalidatingFetchers.forEach(rf => {
      if (fetchControllers.has(rf.key)) {
        abortFetcher(rf.key);
      }
      if (rf.controller) {
        // Fetchers use an independent AbortController so that aborting a fetcher
        // (via deleteFetcher) does not abort the triggering navigation that
        // triggered the revalidation
        fetchControllers.set(rf.key, rf.controller);
      }
    });

    // Proxy navigation abort through to revalidation fetchers
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }

    // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));

    // If any loaders returned a redirect Response, start a new REPLACE navigation
    let redirect = findRedirect([...loaderResults, ...fetcherResults]);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(request, redirect.result, {
        replace
      });
      return {
        shortCircuited: true
      };
    }

    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);

    // Wire up subscribers to update loaderData as promises settle
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });

    // During partial hydration, preserve SSR errors for routes that don't re-run
    if (future.v7_partialHydration && initialHydration && state.errors) {
      Object.entries(state.errors).filter(_ref2 => {
        let [id] = _ref2;
        return !matchesToLoad.some(m => m.route.id === id);
      }).forEach(_ref3 => {
        let [routeId, error] = _ref3;
        errors = Object.assign(errors || {}, {
          [routeId]: error
        });
      });
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends({
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }

  // Trigger a fetcher load/submit for the given fetcher key
  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);
      return;
    }

    // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);
  }

  // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation
  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action && !match.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }

    // Put this fetcher into it's submitting state
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });

    // Call the action for the fetcher
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy("action", fetchRequest, [match], requestMatches);
    let actionResult = actionResults[0];
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }

    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI
    // or redirects processed for unmounted fetchers so we just revert them to
    // idle
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      }
      // Let SuccessResult's fall through for revalidation
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          // A new navigation was kicked off after our action started, so that
          // should take precedence over this redirect navigation.  We already
          // set isRevalidationRequired so all loaders for the new route should
          // fire unless opted out via shouldRevalidate
          updateFetcherState(key, getDoneFetcher(undefined));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, {
            fetcherSubmission: submission
          });
        }
      }

      // Process any non-redirect errors thrown
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }

    // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.unstable_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);

    // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data
    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect([...loaderResults, ...fetcherResults]);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(revalidationRequest, redirect.result);
    }

    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);

    // Since we let revalidations complete even if the submitting fetcher was
    // deleted, only put it back to idle if it hasn't been deleted
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);

    // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }

  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.
  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {
      flushSync
    });

    // Call the loader for this fetcher route match
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy("loader", fetchRequest, [match], matches);
    let result = results[0];

    // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens
    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    }

    // We can delete this so long as we weren't aborted by our our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }

    // We don't want errors bubbling up or redirects followed for unmounted
    // fetchers, so short circuit here if it was removed from the UI
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(undefined));
      return;
    }

    // If the loader threw a redirect Response, start a new REPLACE navigation
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        // A new navigation was kicked off after our loader started, so that
        // should take precedence over this redirect navigation
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result);
        return;
      }
    }

    // Process any non-redirect errors thrown
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");

    // Put the fetcher back into an idle state
    updateFetcherState(key, getDoneFetcher(result.data));
  }

  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */
  async function startRedirectNavigation(request, redirect, _temp2) {
    let {
      submission,
      fetcherSubmission,
      replace
    } = _temp2 === void 0 ? {} : _temp2;
    if (redirect.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(location, new URL(request.url), basename);
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser) {
      let isDocumentReload = false;
      if (redirect.response.headers.has("X-Remix-Reload-Document")) {
        // Hard reload if the response contained X-Remix-Reload-Document
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(location)) {
        const url = init.history.createURL(location);
        isDocumentReload =
        // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin ||
        // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }

    // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled
    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;

    // Use the incoming submission if provided, fallback on the active one in
    // state.navigation
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }

    // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, activeSubmission, {
          formAction: location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // If we have a navigation submission, we will preserve it through the
      // redirect navigation
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }

  // Utility wrapper for calling dataStrategy client-side without having to
  // pass around the manifest, mapRouteProperties, etc.
  async function callDataStrategy(type, request, matchesToLoad, matches) {
    try {
      let results = await callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties);
      return await Promise.all(results.map((result, i) => {
        if (isRedirectHandlerResult(result)) {
          let response = result.result;
          return {
            type: ResultType.redirect,
            response: normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath)
          };
        }
        return convertHandlerResultToDataResult(result);
      }));
    } catch (e) {
      // If the outer dataStrategy method throws, just return the error for all
      // matches - and it'll naturally bubble to the root
      return matchesToLoad.map(() => ({
        type: ResultType.error,
        error: e
      }));
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    let [loaderResults, ...fetcherResults] = await Promise.all([matchesToLoad.length ? callDataStrategy("loader", request, matchesToLoad, matches) : [], ...fetchersToLoad.map(f => {
      if (f.matches && f.match && f.controller) {
        let fetcherRequest = createClientSideRequest(init.history, f.path, f.controller.signal);
        return callDataStrategy("loader", fetcherRequest, [f.match], f.matches).then(r => r[0]);
      } else {
        return Promise.resolve({
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        });
      }
    })]);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true;

    // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());

    // Abort in-flight fetcher loads
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    if (future.v7_fetcherPersist) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      // If this fetcher was previously marked for deletion, unmark it since we
      // have a new instance
      if (deletedFetchers.has(key)) {
        deletedFetchers.delete(key);
      }
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    // Don't abort the controller if this is a deletion of a fetcher.submit()
    // in it's loading phase since - we don't want to abort the corresponding
    // revalidation and want them to complete and land
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    deletedFetchers.delete(key);
    state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    if (future.v7_fetcherPersist) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        deletedFetchers.add(key);
      } else {
        activeFetchers.set(key, count);
      }
    } else {
      deleteFetcher(key);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }

  // Utility function to update blockers, ensuring valid state transitions
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;

    // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref4) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref4;
    if (blockerFunctions.size === 0) {
      return;
    }

    // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    }

    // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }

  // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;

    // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");

/**
 * Future flags to toggle new feature behavior
 */

function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties;
  if (opts != null && opts.mapRouteProperties) {
    mapRouteProperties = opts.mapRouteProperties;
  } else if (opts != null && opts.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = opts.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Config driven behavior flags
  let future = _extends({
    v7_relativeSplatPath: false,
    v7_throwAbortReason: false
  }, opts ? opts.future : null);
  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);

  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   *
   * - `opts.requestContext` is an optional server context that will be passed
   *   to actions/loaders in the `context` parameter
   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent
   *   the bubbling of errors which allows single-fetch-type implementations
   *   where the client will handle the bubbling and we may need to return data
   *   for the handling route
   */
  async function query(request, _temp3) {
    let {
      requestContext,
      skipLoaderErrorBubbling,
      unstable_dataStrategy
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);

    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext, unstable_dataStrategy || null, skipLoaderErrorBubbling === true, null);
    if (isResponse(result)) {
      return result;
    }

    // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location
    return _extends({
      location,
      basename
    }, result);
  }

  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   *
   * - `opts.routeId` allows you to specify the specific route handler to call.
   *   If not provided the handler will determine the proper route by matching
   *   against `request.url`
   * - `opts.requestContext` is an optional server context that will be passed
   *    to actions/loaders in the `context` parameter
   */
  async function queryRoute(request, _temp4) {
    let {
      routeId,
      requestContext,
      unstable_dataStrategy
    } = _temp4 === void 0 ? {} : _temp4;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);

    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, unstable_dataStrategy || null, false, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    }

    // Pick off the right state value to return
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction for a
      // `queryRoute` call, we throw the `HandlerResult` to bail out early
      // and then return or throw the raw Response here accordingly
      if (isHandlerResult(e) && isResponse(e.result)) {
        if (e.type === ResultType.error) {
          throw e.result;
        }
        return e.result;
      }
      // Redirects are always returned since they don't propagate to catch
      // boundaries
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches, isRouteRequest, requestContext, unstable_dataStrategy);
      result = results[0];
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest, future);
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.response.status,
        headers: {
          Location: result.response.headers.get("Location")
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }

    // Create a GET request for the loaders
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(loaderRequest, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, null, [boundaryMatch.route.id, result]);

      // action status codes take precedence over loader status codes
      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    }
    let context = await loadRouteData(loaderRequest, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, null);
    return _extends({}, context, {
      actionData: {
        [actionMatch.route.id]: result.data
      }
    }, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionHeaders: result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {}
    });
  }
  async function loadRouteData(request, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {
    let isRouteRequest = routeMatch != null;

    // Short circuit if we have no loaders to run (queryRoute())
    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;
    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);

    // Short circuit if we have no loaders to run (query())
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await callDataStrategy("loader", request, matchesToLoad, matches, isRouteRequest, requestContext, unstable_dataStrategy);
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest, future);
    }

    // Process and commit output from loaders
    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling);

    // Add a null for any non-loader matches for proper revalidation on the client
    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }

  // Utility wrapper for calling dataStrategy server-side without having to
  // pass around the manifest, mapRouteProperties, etc.
  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, unstable_dataStrategy) {
    let results = await callDataStrategyImpl(unstable_dataStrategy || defaultDataStrategy, type, request, matchesToLoad, matches, manifest, mapRouteProperties, requestContext);
    return await Promise.all(results.map((result, i) => {
      if (isRedirectHandlerResult(result)) {
        let response = result.result;
        // Throw redirects and let the server handle them with an HTTP redirect
        throw normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath);
      }
      if (isResponse(result.result) && isRouteRequest) {
        // For SSR single-route requests, we want to hand Responses back
        // directly without unwrapping
        throw result;
      }
      return convertHandlerResultToDataResult(result);
    }));
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}

//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */
function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function throwStaticHandlerAbortedError(request, isRouteRequest, future) {
  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(method + "() call aborted: " + request.method + " " + request.url);
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);
}
function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    // Grab matches up to the calling route so our route-relative logic is
    // relative to the correct source route
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }

  // Resolve the relative path
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");

  // When `to` is not specified we inherit search/hash from the current
  // location, unlike when to="." and we just inherit the path.
  // See https://github.com/remix-run/remix/issues/927
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }

  // Add an ?index param for matched index routes if we don't already have one
  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }

  // If we're operating within a basename, prepend it to the pathname.  If
  // this is a root navigation, then just use the raw basename which allows
  // the basename to have full control over the presence of a trailing slash
  // on root actions
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}

// Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  // Return location verbatim on non-submission navigations
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });

  // Create a Submission on non-GET navigations
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== undefined) {
    if (opts.formEncType === "text/plain") {
      // text only support POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?
      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
      Array.from(opts.body.entries()).reduce((acc, _ref5) => {
        let [name, value] = _ref5;
        return "" + acc + name + "=" + value + "\n";
      }, "") : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: undefined,
          json: undefined,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      // json only supports POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: undefined,
            json,
            text: undefined
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: undefined,
    text: undefined
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }

  // Flatten submission onto URLSearchParams for GET submissions
  let parsedPath = parsePath(path);
  // On GET navigation submissions we can drop the ?index param from the
  // resulting location since all loaders will run.  But fetcher GET submissions
  // only run a single loader so we need to preserve any incoming ?index params
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}

// Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);

  // Pick navigation matches that are net-new or qualify for revalidation
  let boundaryId = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[0] : undefined;
  let boundaryMatches = boundaryId ? getLoaderMatchesUntilBoundary(matches, boundaryId) : matches;

  // Don't revalidate loaders by default after action 4xx/5xx responses
  // when the flag is enabled.  They can still opt-into revalidation via
  // `shouldRevalidate` via `actionResult`
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : undefined;
  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let {
      route
    } = match;
    if (route.lazy) {
      // We haven't loaded this route yet so we don't know if it's got a loader!
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (isInitialLoad) {
      if (typeof route.loader !== "function" || route.loader.hydrate) {
        return true;
      }
      return state.loaderData[route.id] === undefined && (
      // Don't re-run if the loader ran and threw an error
      !state.errors || state.errors[route.id] === undefined);
    }

    // Always call the loader on new route instances and pending defer cancellations
    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    }

    // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      unstable_actionStatus: actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false :
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||
      // Search params affect all loaders
      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  });

  // Pick fetcher.loads that need to be revalidated
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    // Don't revalidate:
    //  - on initial load (shouldn't be any fetchers then anyway)
    //  - if fetcher won't be present in the subsequent render
    //    - no longer matches the URL (v7_fetcherPersist=false)
    //    - was unmounted but persisted due to v7_fetcherPersist=true
    if (isInitialLoad || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);

    // If the fetcher path no longer matches, push it in with null matches so
    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is
    // currently only a use-case for Remix HMR where the route tree can change
    // at runtime and remove a route previously loaded via a fetcher
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }

    // Revalidating fetchers are decoupled from the route matches since they
    // load from a static href.  They revalidate based on explicit revalidation
    // (submission, useRevalidator, or X-Remix-Revalidate)
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      // Never trigger a revalidation of an actively redirecting fetcher
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      // Always revalidate if the fetcher was cancelled
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {
      // If the fetcher hasn't ever completed loading yet, then this isn't a
      // revalidation, it would just be a brand new load if an explicit
      // revalidation is required
      shouldRevalidate = isRevalidationRequired;
    } else {
      // Otherwise fall back on any user-defined shouldRevalidate, defaulting
      // to explicit revalidations only
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        unstable_actionStatus: actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id;

  // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred
  let isMissingData = currentLoaderData[match.route.id] === undefined;

  // Always load if this is a net-new route or we don't yet have data
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}

/**
 * Execute route.lazy() methods to lazily load route modules (loader, action,
 * shouldRevalidate) and update the routeManifest in place which shares objects
 * with dataRoutes so those get updated as well.
 */
async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();

  // If the lazy route function was executed and removed by another parallel
  // call then we can return - first lazy() to finish wins because the return
  // value of lazy is expected to be static
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");

  // Update the route in place.  This should be safe because there's no way
  // we could yet be sitting on this route as we can't get there without
  // resolving lazy() first.
  //
  // This is different than the HMR "update" use-case where we may actively be
  // on the route being updated.  The main concern boils down to "does this
  // mutation affect any ongoing navigations or any current state.matches
  // values?".  If not, it should be safe to update in place.
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, "Route \"" + routeToUpdate.id + "\" has a static property \"" + lazyRouteProperty + "\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \"" + lazyRouteProperty + "\" will be ignored."));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }

  // Mutate the route with the provided updates.  Do this first so we pass
  // the updated version to mapRouteProperties
  Object.assign(routeToUpdate, routeUpdates);

  // Mutate the `hasErrorBoundary` property on the route based on the route
  // updates and remove the `lazy` function so we don't resolve the lazy
  // route again.
  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
    lazy: undefined
  }));
}

// Default implementation of `dataStrategy` which fetches all loaders in parallel
function defaultDataStrategy(opts) {
  return Promise.all(opts.matches.map(m => m.resolve()));
}
async function callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties, requestContext) {
  let routeIdsToLoad = matchesToLoad.reduce((acc, m) => acc.add(m.route.id), new Set());
  let loadedMatches = new Set();

  // Send all matches here to allow for a middleware-type implementation.
  // handler will be a no-op for unneeded routes and we filter those results
  // back out below.
  let results = await dataStrategyImpl({
    matches: matches.map(match => {
      let shouldLoad = routeIdsToLoad.has(match.route.id);
      // `resolve` encapsulates the route.lazy, executing the
      // loader/action, and mapping return values/thrown errors to a
      // HandlerResult.  Users can pass a callback to take fine-grained control
      // over the execution of the loader/action
      let resolve = handlerOverride => {
        loadedMatches.add(match.route.id);
        return shouldLoad ? callLoaderOrAction(type, request, match, manifest, mapRouteProperties, handlerOverride, requestContext) : Promise.resolve({
          type: ResultType.data,
          result: undefined
        });
      };
      return _extends({}, match, {
        shouldLoad,
        resolve
      });
    }),
    request,
    params: matches[0].params,
    context: requestContext
  });

  // Throw if any loadRoute implementations not called since they are what
  // ensures a route is fully loaded
  matches.forEach(m => invariant(loadedMatches.has(m.route.id), "`match.resolve()` was not called for route id \"" + m.route.id + "\". " + "You must call `match.resolve()` on every match passed to " + "`dataStrategy` to ensure all routes are properly loaded."));

  // Filter out any middleware-only matches for which we didn't need to run handlers
  return results.filter((_, i) => routeIdsToLoad.has(matches[i].route.id));
}

// Default logic for calling a loader/action is the user has no specified a dataStrategy
async function callLoaderOrAction(type, request, match, manifest, mapRouteProperties, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = handler => {
    // Setup a promise we can race against so that abort signals short circuit
    let reject;
    // This will never resolve so safe to type it as Promise<HandlerResult> to
    // satisfy the function return value
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = ctx => {
      if (typeof handler !== "function") {
        return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ("\"" + type + "\" [routeId: " + match.route.id + "]")));
      }
      return handler({
        request,
        params: match.params,
        context: staticContext
      }, ...(ctx !== undefined ? [ctx] : []));
    };
    let handlerPromise;
    if (handlerOverride) {
      handlerPromise = handlerOverride(ctx => actualHandler(ctx));
    } else {
      handlerPromise = (async () => {
        try {
          let val = await actualHandler();
          return {
            type: "data",
            result: val
          };
        } catch (e) {
          return {
            type: "error",
            result: e
          };
        }
      })();
    }
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        // Run statically defined handler in parallel with lazy()
        let handlerError;
        let [value] = await Promise.all([
        // If the handler throws, don't let it immediately bubble out,
        // since we need to let the lazy() execution finish so we know if this
        // route has a boundary that can handle the error
        runHandler(handler).catch(e => {
          handlerError = e;
        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);
        if (handlerError !== undefined) {
          throw handlerError;
        }
        result = value;
      } else {
        // Load lazy route module, then run any returned handler
        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);
        handler = match.route[type];
        if (handler) {
          // Handler still runs even if we got interrupted to maintain consistency
          // with un-abortable behavior of handler execution on non-lazy or
          // previously-lazy-loaded routes
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          // lazy() route has no loader to run.  Short circuit here so we don't
          // hit the invariant below that errors on returning undefined.
          return {
            type: ResultType.data,
            result: undefined
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result.result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    // We should already be catching and converting normal handler executions to
    // HandlerResults and returning them, so anything that throws here is an
    // unexpected error we still need to wrap
    return {
      type: ResultType.error,
      result: e
    };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertHandlerResultToDataResult(handlerResult) {
  let {
    result,
    type,
    status
  } = handlerResult;
  if (isResponse(result)) {
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      // Check between word boundaries instead of startsWith() due to the last
      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e) {
      return {
        type: ResultType.error,
        error: e
      };
    }
    if (type === ResultType.error) {
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(result.status, result.statusText, data),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === ResultType.error) {
    return {
      type: ResultType.error,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : status
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result,
    statusCode: status
  };
}

// Support relative routing in internal redirects
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
  let location = response.headers.get("Location");
  invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
  if (!ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1);
    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);
    response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    // Strip off the protocol+origin for same-origin + same-basename absolute redirects
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}

// Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    // Didn't think we needed this but it turns out unlike other methods, patch
    // won't be properly normalized to uppercase and results in a 405 error.
    // See: https://fetch.spec.whatwg.org/#concept-method
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : undefined;

  // Process loader results into state.loaderData/state.errors
  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let error = result.error;
      // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed
      if (pendingError !== undefined) {
        error = pendingError;
        pendingError = undefined;
      }
      errors = errors || {};
      if (skipLoaderErrorBubbling) {
        errors[id] = error;
      } else {
        // Look upwards from the matched route for the closest ancestor error
        // boundary, defaulting to the root match.  Prefer higher error values
        // if lower errors bubble to the same boundary
        let boundaryMatch = findNearestBoundary(matches, id);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }

      // Clear our any prior loaderData for the throwing route
      loaderData[id] = undefined;

      // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
        // Error status codes always override success status codes, but if all
        // loaders are successful we take the deepest status code.
        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      } else {
        loaderData[id] = result.data;
        // Error status codes always override success status codes, but if all
        // loaders are successful we take the deepest status code.
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      }
    }
  });

  // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route
  if (pendingError !== undefined && pendingActionResult) {
    errors = {
      [pendingActionResult[0]]: pendingError
    };
    loaderData[pendingActionResult[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, false // This method is only called client side so we always want to bubble
  );

  // Process results from our revalidating fetchers
  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match,
      controller
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index];

    // Process fetcher non-redirect errors
    if (controller && controller.signal.aborted) {
      // Nothing to do for aborted fetchers
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined && match.route.loader) {
      // Preserve existing keys not included in newLoaderData and where a loader
      // wasn't removed by HMR
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}

// Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp5 === void 0 ? {} : _temp5;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}

// Find any returned redirect errors, starting from the lowest match
function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    // /page -> /page#hash
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    // /page#hash -> /page#hash
    return true;
  } else if (b.hash !== "") {
    // /page#hash -> /page#other
    return true;
  }

  // If the hash is removed the browser will re-perform a request to the server
  // /page#hash -> /page
  return false;
}
function isHandlerResult(result) {
  return result != null && typeof result === "object" && "type" in result && "result" in result && (result.type === ResultType.data || result.type === ResultType.error);
}
function isRedirectHandlerResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    // If we don't have a match, then we can have a deferred result to do
    // anything with.  This is for revalidating fetchers where the route was
    // removed during HMR
    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      let signal = signals[index];
      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  }
  // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json: undefined,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: undefined,
      text: undefined
    };
  } else if (json !== undefined) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json,
      text: undefined
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined,
      data
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : undefined
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: undefined,
    formAction: undefined,
    formEncType: undefined,
    formData: undefined,
    json: undefined,
    text: undefined,
    data
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {
    // no-op, use default empty object
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}

//#endregion

exports.AbortedDeferredError = AbortedDeferredError;
exports.Action = Action;
exports.IDLE_BLOCKER = IDLE_BLOCKER;
exports.IDLE_FETCHER = IDLE_FETCHER;
exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
exports.UNSAFE_DeferredData = DeferredData;
exports.UNSAFE_ErrorResponseImpl = ErrorResponseImpl;
exports.UNSAFE_convertRouteMatchToUiMatch = convertRouteMatchToUiMatch;
exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
exports.UNSAFE_getResolveToMatches = getResolveToMatches;
exports.UNSAFE_invariant = invariant;
exports.UNSAFE_warning = warning;
exports.createBrowserHistory = createBrowserHistory;
exports.createHashHistory = createHashHistory;
exports.createMemoryHistory = createMemoryHistory;
exports.createPath = createPath;
exports.createRouter = createRouter;
exports.createStaticHandler = createStaticHandler;
exports.defer = defer;
exports.generatePath = generatePath;
exports.getStaticContextFromError = getStaticContextFromError;
exports.getToPathname = getToPathname;
exports.isDeferredData = isDeferredData;
exports.isRouteErrorResponse = isRouteErrorResponse;
exports.joinPaths = joinPaths;
exports.json = json;
exports.matchPath = matchPath;
exports.matchRoutes = matchRoutes;
exports.normalizePathname = normalizePathname;
exports.parsePath = parsePath;
exports.redirect = redirect;
exports.redirectDocument = redirectDocument;
exports.resolvePath = resolvePath;
exports.resolveTo = resolveTo;
exports.stripBasename = stripBasename;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJBY3Rpb24iLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJvcHRpb25zIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJsZW5ndGgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJrZXkiLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfZXh0ZW5kcyIsIl9yZWYiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiLCJnZXRMb2NhdGlvbiIsInZhbGlkYXRlTG9jYXRpb24iLCJkZWZhdWx0VmlldyIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJET01FeGNlcHRpb24iLCJuYW1lIiwiYXNzaWduIiwib3JpZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZXN1bHRUeXBlIiwiaW1tdXRhYmxlUm91dGVLZXlzIiwiU2V0IiwiaXNJbmRleFJvdXRlIiwicm91dGUiLCJjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwicm91dGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsIm1hdGNoUm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJpIiwiZGVjb2RlZCIsImRlY29kZVBhdGgiLCJtYXRjaFJvdXRlQnJhbmNoIiwiY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJtYXRjaCIsImxvYWRlckRhdGEiLCJwYXJhbXMiLCJkYXRhIiwiaGFuZGxlIiwicGFyZW50c01ldGEiLCJmbGF0dGVuUm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJtZXRhIiwiY2FzZVNlbnNpdGl2ZSIsImNoaWxkcmVuSW5kZXgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2hQYXRoIiwiT2JqZWN0IiwicGF0aG5hbWVCYXNlIiwibm9ybWFsaXplUGF0aG5hbWUiLCJnZW5lcmF0ZVBhdGgiLCJvcmlnaW5hbFBhdGgiLCJwcmVmaXgiLCJwIiwiU3RyaW5nIiwiYXJyYXkiLCJpc0xhc3RTZWdtZW50Iiwic3RhciIsImtleU1hdGNoIiwib3B0aW9uYWwiLCJwYXJhbSIsInBhdHRlcm4iLCJtYXRjaGVyIiwiY29tcGlsZWRQYXJhbXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJ2IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJyZXNvbHZlUGF0aCIsImZyb21QYXRobmFtZSIsInRvUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImdldEludmFsaWRQYXRoRXJyb3IiLCJjaGFyIiwiZmllbGQiLCJkZXN0IiwiZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJnZXRSZXNvbHZlVG9NYXRjaGVzIiwidjdfcmVsYXRpdmVTcGxhdFBhdGgiLCJwYXRoTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJpbml0IiwicmVzcG9uc2VJbml0Iiwic3RhdHVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJSZXNwb25zZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiRGVmZXJyZWREYXRhIiwiY29uc3RydWN0b3IiLCJwZW5kaW5nS2V5c1NldCIsInN1YnNjcmliZXJzIiwiZGVmZXJyZWRLZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiYWJvcnRQcm9taXNlIiwiUHJvbWlzZSIsInIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25BYm9ydCIsInVubGlzdGVuQWJvcnRTaWduYWwiLCJzaWduYWwiLCJhY2MiLCJfcmVmMiIsInRyYWNrUHJvbWlzZSIsImRvbmUiLCJhZGQiLCJwcm9taXNlIiwicmFjZSIsInRoZW4iLCJvblNldHRsZSIsImNhdGNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwiZGVsZXRlIiwidW5kZWZpbmVkRXJyb3IiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsImsiLCJyZXNvbHZlRGF0YSIsInJlc29sdmUiLCJzaXplIiwidW53cmFwcGVkRGF0YSIsIl9yZWYzIiwidW53cmFwVHJhY2tlZFByb21pc2UiLCJwZW5kaW5nS2V5cyIsImlzVHJhY2tlZFByb21pc2UiLCJfdHJhY2tlZCIsIl9lcnJvciIsIl9kYXRhIiwiZGVmZXIiLCJyZWRpcmVjdCIsInJlZGlyZWN0RG9jdW1lbnQiLCJyZXNwb25zZSIsIkVycm9yUmVzcG9uc2VJbXBsIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJ2YWxpZE11dGF0aW9uTWV0aG9kc0FyciIsInZhbGlkTXV0YXRpb25NZXRob2RzIiwidmFsaWRSZXF1ZXN0TWV0aG9kc0FyciIsInZhbGlkUmVxdWVzdE1ldGhvZHMiLCJyZWRpcmVjdFN0YXR1c0NvZGVzIiwicmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzIiwiSURMRV9OQVZJR0FUSU9OIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1EYXRhIiwidGV4dCIsIklETEVfRkVUQ0hFUiIsIklETEVfQkxPQ0tFUiIsInByb2NlZWQiLCJyZXNldCIsIkFCU09MVVRFX1VSTF9SRUdFWCIsImRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXMiLCJoYXNFcnJvckJvdW5kYXJ5IiwiQm9vbGVhbiIsIlRSQU5TSVRJT05TX1NUT1JBR0VfS0VZIiwiY3JlYXRlUm91dGVyIiwicm91dGVyV2luZG93IiwiaXNCcm93c2VyIiwiY3JlYXRlRWxlbWVudCIsImlzU2VydmVyIiwiZGV0ZWN0RXJyb3JCb3VuZGFyeSIsImRhdGFSb3V0ZXMiLCJpbkZsaWdodERhdGFSb3V0ZXMiLCJkYXRhU3RyYXRlZ3lJbXBsIiwidW5zdGFibGVfZGF0YVN0cmF0ZWd5IiwiZGVmYXVsdERhdGFTdHJhdGVneSIsImZ1dHVyZSIsInY3X2ZldGNoZXJQZXJzaXN0Iiwidjdfbm9ybWFsaXplRm9ybU1ldGhvZCIsInY3X3BhcnRpYWxIeWRyYXRpb24iLCJ2N19wcmVwZW5kQmFzZW5hbWUiLCJ1bnN0YWJsZV9za2lwQWN0aW9uRXJyb3JSZXZhbGlkYXRpb24iLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5IiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJpbml0aWFsU2Nyb2xsUmVzdG9yZWQiLCJoeWRyYXRpb25EYXRhIiwiaW5pdGlhbE1hdGNoZXMiLCJpbml0aWFsRXJyb3JzIiwiZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvciIsImdldFNob3J0Q2lyY3VpdE1hdGNoZXMiLCJpbml0aWFsaXplZCIsImhhc0xhenlSb3V0ZXMiLCJtIiwibGF6eSIsImhhc0xvYWRlcnMiLCJsb2FkZXIiLCJlcnJvcnMiLCJpc1JvdXRlSW5pdGlhbGl6ZWQiLCJoeWRyYXRlIiwiZmluZEluZGV4Iiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJhY3Rpb25EYXRhIiwiZmV0Y2hlcnMiLCJNYXAiLCJibG9ja2VycyIsInBlbmRpbmdBY3Rpb24iLCJwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0IiwicGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIiwicGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCIsImFwcGxpZWRWaWV3VHJhbnNpdGlvbnMiLCJyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIiLCJpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJpc1JldmFsaWRhdGlvblJlcXVpcmVkIiwiY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMiLCJjYW5jZWxsZWRGZXRjaGVyTG9hZHMiLCJmZXRjaENvbnRyb2xsZXJzIiwiaW5jcmVtZW50aW5nTG9hZElkIiwicGVuZGluZ05hdmlnYXRpb25Mb2FkSWQiLCJmZXRjaFJlbG9hZElkcyIsImZldGNoUmVkaXJlY3RJZHMiLCJmZXRjaExvYWRNYXRjaGVzIiwiYWN0aXZlRmV0Y2hlcnMiLCJkZWxldGVkRmV0Y2hlcnMiLCJhY3RpdmVEZWZlcnJlZHMiLCJibG9ja2VyRnVuY3Rpb25zIiwiaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUiLCJpbml0aWFsaXplIiwiYmxvY2tlcktleSIsInNob3VsZEJsb2NrTmF2aWdhdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsInVwZGF0ZUJsb2NrZXIiLCJ1cGRhdGVTdGF0ZSIsInN0YXJ0TmF2aWdhdGlvbiIsInJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMiLCJfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyIsInBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMiLCJpbml0aWFsSHlkcmF0aW9uIiwiZGlzcG9zZSIsImNsZWFyIiwiZGVsZXRlRmV0Y2hlciIsImRlbGV0ZUJsb2NrZXIiLCJuZXdTdGF0ZSIsIm9wdHMiLCJjb21wbGV0ZWRGZXRjaGVycyIsImRlbGV0ZWRGZXRjaGVyc0tleXMiLCJmZXRjaGVyIiwidW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzIiwidmlld1RyYW5zaXRpb25PcHRzIiwidW5zdGFibGVfZmx1c2hTeW5jIiwiZmx1c2hTeW5jIiwiY29tcGxldGVOYXZpZ2F0aW9uIiwiX3RlbXAiLCJfbG9jYXRpb24kc3RhdGUiLCJfbG9jYXRpb24kc3RhdGUyIiwiaXNBY3Rpb25SZWxvYWQiLCJpc011dGF0aW9uTWV0aG9kIiwiX2lzUmVkaXJlY3QiLCJrZXlzIiwibWVyZ2VMb2FkZXJEYXRhIiwicHJpb3JQYXRocyIsInRvUGF0aHMiLCJnZXRTYXZlZFNjcm9sbFBvc2l0aW9uIiwibmF2aWdhdGUiLCJub3JtYWxpemVkUGF0aCIsIm5vcm1hbGl6ZVRvIiwiZnJvbVJvdXRlSWQiLCJyZWxhdGl2ZSIsInN1Ym1pc3Npb24iLCJub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMiLCJ1c2VyUmVwbGFjZSIsInBlbmRpbmdFcnJvciIsImVuYWJsZVZpZXdUcmFuc2l0aW9uIiwidW5zdGFibGVfdmlld1RyYW5zaXRpb24iLCJyZXZhbGlkYXRlIiwiaW50ZXJydXB0QWN0aXZlTG9hZHMiLCJzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJvdmVycmlkZU5hdmlnYXRpb24iLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJyb3V0ZXNUb1VzZSIsImxvYWRpbmdOYXZpZ2F0aW9uIiwibm90Rm91bmRNYXRjaGVzIiwiY2FuY2VsQWN0aXZlRGVmZXJyZWRzIiwiaXNIYXNoQ2hhbmdlT25seSIsInJlcXVlc3QiLCJjcmVhdGVDbGllbnRTaWRlUmVxdWVzdCIsInBlbmRpbmdBY3Rpb25SZXN1bHQiLCJmaW5kTmVhcmVzdEJvdW5kYXJ5IiwidHlwZSIsImFjdGlvblJlc3VsdCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwiZ2V0TG9hZGluZ05hdmlnYXRpb24iLCJoYW5kbGVMb2FkZXJzIiwiZmV0Y2hlclN1Ym1pc3Npb24iLCJnZXRBY3Rpb25EYXRhRm9yQ29tbWl0IiwiZ2V0U3VibWl0dGluZ05hdmlnYXRpb24iLCJhY3Rpb25NYXRjaCIsImdldFRhcmdldE1hdGNoIiwibWV0aG9kIiwicm91dGVJZCIsInJlc3VsdHMiLCJjYWxsRGF0YVN0cmF0ZWd5IiwiaXNSZWRpcmVjdFJlc3VsdCIsIm5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24iLCJzdGFydFJlZGlyZWN0TmF2aWdhdGlvbiIsImlzRGVmZXJyZWRSZXN1bHQiLCJpc0Vycm9yUmVzdWx0IiwiYm91bmRhcnlNYXRjaCIsImFjdGl2ZVN1Ym1pc3Npb24iLCJnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24iLCJtYXRjaGVzVG9Mb2FkIiwicmV2YWxpZGF0aW5nRmV0Y2hlcnMiLCJnZXRNYXRjaGVzVG9Mb2FkIiwidXBkYXRlZEZldGNoZXJzIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsInJmIiwicmV2YWxpZGF0aW5nRmV0Y2hlciIsImdldExvYWRpbmdGZXRjaGVyIiwiYWJvcnRGZXRjaGVyIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiZiIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsImZldGNoZXJLZXkiLCJwcm9jZXNzTG9hZGVyRGF0YSIsImRlZmVycmVkRGF0YSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwic2hvdWxkVXBkYXRlRmV0Y2hlcnMiLCJmZXRjaCIsInNldEZldGNoZXJFcnJvciIsImhhbmRsZUZldGNoZXJBY3Rpb24iLCJoYW5kbGVGZXRjaGVyTG9hZGVyIiwicmVxdWVzdE1hdGNoZXMiLCJleGlzdGluZ0ZldGNoZXIiLCJ1cGRhdGVGZXRjaGVyU3RhdGUiLCJnZXRTdWJtaXR0aW5nRmV0Y2hlciIsImFib3J0Q29udHJvbGxlciIsImZldGNoUmVxdWVzdCIsIm9yaWdpbmF0aW5nTG9hZElkIiwiYWN0aW9uUmVzdWx0cyIsImdldERvbmVGZXRjaGVyIiwicmV2YWxpZGF0aW9uUmVxdWVzdCIsImxvYWRJZCIsImxvYWRGZXRjaGVyIiwic3RhbGVLZXkiLCJkb25lRmV0Y2hlciIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcDIiLCJyZWRpcmVjdExvY2F0aW9uIiwiaXNEb2N1bWVudFJlbG9hZCIsInJlZGlyZWN0SGlzdG9yeUFjdGlvbiIsImNhbGxEYXRhU3RyYXRlZ3lJbXBsIiwiYWxsIiwiaXNSZWRpcmVjdEhhbmRsZXJSZXN1bHQiLCJub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlIiwiY29udmVydEhhbmRsZXJSZXN1bHRUb0RhdGFSZXN1bHQiLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiZmV0Y2hlclJlcXVlc3QiLCJyZXNvbHZlRGVmZXJyZWRSZXN1bHRzIiwiZ2V0RmV0Y2hlciIsImRlbGV0ZUZldGNoZXJBbmRVcGRhdGVTdGF0ZSIsImNvdW50IiwibWFya0ZldGNoZXJzRG9uZSIsImRvbmVLZXlzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwiZ2V0QmxvY2tlciIsImJsb2NrZXIiLCJuZXdCbG9ja2VyIiwiX3JlZjQiLCJibG9ja2VyRnVuY3Rpb24iLCJwcmVkaWNhdGUiLCJjYW5jZWxsZWRSb3V0ZUlkcyIsImRmZCIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJnZXRLZXkiLCJ5IiwiZ2V0U2Nyb2xsS2V5IiwiX2ludGVybmFsU2V0Um91dGVzIiwibmV3Um91dGVzIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsIl9pbnRlcm5hbEFjdGl2ZURlZmVycmVkcyIsIlVOU0FGRV9ERUZFUlJFRF9TWU1CT0wiLCJTeW1ib2wiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwidjdfdGhyb3dBYm9ydFJlYXNvbiIsInF1ZXJ5IiwiX3RlbXAzIiwicmVxdWVzdENvbnRleHQiLCJza2lwTG9hZGVyRXJyb3JCdWJibGluZyIsImlzVmFsaWRNZXRob2QiLCJtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyIsInN0YXR1c0NvZGUiLCJsb2FkZXJIZWFkZXJzIiwiYWN0aW9uSGVhZGVycyIsInF1ZXJ5SW1wbCIsImlzUmVzcG9uc2UiLCJxdWVyeVJvdXRlIiwiX3RlbXA0IiwiZmluZCIsInZhbHVlcyIsIl9yZXN1bHQkYWN0aXZlRGVmZXJyZSIsInJvdXRlTWF0Y2giLCJzdWJtaXQiLCJsb2FkUm91dGVEYXRhIiwiaXNIYW5kbGVyUmVzdWx0IiwiaXNSZWRpcmVjdFJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJ0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IiLCJMb2NhdGlvbiIsImxvYWRlclJlcXVlc3QiLCJSZXF1ZXN0IiwiY29udGV4dCIsImdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5IiwicHJvY2Vzc1JvdXRlTG9hZGVyRGF0YSIsImV4ZWN1dGVkTG9hZGVycyIsImZyb21FbnRyaWVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsIm5ld0NvbnRleHQiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsInJlYXNvbiIsImlzU3VibWlzc2lvbk5hdmlnYXRpb24iLCJib2R5IiwicHJlcGVuZEJhc2VuYW1lIiwiY29udGV4dHVhbE1hdGNoZXMiLCJhY3RpdmVSb3V0ZU1hdGNoIiwiaGFzTmFrZWRJbmRleFF1ZXJ5Iiwibm9ybWFsaXplRm9ybU1ldGhvZCIsImlzRmV0Y2hlciIsImdldEludmFsaWRCb2R5RXJyb3IiLCJyYXdGb3JtTWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdHJpcEhhc2hGcm9tUGF0aCIsIkZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX3JlZjUiLCJwYXJzZSIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiaXNJbml0aWFsTG9hZCIsInNraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbiIsImN1cnJlbnRVcmwiLCJuZXh0VXJsIiwiYWN0aW9uU3RhdHVzIiwic2hvdWxkU2tpcFJldmFsaWRhdGlvbiIsIm5hdmlnYXRpb25NYXRjaGVzIiwiaXNOZXdMb2FkZXIiLCJjdXJyZW50Um91dGVNYXRjaCIsIm5leHRSb3V0ZU1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZUxvYWRlciIsImN1cnJlbnRQYXJhbXMiLCJuZXh0UGFyYW1zIiwidW5zdGFibGVfYWN0aW9uU3RhdHVzIiwiZGVmYXVsdFNob3VsZFJldmFsaWRhdGUiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJmZXRjaGVyTWF0Y2hlcyIsImZldGNoZXJNYXRjaCIsInNob3VsZFJldmFsaWRhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJyb3V0ZUNob2ljZSIsImxvYWRMYXp5Um91dGVNb2R1bGUiLCJsYXp5Um91dGUiLCJyb3V0ZVRvVXBkYXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkIiwicm91dGVJZHNUb0xvYWQiLCJsb2FkZWRNYXRjaGVzIiwic2hvdWxkTG9hZCIsImhhbmRsZXJPdmVycmlkZSIsImNhbGxMb2FkZXJPckFjdGlvbiIsInN0YXRpY0NvbnRleHQiLCJvblJlamVjdCIsInJ1bkhhbmRsZXIiLCJoYW5kbGVyIiwiYWN0dWFsSGFuZGxlciIsImN0eCIsImhhbmRsZXJQcm9taXNlIiwidmFsIiwiaGFuZGxlckVycm9yIiwiaGFuZGxlclJlc3VsdCIsImNvbnRlbnRUeXBlIiwiaXNEZWZlcnJlZERhdGEiLCJfcmVzdWx0JGluaXQiLCJfcmVzdWx0JGluaXQyIiwiZGVmZXJyZWQiLCJ0cmltbWVkTWF0Y2hlcyIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJmb3VuZEVycm9yIiwibmV3TG9hZGVyRGF0YSIsIm1lcmdlZExvYWRlckRhdGEiLCJoYXNPd25Qcm9wZXJ0eSIsImVsaWdpYmxlTWF0Y2hlcyIsInJldmVyc2UiLCJfdGVtcDUiLCJlcnJvck1lc3NhZ2UiLCJzaWduYWxzIiwiaXNSZXZhbGlkYXRpbmdMb2FkZXIiLCJ1bndyYXAiLCJnZXRBbGwiLCJfd2luZG93IiwidHJhbnNpdGlvbnMiLCJzZXNzaW9uUG9zaXRpb25zIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSJdLCJzb3VyY2VzIjpbIi4uL2hpc3RvcnkudHMiLCIuLi91dGlscy50cyIsIi4uL3JvdXRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXG4gKi9cbmV4cG9ydCBlbnVtIEFjdGlvbiB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBQb3AgPSBcIlBPUFwiLFxuXG4gIC8qKlxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cbiAgICovXG4gIFB1c2ggPSBcIlBVU0hcIixcblxuICAvKipcbiAgICogQSBSRVBMQUNFIGluZGljYXRlcyB0aGUgZW50cnkgYXQgdGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxuICAgKi9cbiAgUmVwbGFjZSA9IFwiUkVQTEFDRVwiLFxufVxuXG4vKipcbiAqIFRoZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCB2YWx1ZXMgb2YgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aCB7XG4gIC8qKlxuICAgKiBBIFVSTCBwYXRobmFtZSwgYmVnaW5uaW5nIHdpdGggYSAvLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogQSBVUkwgc2VhcmNoIHN0cmluZywgYmVnaW5uaW5nIHdpdGggYSA/LlxuICAgKi9cbiAgc2VhcmNoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIGZyYWdtZW50IGlkZW50aWZpZXIsIGJlZ2lubmluZyB3aXRoIGEgIy5cbiAgICovXG4gIGhhc2g6IHN0cmluZztcbn1cblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIExvY2F0aW9uIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYCBhbmRcbi8vIHJlbW92ZSBSZW1peCBgdXNlTG9jYXRpb25gIHdyYXBwZXIuXG5cbi8qKlxuICogQW4gZW50cnkgaW4gYSBoaXN0b3J5IHN0YWNrLiBBIGxvY2F0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogVVJMIHBhdGgsIGFzIHdlbGwgYXMgcG9zc2libHkgc29tZSBhcmJpdHJhcnkgc3RhdGUgYW5kIGEga2V5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uPFN0YXRlID0gYW55PiBleHRlbmRzIFBhdGgge1xuICAvKipcbiAgICogQSB2YWx1ZSBvZiBhcmJpdHJhcnkgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsb2NhdGlvbi5cbiAgICovXG4gIHN0YXRlOiBTdGF0ZTtcblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLiBNYXkgYmUgdXNlZCB0byBzYWZlbHkgc3RvcmVcbiAgICogYW5kIHJldHJpZXZlIGRhdGEgaW4gc29tZSBvdGhlciBzdG9yYWdlIEFQSSwgbGlrZSBgbG9jYWxTdG9yYWdlYC5cbiAgICpcbiAgICogTm90ZTogVGhpcyB2YWx1ZSBpcyBhbHdheXMgXCJkZWZhdWx0XCIgb24gdGhlIGluaXRpYWwgbG9jYXRpb24uXG4gICAqL1xuICBrZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNoYW5nZSB0byB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgY2hhbmdlLlxuICAgKi9cbiAgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBuZXcgbG9jYXRpb24uXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBiZXR3ZWVuIHRoaXMgbG9jYXRpb24gYW5kIHRoZSBmb3JtZXIgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIGRlbHRhOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBub3RpZmljYXRpb25zIGFib3V0IGxvY2F0aW9uIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAodXBkYXRlOiBVcGRhdGUpOiB2b2lkO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGxvY2F0aW9uIHRoYXQgaXMgdGhlIGRlc3RpbmF0aW9uIG9mIHNvbWUgbmF2aWdhdGlvbiwgZWl0aGVyIHZpYVxuICogYGhpc3RvcnkucHVzaGAgb3IgYGhpc3RvcnkucmVwbGFjZWAuIFRoaXMgbWF5IGJlIGVpdGhlciBhIFVSTCBvciB0aGUgcGllY2VzXG4gKiBvZiBhIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBUbyA9IHN0cmluZyB8IFBhcnRpYWw8UGF0aD47XG5cbi8qKlxuICogQSBoaXN0b3J5IGlzIGFuIGludGVyZmFjZSB0byB0aGUgbmF2aWdhdGlvbiBzdGFjay4gVGhlIGhpc3Rvcnkgc2VydmVzIGFzIHRoZVxuICogc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbiwgYXMgd2VsbCBhcyBwcm92aWRlcyBhIHNldCBvZlxuICogbWV0aG9kcyB0aGF0IG1heSBiZSB1c2VkIHRvIGNoYW5nZSBpdC5cbiAqXG4gKiBJdCBpcyBzaW1pbGFyIHRvIHRoZSBET00ncyBgd2luZG93Lmhpc3RvcnlgIG9iamVjdCwgYnV0IHdpdGggYSBzbWFsbGVyLCBtb3JlXG4gKiBmb2N1c2VkIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IGFjdGlvbiB0aGF0IG1vZGlmaWVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIHdpbGwgYWx3YXlzIGJlXG4gICAqIEFjdGlvbi5Qb3Agd2hlbiBhIGhpc3RvcnkgaW5zdGFuY2UgaXMgZmlyc3QgY3JlYXRlZC4gVGhpcyB2YWx1ZSBpcyBtdXRhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIHZhbHVlIGlzIG11dGFibGUuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWxpZCBocmVmIGZvciB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSB0aGF0IG1heSBiZSB1c2VkIGFzXG4gICAqIHRoZSB2YWx1ZSBvZiBhbiA8YSBocmVmPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAgICovXG4gIGNyZWF0ZUhyZWYodG86IFRvKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgVVJMIGZvciB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gICAqL1xuICBjcmVhdGVVUkwodG86IFRvKTogVVJMO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBsb2NhdGlvbiB0aGUgc2FtZSB3YXkgd2luZG93Lmhpc3Rvcnkgd291bGQgZG8gKG5vLW9wIGZvciBtZW1vcnlcbiAgICogaGlzdG9yeSkgc28gd2UgZW5zdXJlIG91ciBQVVNIL1JFUExBQ0UgbmF2aWdhdGlvbnMgZm9yIGRhdGEgcm91dGVyc1xuICAgKiBiZWhhdmUgdGhlIHNhbWUgYXMgUE9QXG4gICAqXG4gICAqIEBwYXJhbSB0byBVbmVuY29kZWQgcGF0aFxuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogUHVzaGVzIGEgbmV3IGxvY2F0aW9uIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2ssIGluY3JlYXNpbmcgaXRzIGxlbmd0aCBieSBvbmUuXG4gICAqIElmIHRoZXJlIHdlcmUgYW55IGVudHJpZXMgaW4gdGhlIHN0YWNrIGFmdGVyIHRoZSBjdXJyZW50IG9uZSwgdGhleSBhcmVcbiAgICogbG9zdC5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIG5ldyBVUkxcbiAgICogQHBhcmFtIHN0YXRlIC0gRGF0YSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IGxvY2F0aW9uXG4gICAqL1xuICBwdXNoKHRvOiBUbywgc3RhdGU/OiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgaGlzdG9yeSBzdGFjayB3aXRoIGEgbmV3IG9uZS4gIFRoZVxuICAgKiBsb2NhdGlvbiB0aGF0IHdhcyByZXBsYWNlZCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogTmF2aWdhdGVzIGBuYCBlbnRyaWVzIGJhY2t3YXJkL2ZvcndhcmQgaW4gdGhlIGhpc3Rvcnkgc3RhY2sgcmVsYXRpdmUgdG8gdGhlXG4gICAqIGN1cnJlbnQgaW5kZXguIEZvciBleGFtcGxlLCBhIFwiYmFja1wiIG5hdmlnYXRpb24gd291bGQgdXNlIGdvKC0xKS5cbiAgICpcbiAgICogQHBhcmFtIGRlbHRhIC0gVGhlIGRlbHRhIGluIHRoZSBzdGFjayBpbmRleFxuICAgKi9cbiAgZ28oZGVsdGE6IG51bWJlcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAqIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzXG4gICAqIEByZXR1cm5zIHVubGlzdGVuIC0gQSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHN0b3AgbGlzdGVuaW5nXG4gICAqL1xuICBsaXN0ZW4obGlzdGVuZXI6IExpc3RlbmVyKTogKCkgPT4gdm9pZDtcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPSB7XG4gIHVzcjogYW55O1xuICBrZXk/OiBzdHJpbmc7XG4gIGlkeDogbnVtYmVyO1xufTtcblxuY29uc3QgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBNZW1vcnkgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIHVzZXItc3VwcGxpZWQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbG9jYXRpb24uIFVzZWQgd2hlbiBwcm92aWRpbmdcbiAqIGVudHJpZXMgdG8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgIHZpYSBpdHMgYGluaXRpYWxFbnRyaWVzYCBvcHRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEluaXRpYWxFbnRyeSA9IHN0cmluZyB8IFBhcnRpYWw8TG9jYXRpb24+O1xuXG5leHBvcnQgdHlwZSBNZW1vcnlIaXN0b3J5T3B0aW9ucyA9IHtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB2NUNvbXBhdD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEEgbWVtb3J5IGhpc3Rvcnkgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuIFRoaXMgaXMgdXNlZnVsIGluIHN0YXRlZnVsXG4gKiBlbnZpcm9ubWVudHMgd2hlcmUgdGhlcmUgaXMgbm8gd2ViIGJyb3dzZXIsIHN1Y2ggYXMgbm9kZSB0ZXN0cyBvciBSZWFjdFxuICogTmF0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeUhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShcbiAgb3B0aW9uczogTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogTWVtb3J5SGlzdG9yeSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllczogTG9jYXRpb25bXTsgLy8gRGVjbGFyZSBzbyB3ZSBjYW4gYWNjZXNzIGZyb20gY3JlYXRlTWVtb3J5TG9jYXRpb25cbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcCgoZW50cnksIGluZGV4KSA9PlxuICAgIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgICAgZW50cnksXG4gICAgICB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsXG4gICAgICBpbmRleCA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdW5kZWZpbmVkXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXI6IExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKTogTG9jYXRpb24ge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICB0bzogVG8sXG4gICAgc3RhdGU6IGFueSA9IG51bGwsXG4gICAga2V5Pzogc3RyaW5nXG4gICk6IExvY2F0aW9uIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvOiBUbykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IE1lbW9yeUhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvOiBUbykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgICAgbGV0IG5leHRJbmRleCA9IGNsYW1wSW5kZXgoaW5kZXggKyBkZWx0YSk7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGVuKGZuOiBMaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEJyb3dzZXIgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzIGluIGEgd2ViXG4gKiBicm93c2VyIGVudmlyb25tZW50LiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3IgbW9zdCB3ZWIgYXBwcyBhbmQgcHJvdmlkZXMgdGhlXG4gKiBjbGVhbmVzdCBVUkxzIHRoZSBicm93c2VyJ3MgYWRkcmVzcyBiYXIuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNicm93c2VyaGlzdG9yeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJIaXN0b3J5IGV4dGVuZHMgVXJsSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBCcm93c2VySGlzdG9yeU9wdGlvbnMgPSBVcmxIaXN0b3J5T3B0aW9ucztcblxuLyoqXG4gKiBCcm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvclxuICogbW9zdCB3ZWIgYXBwcywgYnV0IGl0IHJlcXVpcmVzIHNvbWUgY29uZmlndXJhdGlvbiBvbiB0aGUgc2VydmVyIHRvIGVuc3VyZSB5b3VcbiAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KFxuICBvcHRpb25zOiBCcm93c2VySGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogQnJvd3Nlckhpc3Rvcnkge1xuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24oXG4gICAgd2luZG93OiBXaW5kb3csXG4gICAgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXVxuICApIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzcikgfHwgbnVsbCxcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3c6IFdpbmRvdywgdG86IFRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cblxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbixcbiAgICBjcmVhdGVCcm93c2VySHJlZixcbiAgICBudWxsLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhhc2ggSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgcG9ydGlvblxuICogb2YgdGhlIFVSTCBpbiBhIHdlYiBicm93c2VyIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgaXMgaWRlYWwgZm9yIGFwcHMgdGhhdCBkbyBub3QgY29udHJvbCB0aGUgc2VydmVyIGZvciBzb21lIHJlYXNvblxuICogKGJlY2F1c2UgdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgaXMgbmV2ZXIgc2VudCB0byB0aGUgc2VydmVyKSwgaW5jbHVkaW5nIHNvbWVcbiAqIHNoYXJlZCBob3N0aW5nIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBwcm92aWRlIGZpbmUtZ3JhaW5lZCBjb250cm9scyBvdmVyXG4gKiB3aGljaCBwYWdlcyBhcmUgc2VydmVkIGF0IHdoaWNoIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNoYXNoaGlzdG9yeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hIaXN0b3J5IGV4dGVuZHMgVXJsSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBIYXNoSGlzdG9yeU9wdGlvbnMgPSBVcmxIaXN0b3J5T3B0aW9ucztcblxuLyoqXG4gKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcbiAqIHNvbWUgcmVhc29uLCBlaXRoZXIgYmVjYXVzZSB5b3UgZG8gY2Fubm90IGNvbmZpZ3VyZSBpdCBvciB0aGUgVVJMIHNwYWNlIGlzXG4gKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVoYXNoaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoXG4gIG9wdGlvbnM6IEhhc2hIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBIYXNoSGlzdG9yeSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbihcbiAgICB3aW5kb3c6IFdpbmRvdyxcbiAgICBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdXG4gICkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiLFxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcblxuICAgIC8vIEhhc2ggVVJMIHNob3VsZCBhbHdheXMgaGF2ZSBhIGxlYWRpbmcgLyBqdXN0IGxpa2Ugd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgLy8gZG9lcywgc28gaWYgYW4gYXBwIGVuZHMgdXAgYXQgYSByb3V0ZSBsaWtlIC8jc29tZXRoaW5nIHRoZW4gd2UgYWRkIGFcbiAgICAvLyBsZWFkaW5nIHNsYXNoIHNvIGFsbCBvZiBvdXIgcGF0aC1tYXRjaGluZyBiZWhhdmVzIHRoZSBzYW1lIGFzIGlmIGl0IHdvdWxkXG4gICAgLy8gaW4gYSBicm93c2VyIHJvdXRlci4gIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCB3aGVuIHRoZXJlIGV4aXN0cyBhXG4gICAgLy8gcm9vdCBzcGxhdCByb3V0ZSAoPFJvdXRlIHBhdGg9XCIqXCI+KSBzaW5jZSB0aGF0IG1hdGNoZXMgaW50ZXJuYWxseSBhZ2FpbnN0XG4gICAgLy8gXCIvKlwiIGFuZCB3ZSdkIGV4cGVjdCAvI3NvbWV0aGluZyB0byA0MDQgaW4gYSBoYXNoIHJvdXRlciBhcHAuXG4gICAgaWYgKCFwYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJiAhcGF0aG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyKSB8fCBudWxsLFxuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdzogV2luZG93LCB0bzogVG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcbiAgICBsZXQgaHJlZiA9IFwiXCI7XG5cbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmICsgXCIjXCIgKyAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbjogTG9jYXRpb24sIHRvOiBUbykge1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaCgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX0pYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUhhc2hMb2NhdGlvbixcbiAgICBjcmVhdGVIYXNoSHJlZixcbiAgICB2YWxpZGF0ZUhhc2hMb2NhdGlvbixcbiAgICBvcHRpb25zXG4gICk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlOiBib29sZWFuLCBtZXNzYWdlPzogc3RyaW5nKTogYXNzZXJ0cyB2YWx1ZTtcbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQ8VD4oXG4gIHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgbWVzc2FnZT86IHN0cmluZ1xuKTogYXNzZXJ0cyB2YWx1ZSBpcyBUO1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZTogYW55LCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlLCBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuXG4vKipcbiAqIEZvciBicm93c2VyLWJhc2VkIGhpc3Rvcmllcywgd2UgY29tYmluZSB0aGUgc3RhdGUgYW5kIGtleSBpbnRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb246IExvY2F0aW9uLCBpbmRleDogbnVtYmVyKTogSGlzdG9yeVN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXgsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihcbiAgY3VycmVudDogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHRvOiBUbyxcbiAgc3RhdGU6IGFueSA9IG51bGwsXG4gIGtleT86IHN0cmluZ1xuKTogUmVhZG9ubHk8TG9jYXRpb24+IHtcbiAgbGV0IGxvY2F0aW9uOiBSZWFkb25seTxMb2NhdGlvbj4gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4uKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0byksXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogKHRvICYmICh0byBhcyBMb2NhdGlvbikua2V5KSB8fCBrZXkgfHwgY3JlYXRlS2V5KCksXG4gIH07XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCIsXG59OiBQYXJ0aWFsPFBhdGg+KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKTogUGFydGlhbDxQYXRoPiB7XG4gIGxldCBwYXJzZWRQYXRoOiBQYXJ0aWFsPFBhdGg+ID0ge307XG5cbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVybEhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIFVybEhpc3RvcnlPcHRpb25zID0ge1xuICB3aW5kb3c/OiBXaW5kb3c7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShcbiAgZ2V0TG9jYXRpb246ICh3aW5kb3c6IFdpbmRvdywgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXSkgPT4gTG9jYXRpb24sXG4gIGNyZWF0ZUhyZWY6ICh3aW5kb3c6IFdpbmRvdywgdG86IFRvKSA9PiBzdHJpbmcsXG4gIHZhbGlkYXRlTG9jYXRpb246ICgobG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pID0+IHZvaWQpIHwgbnVsbCxcbiAgb3B0aW9uczogVXJsSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogVXJsSGlzdG9yeSB7XG4gIGxldCB7IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ISwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpITtcbiAgLy8gSW5kZXggc2hvdWxkIG9ubHkgYmUgbnVsbCB3aGVuIHdlIGluaXRpYWxpemUuIElmIG5vdCwgaXQncyBiZWNhdXNlIHRoZVxuICAvLyB1c2VyIGNhbGxlZCBoaXN0b3J5LnB1c2hTdGF0ZSBvciBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBkaXJlY3RseSwgaW4gd2hpY2hcbiAgLy8gY2FzZSB3ZSBzaG91bGQgbG9nIGEgd2FybmluZyBhcyBpdCB3aWxsIHJlc3VsdCBpbiBidWdzLlxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IC4uLmdsb2JhbEhpc3Rvcnkuc3RhdGUsIGlkeDogaW5kZXggfSwgXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbmRleCgpOiBudW1iZXIge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xuICAgICAgLy8gb3V0d2FyZHMganVzdCBsaWtlIGEgcmVwbGFjZSBjYWxsIHdvdWxkIHNvIHRoZSBkZXYga25vd3MgdGhlIGNhdXNlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9uYXYtaGlzdG9yeS1hcGlzLmh0bWwjc2hhcmVkLWhpc3RvcnktcHVzaC9yZXBsYWNlLXN0YXRlLXN0ZXBzXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG86IFRvKTogVVJMIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPVxuICAgICAgd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCJcbiAgICAgICAgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgLy8gVHJlYXRpbmcgdGhpcyBhcyBhIGZ1bGwgVVJMIHdpbGwgc3RyaXAgYW55IHRyYWlsaW5nIHNwYWNlcyBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gcHJlLWVuY29kZSB0aGVtIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFydCBvZiBhIG1hdGNoaW5nIHNwbGF0IHBhcmFtIGZyb21cbiAgICAvLyBhbiBhbmNlc3RvciByb3V0ZVxuICAgIGhyZWYgPSBocmVmLnJlcGxhY2UoLyAkLywgXCIlMjBcIik7XG4gICAgaW52YXJpYW50KFxuICAgICAgYmFzZSxcbiAgICAgIGBObyB3aW5kb3cubG9jYXRpb24uKG9yaWdpbnxocmVmKSBhdmFpbGFibGUgdG8gY3JlYXRlIFVSTCBmb3IgaHJlZjogJHtocmVmfWBcbiAgICApO1xuICAgIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IEhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaCxcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2UsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuLy8jZW5kcmVnaW9uXG4iLCJpbXBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7IGludmFyaWFudCwgcGFyc2VQYXRoLCB3YXJuaW5nIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuXG4vKipcbiAqIE1hcCBvZiByb3V0ZUlkIC0+IGRhdGEgcmV0dXJuZWQgZnJvbSBhIGxvYWRlci9hY3Rpb24vZXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZURhdGEge1xuICBbcm91dGVJZDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgZW51bSBSZXN1bHRUeXBlIHtcbiAgZGF0YSA9IFwiZGF0YVwiLFxuICBkZWZlcnJlZCA9IFwiZGVmZXJyZWRcIixcbiAgcmVkaXJlY3QgPSBcInJlZGlyZWN0XCIsXG4gIGVycm9yID0gXCJlcnJvclwiLFxufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VjY2Vzc1Jlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGF0YTtcbiAgZGF0YTogdW5rbm93bjtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogU3VjY2Vzc2Z1bCBkZWZlcigpIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmVycmVkUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZDtcbiAgZGVmZXJyZWREYXRhOiBEZWZlcnJlZERhdGE7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFJlZGlyZWN0IHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZGlyZWN0UmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdDtcbiAgLy8gV2Uga2VlcCB0aGUgcmF3IFJlc3BvbnNlIGZvciByZWRpcmVjdHMgc28gd2UgY2FuIHJldHVybiBpdCB2ZXJiYXRpbVxuICByZXNwb25zZTogUmVzcG9uc2U7XG59XG5cbi8qKlxuICogVW5zdWNjZXNzZnVsIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcjtcbiAgZXJyb3I6IHVua25vd247XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvbiAtIHBvdGVudGlhbGx5IHN1Y2Nlc3NmdWwgb3IgdW5zdWNjZXNzZnVsXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFSZXN1bHQgPVxuICB8IFN1Y2Nlc3NSZXN1bHRcbiAgfCBEZWZlcnJlZFJlc3VsdFxuICB8IFJlZGlyZWN0UmVzdWx0XG4gIHwgRXJyb3JSZXN1bHQ7XG5cbi8qKlxuICogUmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uIGNhbGxlZCB2aWEgZGF0YVN0cmF0ZWd5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlclJlc3VsdCB7XG4gIHR5cGU6IFwiZGF0YVwiIHwgXCJlcnJvclwiO1xuICByZXN1bHQ6IHVua25vd247IC8vIGRhdGEsIEVycm9yLCBSZXNwb25zZSwgRGVmZXJyZWREYXRhXG4gIHN0YXR1cz86IG51bWJlcjtcbn1cblxudHlwZSBMb3dlckNhc2VGb3JtTWV0aG9kID0gXCJnZXRcIiB8IFwicG9zdFwiIHwgXCJwdXRcIiB8IFwicGF0Y2hcIiB8IFwiZGVsZXRlXCI7XG50eXBlIFVwcGVyQ2FzZUZvcm1NZXRob2QgPSBVcHBlcmNhc2U8TG93ZXJDYXNlRm9ybU1ldGhvZD47XG5cbi8qKlxuICogVXNlcnMgY2FuIHNwZWNpZnkgZWl0aGVyIGxvd2VyY2FzZSBvciB1cHBlcmNhc2UgZm9ybSBtZXRob2RzIG9uIGA8Rm9ybT5gLFxuICogdXNlU3VibWl0KCksIGA8ZmV0Y2hlci5Gb3JtPmAsIGV0Yy5cbiAqL1xuZXhwb3J0IHR5cGUgSFRNTEZvcm1NZXRob2QgPSBMb3dlckNhc2VGb3JtTWV0aG9kIHwgVXBwZXJDYXNlRm9ybU1ldGhvZDtcblxuLyoqXG4gKiBBY3RpdmUgbmF2aWdhdGlvbi9mZXRjaGVyIGZvcm0gbWV0aG9kcyBhcmUgZXhwb3NlZCBpbiBsb3dlcmNhc2Ugb24gdGhlXG4gKiBSb3V0ZXJTdGF0ZVxuICovXG5leHBvcnQgdHlwZSBGb3JtTWV0aG9kID0gTG93ZXJDYXNlRm9ybU1ldGhvZDtcbmV4cG9ydCB0eXBlIE11dGF0aW9uRm9ybU1ldGhvZCA9IEV4Y2x1ZGU8Rm9ybU1ldGhvZCwgXCJnZXRcIj47XG5cbi8qKlxuICogSW4gdjcsIGFjdGl2ZSBuYXZpZ2F0aW9uL2ZldGNoZXIgZm9ybSBtZXRob2RzIGFyZSBleHBvc2VkIGluIHVwcGVyY2FzZSBvbiB0aGVcbiAqIFJvdXRlclN0YXRlLiAgVGhpcyBpcyB0byBhbGlnbiB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGRvbmUgdmlhIGZldGNoKCkuXG4gKi9cbmV4cG9ydCB0eXBlIFY3X0Zvcm1NZXRob2QgPSBVcHBlckNhc2VGb3JtTWV0aG9kO1xuZXhwb3J0IHR5cGUgVjdfTXV0YXRpb25Gb3JtTWV0aG9kID0gRXhjbHVkZTxWN19Gb3JtTWV0aG9kLCBcIkdFVFwiPjtcblxuZXhwb3J0IHR5cGUgRm9ybUVuY1R5cGUgPVxuICB8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgfCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICB8IFwiYXBwbGljYXRpb24vanNvblwiXG4gIHwgXCJ0ZXh0L3BsYWluXCI7XG5cbi8vIFRoYW5rcyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3R5cGUtZmVzdCFcbnR5cGUgSnNvbk9iamVjdCA9IHsgW0tleSBpbiBzdHJpbmddOiBKc29uVmFsdWUgfSAmIHtcbiAgW0tleSBpbiBzdHJpbmddPzogSnNvblZhbHVlIHwgdW5kZWZpbmVkO1xufTtcbnR5cGUgSnNvbkFycmF5ID0gSnNvblZhbHVlW10gfCByZWFkb25seSBKc29uVmFsdWVbXTtcbnR5cGUgSnNvblByaW1pdGl2ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsO1xudHlwZSBKc29uVmFsdWUgPSBKc29uUHJpbWl0aXZlIHwgSnNvbk9iamVjdCB8IEpzb25BcnJheTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHBhc3MgYXJvdW5kIGZvciBhY3Rpb24gc3VibWlzc2lvbnMsIG5vdCBpbnRlbmRlZCBmb3JcbiAqIGV4dGVybmFsIGNvbnN1bXB0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFN1Ym1pc3Npb24gPVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICAgICAganNvbjogdW5kZWZpbmVkO1xuICAgICAgdGV4dDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfCB7XG4gICAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZDtcbiAgICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAgICBqc29uOiBKc29uVmFsdWU7XG4gICAgICB0ZXh0OiB1bmRlZmluZWQ7XG4gICAgfVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICAgIGpzb246IHVuZGVmaW5lZDtcbiAgICAgIHRleHQ6IHN0cmluZztcbiAgICB9O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIHJvdXRlIGxvYWRlci9hY3Rpb24gZnVuY3Rpb25zLiAgU2FtZSBmb3Igbm93IGJ1dCB3ZSBrZWVwXG4gKiB0aGlzIGFzIGEgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgaW4gY2FzZSB0aGV5IGRpdmVyZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuaW50ZXJmYWNlIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge1xuICByZXF1ZXN0OiBSZXF1ZXN0O1xuICBwYXJhbXM6IFBhcmFtcztcbiAgY29udGV4dD86IENvbnRleHQ7XG59XG5cbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSBkZWZhdWx0cyBmcm9tIGFueSB0byB1bmtub3duIGluIGFuZCByZW1vdmUgUmVtaXggd3JhcHBlcnM6XG4vLyAgIEFjdGlvbkZ1bmN0aW9uLCBBY3Rpb25GdW5jdGlvbkFyZ3MsIExvYWRlckZ1bmN0aW9uLCBMb2FkZXJGdW5jdGlvbkFyZ3Ncbi8vICAgQWxzbywgbWFrZSB0aGVtIGEgdHlwZSBhbGlhcyBpbnN0ZWFkIG9mIGFuIGludGVyZmFjZVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gbG9hZGVyIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uQXJnczxDb250ZXh0ID0gYW55PlxuICBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge31cblxuLyoqXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIGFjdGlvbiBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25GdW5jdGlvbkFyZ3M8Q29udGV4dCA9IGFueT5cbiAgZXh0ZW5kcyBEYXRhRnVuY3Rpb25BcmdzPENvbnRleHQ+IHt9XG5cbi8qKlxuICogTG9hZGVycyBhbmQgYWN0aW9ucyBjYW4gcmV0dXJuIGFueXRoaW5nIGV4Y2VwdCBgdW5kZWZpbmVkYCAoYG51bGxgIGlzIGFcbiAqIHZhbGlkIHJldHVybiB2YWx1ZSBpZiB0aGVyZSBpcyBubyBkYXRhIHRvIHJldHVybikuICBSZXNwb25zZXMgYXJlIHByZWZlcnJlZFxuICogYW5kIHdpbGwgZWFzZSBhbnkgZnV0dXJlIG1pZ3JhdGlvbiB0byBSZW1peFxuICovXG50eXBlIERhdGFGdW5jdGlvblZhbHVlID0gUmVzcG9uc2UgfCBOb25OdWxsYWJsZTx1bmtub3duPiB8IG51bGw7XG5cbnR5cGUgRGF0YUZ1bmN0aW9uUmV0dXJuVmFsdWUgPSBQcm9taXNlPERhdGFGdW5jdGlvblZhbHVlPiB8IERhdGFGdW5jdGlvblZhbHVlO1xuXG4vKipcbiAqIFJvdXRlIGxvYWRlciBmdW5jdGlvbiBzaWduYXR1cmVcbiAqL1xuZXhwb3J0IHR5cGUgTG9hZGVyRnVuY3Rpb248Q29udGV4dCA9IGFueT4gPSB7XG4gIChcbiAgICBhcmdzOiBMb2FkZXJGdW5jdGlvbkFyZ3M8Q29udGV4dD4sXG4gICAgaGFuZGxlckN0eD86IHVua25vd25cbiAgKTogRGF0YUZ1bmN0aW9uUmV0dXJuVmFsdWU7XG59ICYgeyBoeWRyYXRlPzogYm9vbGVhbiB9O1xuXG4vKipcbiAqIFJvdXRlIGFjdGlvbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25GdW5jdGlvbjxDb250ZXh0ID0gYW55PiB7XG4gIChcbiAgICBhcmdzOiBBY3Rpb25GdW5jdGlvbkFyZ3M8Q29udGV4dD4sXG4gICAgaGFuZGxlckN0eD86IHVua25vd25cbiAgKTogRGF0YUZ1bmN0aW9uUmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyB7XG4gIGN1cnJlbnRVcmw6IFVSTDtcbiAgY3VycmVudFBhcmFtczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgbmV4dFVybDogVVJMO1xuICBuZXh0UGFyYW1zOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBmb3JtTWV0aG9kPzogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl07XG4gIGZvcm1BY3Rpb24/OiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgZm9ybUVuY1R5cGU/OiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl07XG4gIHRleHQ/OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgZm9ybURhdGE/OiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gIGpzb24/OiBTdWJtaXNzaW9uW1wianNvblwiXTtcbiAgdW5zdGFibGVfYWN0aW9uU3RhdHVzPzogbnVtYmVyO1xuICBhY3Rpb25SZXN1bHQ/OiBhbnk7XG4gIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJvdXRlIHNob3VsZFJldmFsaWRhdGUgZnVuY3Rpb24gc2lnbmF0dXJlLiAgVGhpcyBydW5zIGFmdGVyIGFueSBzdWJtaXNzaW9uXG4gKiAobmF2aWdhdGlvbiBvciBmZXRjaGVyKSwgc28gd2UgZmxhdHRlbiB0aGUgbmF2aWdhdGlvbi9mZXRjaGVyIHN1Ym1pc3Npb25cbiAqIG9udG8gdGhlIGFyZ3VtZW50cy4gIEl0IHNob3VsZG4ndCBtYXR0ZXIgd2hldGhlciBpdCBjYW1lIGZyb20gYSBuYXZpZ2F0aW9uXG4gKiBvciBhIGZldGNoZXIsIHdoYXQgcmVhbGx5IG1hdHRlcnMgaXMgdGhlIFVSTHMgYW5kIHRoZSBmb3JtRGF0YSBzaW5jZSBsb2FkZXJzXG4gKiBoYXZlIHRvIHJlLXJ1biBiYXNlZCBvbiB0aGUgZGF0YSBtb2RlbHMgdGhhdCB3ZXJlIHBvdGVudGlhbGx5IG11dGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uIHtcbiAgKGFyZ3M6IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbkFyZ3MpOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBmcmFtZXdvcmstYXdhcmUgbGF5ZXJzIHRvIHNldCBgaGFzRXJyb3JCb3VuZGFyeWBcbiAqIGZyb20gdGhlIGZyYW1ld29yay1hd2FyZSBgZXJyb3JFbGVtZW50YCBwcm9wXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBtYXBSb3V0ZVByb3BlcnRpZXNgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb24ge1xuICAocm91dGU6IEFnbm9zdGljUm91dGVPYmplY3QpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFTdHJhdGVneU1hdGNoXG4gIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgQWdub3N0aWNEYXRhUm91dGVPYmplY3Q+IHtcbiAgc2hvdWxkTG9hZDogYm9vbGVhbjtcbiAgcmVzb2x2ZTogKFxuICAgIGhhbmRsZXJPdmVycmlkZT86IChcbiAgICAgIGhhbmRsZXI6IChjdHg/OiB1bmtub3duKSA9PiBEYXRhRnVuY3Rpb25SZXR1cm5WYWx1ZVxuICAgICkgPT4gUHJvbWlzZTxIYW5kbGVyUmVzdWx0PlxuICApID0+IFByb21pc2U8SGFuZGxlclJlc3VsdD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVN0cmF0ZWd5RnVuY3Rpb25BcmdzPENvbnRleHQgPSBhbnk+XG4gIGV4dGVuZHMgRGF0YUZ1bmN0aW9uQXJnczxDb250ZXh0PiB7XG4gIG1hdGNoZXM6IERhdGFTdHJhdGVneU1hdGNoW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVN0cmF0ZWd5RnVuY3Rpb24ge1xuICAoYXJnczogRGF0YVN0cmF0ZWd5RnVuY3Rpb25BcmdzKTogUHJvbWlzZTxIYW5kbGVyUmVzdWx0W10+O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBmcmFtZXdvcmstYXdhcmUgbGF5ZXJzIHRvIHNldCBhbnkgZnJhbWV3b3JrLXNwZWNpZmljXG4gKiBwcm9wZXJ0aWVzIGZyb20gZnJhbWV3b3JrLWFnbm9zdGljIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbiB7XG4gIChyb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdCk6IHtcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiBib29sZWFuO1xuICB9ICYgUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuLyoqXG4gKiBLZXlzIHdlIGNhbm5vdCBjaGFuZ2UgZnJvbSB3aXRoaW4gYSBsYXp5KCkgZnVuY3Rpb24uIFdlIHNwcmVhZCBhbGwgb3RoZXIga2V5c1xuICogb250byB0aGUgcm91dGUuIEVpdGhlciB0aGV5J3JlIG1lYW5pbmdmdWwgdG8gdGhlIHJvdXRlciwgb3IgdGhleSdsbCBnZXRcbiAqIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCB0eXBlIEltbXV0YWJsZVJvdXRlS2V5ID1cbiAgfCBcImxhenlcIlxuICB8IFwiY2FzZVNlbnNpdGl2ZVwiXG4gIHwgXCJwYXRoXCJcbiAgfCBcImlkXCJcbiAgfCBcImluZGV4XCJcbiAgfCBcImNoaWxkcmVuXCI7XG5cbmV4cG9ydCBjb25zdCBpbW11dGFibGVSb3V0ZUtleXMgPSBuZXcgU2V0PEltbXV0YWJsZVJvdXRlS2V5PihbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImNoaWxkcmVuXCIsXG5dKTtcblxudHlwZSBSZXF1aXJlT25lPFQsIEtleSA9IGtleW9mIFQ+ID0gRXhjbHVkZTxcbiAge1xuICAgIFtLIGluIGtleW9mIFRdOiBLIGV4dGVuZHMgS2V5ID8gT21pdDxULCBLPiAmIFJlcXVpcmVkPFBpY2s8VCwgSz4+IDogbmV2ZXI7XG4gIH1ba2V5b2YgVF0sXG4gIHVuZGVmaW5lZFxuPjtcblxuLyoqXG4gKiBsYXp5KCkgZnVuY3Rpb24gdG8gbG9hZCBhIHJvdXRlIGRlZmluaXRpb24sIHdoaWNoIGNhbiBhZGQgbm9uLW1hdGNoaW5nXG4gKiByZWxhdGVkIHByb3BlcnRpZXMgdG8gYSByb3V0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExhenlSb3V0ZUZ1bmN0aW9uPFIgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0PiB7XG4gICgpOiBQcm9taXNlPFJlcXVpcmVPbmU8T21pdDxSLCBJbW11dGFibGVSb3V0ZUtleT4+Pjtcbn1cblxuLyoqXG4gKiBCYXNlIFJvdXRlT2JqZWN0IHdpdGggY29tbW9uIHByb3BzIHNoYXJlZCBieSBhbGwgdHlwZXMgb2Ygcm91dGVzXG4gKi9cbnR5cGUgQWdub3N0aWNCYXNlUm91dGVPYmplY3QgPSB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgbG9hZGVyPzogTG9hZGVyRnVuY3Rpb24gfCBib29sZWFuO1xuICBhY3Rpb24/OiBBY3Rpb25GdW5jdGlvbiB8IGJvb2xlYW47XG4gIGhhc0Vycm9yQm91bmRhcnk/OiBib29sZWFuO1xuICBzaG91bGRSZXZhbGlkYXRlPzogU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uO1xuICBoYW5kbGU/OiBhbnk7XG4gIGxhenk/OiBMYXp5Um91dGVGdW5jdGlvbjxBZ25vc3RpY0Jhc2VSb3V0ZU9iamVjdD47XG59O1xuXG4vKipcbiAqIEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IHVuZGVmaW5lZDtcbiAgaW5kZXg6IHRydWU7XG59O1xuXG4vKipcbiAqIE5vbi1pbmRleCByb3V0ZXMgbWF5IGhhdmUgY2hpbGRyZW4sIGJ1dCBjYW5ub3QgaGF2ZSBpbmRleFxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY0Jhc2VSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBBZ25vc3RpY1JvdXRlT2JqZWN0W107XG4gIGluZGV4PzogZmFsc2U7XG59O1xuXG4vKipcbiAqIEEgcm91dGUgb2JqZWN0IHJlcHJlc2VudHMgYSBsb2dpY2FsIHJvdXRlLCB3aXRoIChvcHRpb25hbGx5KSBpdHMgY2hpbGRcbiAqIHJvdXRlcyBvcmdhbml6ZWQgaW4gYSB0cmVlLWxpa2Ugc3RydWN0dXJlLlxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY1JvdXRlT2JqZWN0ID1cbiAgfCBBZ25vc3RpY0luZGV4Um91dGVPYmplY3RcbiAgfCBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3Q7XG5cbmV4cG9ydCB0eXBlIEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QgJiB7XG4gIGlkOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG4gIGlkOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEEgZGF0YSByb3V0ZSBvYmplY3QsIHdoaWNoIGlzIGp1c3QgYSBSb3V0ZU9iamVjdCB3aXRoIGEgcmVxdWlyZWQgdW5pcXVlIElEXG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0ID1cbiAgfCBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0XG4gIHwgQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdDtcblxuZXhwb3J0IHR5cGUgUm91dGVNYW5pZmVzdCA9IFJlY29yZDxzdHJpbmcsIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0IHwgdW5kZWZpbmVkPjtcblxuLy8gUmVjdXJzaXZlIGhlbHBlciBmb3IgZmluZGluZyBwYXRoIHBhcmFtZXRlcnMgaW4gdGhlIGFic2VuY2Ugb2Ygd2lsZGNhcmRzXG50eXBlIF9QYXRoUGFyYW08UGF0aCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBzcGxpdCBwYXRoIGludG8gaW5kaXZpZHVhbCBwYXRoIHNlZ21lbnRzXG4gIFBhdGggZXh0ZW5kcyBgJHtpbmZlciBMfS8ke2luZmVyIFJ9YFxuICAgID8gX1BhdGhQYXJhbTxMPiB8IF9QYXRoUGFyYW08Uj5cbiAgICA6IC8vIGZpbmQgcGFyYW1zIGFmdGVyIGA6YFxuICAgIFBhdGggZXh0ZW5kcyBgOiR7aW5mZXIgUGFyYW19YFxuICAgID8gUGFyYW0gZXh0ZW5kcyBgJHtpbmZlciBPcHRpb25hbH0/YFxuICAgICAgPyBPcHRpb25hbFxuICAgICAgOiBQYXJhbVxuICAgIDogLy8gb3RoZXJ3aXNlLCB0aGVyZSBhcmVuJ3QgYW55IHBhcmFtcyBwcmVzZW50XG4gICAgICBuZXZlcjtcblxuLyoqXG4gKiBFeGFtcGxlczpcbiAqIFwiL2EvYi8qXCIgLT4gXCIqXCJcbiAqIFwiOmFcIiAtPiBcImFcIlxuICogXCIvYS86YlwiIC0+IFwiYlwiXG4gKiBcIi9hL2JsYWhibGFoYmxhaDpiXCIgLT4gXCJiXCJcbiAqIFwiLzphLzpiXCIgLT4gXCJhXCIgfCBcImJcIlxuICogXCIvOmEvYi86Yy8qXCIgLT4gXCJhXCIgfCBcImNcIiB8IFwiKlwiXG4gKi9cbmV4cG9ydCB0eXBlIFBhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGNoZWNrIGlmIHBhdGggaXMganVzdCBhIHdpbGRjYXJkXG4gIFBhdGggZXh0ZW5kcyBcIipcIiB8IFwiLypcIlxuICAgID8gXCIqXCJcbiAgICA6IC8vIGxvb2sgZm9yIHdpbGRjYXJkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdGhcbiAgICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgUmVzdH0vKmBcbiAgICA/IFwiKlwiIHwgX1BhdGhQYXJhbTxSZXN0PlxuICAgIDogLy8gbG9vayBmb3IgcGFyYW1zIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xuICAgICAgX1BhdGhQYXJhbTxQYXRoPjtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIHNlZ21lbnQuIElmIGl0IGZhaWxzLCB0aGVuIGp1c3QgcmV0dXJuIHRoZVxuLy8gcGxhaW4gc3RyaW5nIHR5cGUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLiBPdGhlcndpc2UsIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxuZXhwb3J0IHR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGlmIHlvdSBjb3VsZCBub3QgZmluZCBwYXRoIHBhcmFtcywgZmFsbGJhY2sgdG8gYHN0cmluZ2BcbiAgW1BhdGhQYXJhbTxTZWdtZW50Pl0gZXh0ZW5kcyBbbmV2ZXJdID8gc3RyaW5nIDogUGF0aFBhcmFtPFNlZ21lbnQ+O1xuXG4vKipcbiAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXJzZWQgZnJvbSB0aGUgVVJMIHBhdGguXG4gKi9cbmV4cG9ydCB0eXBlIFBhcmFtczxLZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0ge1xuICByZWFkb25seSBba2V5IGluIEtleV06IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQSBSb3V0ZU1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgcm91dGUgbWF0Y2hlZCBhIFVSTC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZ25vc3RpY1JvdXRlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJvdXRlIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4gIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgQWdub3N0aWNEYXRhUm91dGVPYmplY3Q+IHt9XG5cbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShcbiAgcm91dGU6IEFnbm9zdGljUm91dGVPYmplY3Rcbik6IHJvdXRlIGlzIEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCB7XG4gIHJldHVybiByb3V0ZS5pbmRleCA9PT0gdHJ1ZTtcbn1cblxuLy8gV2FsayB0aGUgcm91dGUgdHJlZSBnZW5lcmF0aW5nIHVuaXF1ZSBJRHMgd2hlcmUgbmVjZXNzYXJ5LCBzbyB3ZSBhcmUgd29ya2luZ1xuLy8gc29sZWx5IHdpdGggQWdub3N0aWNEYXRhUm91dGVPYmplY3QncyB3aXRoaW4gdGhlIFJvdXRlclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uLFxuICBwYXJlbnRQYXRoOiBudW1iZXJbXSA9IFtdLFxuICBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCA9IHt9XG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhbWFuaWZlc3RbaWRdLFxuICAgICAgYEZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFwiJHtpZH1cIi4gIFJvdXRlIGAgK1xuICAgICAgICBcImlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc1wiXG4gICAgKTtcblxuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZTogQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlOiBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0ID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSxcbiAgICAgICAgaWQsXG4gICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gcGF0aE9yTGF5b3V0Um91dGU7XG5cbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgIHRyZWVQYXRoLFxuICAgICAgICAgIG1hbmlmZXN0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGxvY2F0aW9uQXJnOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZyxcbiAgYmFzZW5hbWUgPSBcIi9cIlxuKTogQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPltdIHwgbnVsbCB7XG4gIGxldCBsb2NhdGlvbiA9XG4gICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG5cbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIEluY29taW5nIHBhdGhuYW1lcyBhcmUgZ2VuZXJhbGx5IGVuY29kZWQgZnJvbSBlaXRoZXIgd2luZG93LmxvY2F0aW9uXG4gICAgLy8gb3IgZnJvbSByb3V0ZXIubmF2aWdhdGUsIGJ1dCB3ZSB3YW50IHRvIG1hdGNoIGFnYWluc3QgdGhlIHVuZW5jb2RlZFxuICAgIC8vIHBhdGhzIGluIHRoZSByb3V0ZSBkZWZpbml0aW9ucy4gIE1lbW9yeSByb3V0ZXIgbG9jYXRpb25zIHdvbid0IGJlXG4gICAgLy8gZW5jb2RlZCBoZXJlIGJ1dCB0aGVyZSBhbHNvIHNob3VsZG4ndCBiZSBhbnl0aGluZyB0byBkZWNvZGUgc28gdGhpc1xuICAgIC8vIHNob3VsZCBiZSBhIHNhZmUgb3BlcmF0aW9uLiAgVGhpcyBhdm9pZHMgbmVlZGluZyBtYXRjaFJvdXRlcyB0byBiZVxuICAgIC8vIGhpc3RvcnktYXdhcmUuXG4gICAgbGV0IGRlY29kZWQgPSBkZWNvZGVQYXRoKHBhdGhuYW1lKTtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaDxzdHJpbmcsIFJvdXRlT2JqZWN0VHlwZT4oYnJhbmNoZXNbaV0sIGRlY29kZWQpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVUlNYXRjaDxEYXRhID0gdW5rbm93biwgSGFuZGxlID0gdW5rbm93bj4ge1xuICBpZDogc3RyaW5nO1xuICBwYXRobmFtZTogc3RyaW5nO1xuICBwYXJhbXM6IEFnbm9zdGljUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgZGF0YTogRGF0YTtcbiAgaGFuZGxlOiBIYW5kbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YVxuKTogVUlNYXRjaCB7XG4gIGxldCB7IHJvdXRlLCBwYXRobmFtZSwgcGFyYW1zIH0gPSBtYXRjaDtcbiAgcmV0dXJuIHtcbiAgICBpZDogcm91dGUuaWQsXG4gICAgcGF0aG5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRhdGE6IGxvYWRlckRhdGFbcm91dGUuaWRdLFxuICAgIGhhbmRsZTogcm91dGUuaGFuZGxlLFxuICB9O1xufVxuXG5pbnRlcmZhY2UgUm91dGVNZXRhPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuO1xuICBjaGlsZHJlbkluZGV4OiBudW1iZXI7XG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmludGVyZmFjZSBSb3V0ZUJyYW5jaDxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICBwYXRoOiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHJvdXRlc01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W107XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXM8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0VHlwZVtdLFxuICBicmFuY2hlczogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPltdID0gW10sXG4gIHBhcmVudHNNZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPltdID0gW10sXG4gIHBhcmVudFBhdGggPSBcIlwiXG4pOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10ge1xuICBsZXQgZmxhdHRlblJvdXRlID0gKFxuICAgIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGUsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICByZWxhdGl2ZVBhdGg/OiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgbGV0IG1ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+ID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOlxuICAgICAgICByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlLFxuICAgIH07XG5cbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIGAgK1xuICAgICAgICAgIGBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggYCArXG4gICAgICAgICAgYG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcblxuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG5cbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXksIHNvIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHJvdXRlIHRyZWUgZGVwdGgtZmlyc3QgYW5kIGNoaWxkIHJvdXRlcyBhcHBlYXIgYmVmb3JlIHRoZWlyIHBhcmVudHMgaW5cbiAgICAvLyB0aGUgXCJmbGF0dGVuZWRcIiB2ZXJzaW9uLlxuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBgICtcbiAgICAgICAgICBgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcblxuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIFJvdXRlcyB3aXRob3V0IGEgcGF0aCBzaG91bGRuJ3QgZXZlciBtYXRjaCBieSB0aGVtc2VsdmVzIHVubGVzcyB0aGV5IGFyZVxuICAgIC8vIGluZGV4IHJvdXRlcywgc28gZG9uJ3QgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcG9zc2libGUgYnJhbmNoZXMuXG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGEsXG4gICAgfSk7XG4gIH07XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICAvLyBjb2Fyc2UtZ3JhaW4gY2hlY2sgZm9yIG9wdGlvbmFsIHBhcmFtc1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICFyb3V0ZS5wYXRoPy5pbmNsdWRlcyhcIj9cIikpIHtcbiAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBleHBsb2RlZCBvZiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyb3V0ZS5wYXRoKSkge1xuICAgICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4LCBleHBsb2RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYnJhbmNoZXM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYWxsIGNvbWJpbmF0aW9ucyBvZiBvcHRpb25hbCBwYXRoIHNlZ21lbnRzIGZvciBhIGdpdmVuIHBhdGgsXG4gKiBleGNsdWRpbmcgY29tYmluYXRpb25zIHRoYXQgYXJlIGFtYmlndW91cyBhbmQgb2YgbG93ZXIgcHJpb3JpdHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGAvb25lLzp0d28/L3RocmVlLzpmb3VyPy86Zml2ZT9gIGV4cGxvZGVzIHRvOlxuICogLSBgL29uZS90aHJlZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS90aHJlZS86Zm91ci86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91ci86Zml2ZWBcbiAqL1xuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gc2VnbWVudHM7XG5cbiAgLy8gT3B0aW9uYWwgcGF0aCBzZWdtZW50cyBhcmUgZGVub3RlZCBieSBhIHRyYWlsaW5nIGA/YFxuICBsZXQgaXNPcHRpb25hbCA9IGZpcnN0LmVuZHNXaXRoKFwiP1wiKTtcbiAgLy8gQ29tcHV0ZSB0aGUgY29ycmVzcG9uZGluZyByZXF1aXJlZCBzZWdtZW50OiBgZm9vP2AgLT4gYGZvb2BcbiAgbGV0IHJlcXVpcmVkID0gZmlyc3QucmVwbGFjZSgvXFw/JC8sIFwiXCIpO1xuXG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEludGVwcmV0IGVtcHR5IHN0cmluZyBhcyBvbWl0dGluZyBhbiBvcHRpb25hbCBzZWdtZW50XG4gICAgLy8gYFtcIm9uZVwiLCBcIlwiLCBcInRocmVlXCJdYCBjb3JyZXNwb25kcyB0byBvbWl0dGluZyBgOnR3b2AgZnJvbSBgL29uZS86dHdvPy90aHJlZWAgLT4gYC9vbmUvdGhyZWVgXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuXG4gIGxldCByZXN0RXhwbG9kZWQgPSBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyZXN0LmpvaW4oXCIvXCIpKTtcblxuICBsZXQgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIEFsbCBjaGlsZCBwYXRocyB3aXRoIHRoZSBwcmVmaXguICBEbyB0aGlzIGZvciBhbGwgY2hpbGRyZW4gYmVmb3JlIHRoZVxuICAvLyBvcHRpb25hbCB2ZXJzaW9uIGZvciBhbGwgY2hpbGRyZW4sIHNvIHdlIGdldCBjb25zaXN0ZW50IG9yZGVyaW5nIHdoZXJlIHRoZVxuICAvLyBwYXJlbnQgb3B0aW9uYWwgYXNwZWN0IGlzIHByZWZlcnJlZCBhcyByZXF1aXJlZC4gIE90aGVyd2lzZSwgd2UgY2FuIGdldFxuICAvLyBjaGlsZCBzZWN0aW9ucyBpbnRlcnNwZXJzZWQgd2hlcmUgZGVlcGVyIG9wdGlvbmFsIHNlZ21lbnRzIGFyZSBoaWdoZXIgdGhhblxuICAvLyBwYXJlbnQgb3B0aW9uYWwgc2VnbWVudHMsIHdoZXJlIGZvciBleGFtcGxlLCAvOnR3byB3b3VsZCBleHBsb2RlIF9lYXJsaWVyX1xuICAvLyB0aGVuIC86b25lLiAgQnkgYWx3YXlzIGluY2x1ZGluZyB0aGUgcGFyZW50IGFzIHJlcXVpcmVkIF9mb3IgYWxsIGNoaWxkcmVuX1xuICAvLyBmaXJzdCwgd2UgYXZvaWQgdGhpcyBpc3N1ZVxuICByZXN1bHQucHVzaChcbiAgICAuLi5yZXN0RXhwbG9kZWQubWFwKChzdWJwYXRoKSA9PlxuICAgICAgc3VicGF0aCA9PT0gXCJcIiA/IHJlcXVpcmVkIDogW3JlcXVpcmVkLCBzdWJwYXRoXS5qb2luKFwiL1wiKVxuICAgIClcbiAgKTtcblxuICAvLyBUaGVuLCBpZiB0aGlzIGlzIGFuIG9wdGlvbmFsIHZhbHVlLCBhZGQgYWxsIGNoaWxkIHZlcnNpb25zIHdpdGhvdXRcbiAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICByZXN1bHQucHVzaCguLi5yZXN0RXhwbG9kZWQpO1xuICB9XG5cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcCgoZXhwbG9kZWQpID0+XG4gICAgcGF0aC5zdGFydHNXaXRoKFwiL1wiKSAmJiBleHBsb2RlZCA9PT0gXCJcIiA/IFwiL1wiIDogZXhwbG9kZWRcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10pOiB2b2lkIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT5cbiAgICBhLnNjb3JlICE9PSBiLnNjb3JlXG4gICAgICA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgICAgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgICAgIGIucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICAgICAgKVxuICApO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSAoczogc3RyaW5nKSA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGg6IHN0cmluZywgaW5kZXg6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG5cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoc2NvcmUsIHNlZ21lbnQpID0+XG4gICAgICAgIHNjb3JlICtcbiAgICAgICAgKHBhcmFtUmUudGVzdChzZWdtZW50KVxuICAgICAgICAgID8gZHluYW1pY1NlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc2VnbWVudCA9PT0gXCJcIlxuICAgICAgICAgID8gZW1wdHlTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgICBpbml0aWFsU2NvcmVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgc2libGluZ3MgPVxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG5cbiAgcmV0dXJuIHNpYmxpbmdzXG4gICAgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICAgOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAgIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgYnJhbmNoOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+LFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT5bXSB8IG51bGwge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG5cbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlczogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBwYXRobmFtZVxuICAgICAgICA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcblxuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG5cbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyBhcyBQYXJhbXM8UGFyYW1LZXk+LFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGUsXG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aDxQYXRoIGV4dGVuZHMgc3RyaW5nPihcbiAgb3JpZ2luYWxQYXRoOiBQYXRoLFxuICBwYXJhbXM6IHtcbiAgICBba2V5IGluIFBhdGhQYXJhbTxQYXRoPl06IHN0cmluZyB8IG51bGw7XG4gIH0gPSB7fSBhcyBhbnlcbik6IHN0cmluZyB7XG4gIGxldCBwYXRoOiBzdHJpbmcgPSBvcmlnaW5hbFBhdGg7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBwYXRoICE9PSBcIipcIiAmJiAhcGF0aC5lbmRzV2l0aChcIi8qXCIpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYCArXG4gICAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgICAgYHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICAgICk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgYXMgUGF0aDtcbiAgfVxuXG4gIC8vIGVuc3VyZSBgL2AgaXMgYWRkZWQgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZVxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xuXG4gIGNvbnN0IHN0cmluZ2lmeSA9IChwOiBhbnkpID0+XG4gICAgcCA9PSBudWxsID8gXCJcIiA6IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8gcCA6IFN0cmluZyhwKTtcblxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhcbiAgICAuc3BsaXQoL1xcLysvKVxuICAgIC5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgICAvLyBvbmx5IGFwcGx5IHRoZSBzcGxhdCBpZiBpdCdzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgIGlmIChpc0xhc3RTZWdtZW50ICYmIHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBcIipcIiBhcyBQYXRoUGFyYW08UGF0aD47XG4gICAgICAgIC8vIEFwcGx5IHRoZSBzcGxhdFxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtc1tzdGFyXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleU1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW1xcdy1dKykoXFw/PykkLyk7XG4gICAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgICAgY29uc3QgWywga2V5LCBvcHRpb25hbF0gPSBrZXlNYXRjaDtcbiAgICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleSBhcyBQYXRoUGFyYW08UGF0aD5dO1xuICAgICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgYW55IG9wdGlvbmFsIG1hcmtlcnMgZnJvbSBvcHRpb25hbCBzdGF0aWMgc2VnbWVudHNcbiAgICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gICAgfSlcbiAgICAvLyBSZW1vdmUgZW1wdHkgc2VnbWVudHNcbiAgICAuZmlsdGVyKChzZWdtZW50KSA9PiAhIXNlZ21lbnQpO1xuXG4gIHJldHVybiBwcmVmaXggKyBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cblxuLyoqXG4gKiBBIFBhdGhQYXR0ZXJuIGlzIHVzZWQgdG8gbWF0Y2ggb24gc29tZSBwb3J0aW9uIG9mIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhQYXR0ZXJuPFBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3QgYSBVUkwgcGF0aG5hbWUuIE1heSBjb250YWluIGA6aWRgLXN0eWxlIHNlZ21lbnRzXG4gICAqIHRvIGluZGljYXRlIHBsYWNlaG9sZGVycyBmb3IgZHluYW1pYyBwYXJhbWV0ZXJzLiBNYXkgYWxzbyBlbmQgd2l0aCBgLypgIHRvXG4gICAqIGluZGljYXRlIG1hdGNoaW5nIHRoZSByZXN0IG9mIHRoZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBwYXRoOiBQYXRoO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGUgc3RhdGljIHBvcnRpb25zIG9mIHRoZSBgcGF0aGAgc2hvdWxkIGJlIG1hdGNoZWQgaW5cbiAgICogdGhlIHNhbWUgY2FzZS5cbiAgICovXG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGlzIHBhdHRlcm4gc2hvdWxkIG1hdGNoIHRoZSBlbnRpcmUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgZW5kPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIFBhdGhNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIFBhdGhQYXR0ZXJuIG1hdGNoZWQgb24gYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aE1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuO1xufVxuXG50eXBlIE11dGFibGU8VD4gPSB7XG4gIC1yZWFkb25seSBbUCBpbiBrZXlvZiBUXTogVFtQXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxuICogdGhlIG1hdGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hQYXRoPFxuICBQYXJhbUtleSBleHRlbmRzIFBhcmFtUGFyc2VLZXk8UGF0aD4sXG4gIFBhdGggZXh0ZW5kcyBzdHJpbmdcbj4oXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuPFBhdGg+IHwgUGF0aCxcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogUGF0aE1hdGNoPFBhcmFtS2V5PiB8IG51bGwge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0geyBwYXRoOiBwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlOiBmYWxzZSwgZW5kOiB0cnVlIH07XG4gIH1cblxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gY29tcGlsZWRQYXJhbXMucmVkdWNlPE11dGFibGU8UGFyYW1zPj4oXG4gICAgKG1lbW8sIHsgcGFyYW1OYW1lLCBpc09wdGlvbmFsIH0sIGluZGV4KSA9PiB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIHBhdGhuYW1lQmFzZSBoZXJlIHVzaW5nIHRoZSByYXcgc3BsYXQgdmFsdWVcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xuICAgICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZVxuICAgICAgICAgIC5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICAgIGlmIChpc09wdGlvbmFsICYmICF2YWx1ZSkge1xuICAgICAgICBtZW1vW3BhcmFtTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vW3BhcmFtTmFtZV0gPSAodmFsdWUgfHwgXCJcIikucmVwbGFjZSgvJTJGL2csIFwiL1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuLFxuICB9O1xufVxuXG50eXBlIENvbXBpbGVkUGF0aFBhcmFtID0geyBwYXJhbU5hbWU6IHN0cmluZzsgaXNPcHRpb25hbD86IGJvb2xlYW4gfTtcblxuZnVuY3Rpb24gY29tcGlsZVBhdGgoXG4gIHBhdGg6IHN0cmluZyxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICBlbmQgPSB0cnVlXG4pOiBbUmVnRXhwLCBDb21waWxlZFBhdGhQYXJhbVtdXSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG5cbiAgbGV0IHBhcmFtczogQ29tcGlsZWRQYXRoUGFyYW1bXSA9IFtdO1xuICBsZXQgcmVnZXhwU291cmNlID1cbiAgICBcIl5cIiArXG4gICAgcGF0aFxuICAgICAgLnJlcGxhY2UoL1xcLypcXCo/JC8sIFwiXCIpIC8vIElnbm9yZSB0cmFpbGluZyAvIGFuZCAvKiwgd2UnbGwgaGFuZGxlIGl0IGJlbG93XG4gICAgICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAgICAgLnJlcGxhY2UoL1tcXFxcLiorXiR7fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gICAgICAucmVwbGFjZShcbiAgICAgICAgL1xcLzooW1xcdy1dKykoXFw/KT8vZyxcbiAgICAgICAgKF86IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgICBwYXJhbXMucHVzaCh7IHBhcmFtTmFtZSwgaXNPcHRpb25hbDogaXNPcHRpb25hbCAhPSBudWxsIH0pO1xuICAgICAgICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbXMucHVzaCh7IHBhcmFtTmFtZTogXCIqXCIgfSk7XG4gICAgcmVnZXhwU291cmNlICs9XG4gICAgICBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCJcbiAgICAgICAgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICAgICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCwgc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3RoaW5nIHRvIG1hdGNoIGZvciBcIlwiIG9yIFwiL1wiXG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1zXTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUGF0aCh2YWx1ZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAubWFwKCh2KSA9PiBkZWNvZGVVUklDb21wb25lbnQodikucmVwbGFjZSgvXFwvL2csIFwiJTJGXCIpKVxuICAgICAgLmpvaW4oXCIvXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBgICtcbiAgICAgICAgYG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBgICtcbiAgICAgICAgYGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgYmFzZW5hbWU6IHN0cmluZ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIilcbiAgICA/IGJhc2VuYW1lLmxlbmd0aCAtIDFcbiAgICA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgLy8gcGF0aG5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCBiYXNlbmFtZS9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvcmVzb2x2ZS1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aCh0bzogVG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKTogUGF0aCB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcblxuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lXG4gICAgPyB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpXG4gICAgICA/IHRvUGF0aG5hbWVcbiAgICAgIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSlcbiAgICA6IGZyb21QYXRobmFtZTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaDogbm9ybWFsaXplU2VhcmNoKHNlYXJjaCksXG4gICAgaGFzaDogbm9ybWFsaXplSGFzaChoYXNoKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aDogc3RyaW5nLCBmcm9tUGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuXG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLmpvaW4oXCIvXCIpIDogXCIvXCI7XG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRQYXRoRXJyb3IoXG4gIGNoYXI6IHN0cmluZyxcbiAgZmllbGQ6IHN0cmluZyxcbiAgZGVzdDogc3RyaW5nLFxuICBwYXRoOiBQYXJ0aWFsPFBhdGg+XG4pIHtcbiAgcmV0dXJuIChcbiAgICBgQ2Fubm90IGluY2x1ZGUgYSAnJHtjaGFyfScgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIGAgK1xuICAgIGBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHBhdGhcbiAgICApfV0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBgICtcbiAgICBgXFxgdG8uJHtkZXN0fVxcYCBmaWVsZC4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHByb3ZpZGUgdGhlIGZ1bGwgcGF0aCBhcyBgICtcbiAgICBgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmBcbiAgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFdoZW4gcHJvY2Vzc2luZyByZWxhdGl2ZSBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gaWdub3JlIGFuY2VzdG9yIHJvdXRlcyB0aGF0XG4gKiBkbyBub3QgY29udHJpYnV0ZSB0byB0aGUgcGF0aCwgc3VjaCB0aGF0IGluZGV4L3BhdGhsZXNzIGxheW91dCByb3V0ZXMgZG9uJ3RcbiAqIGludGVyZmVyZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiBtb3ZpbmcgYSByb3V0ZSBlbGVtZW50IGludG8gYW4gaW5kZXggcm91dGUgYW5kL29yIGFcbiAqIHBhdGhsZXNzIGxheW91dCByb3V0ZSwgcmVsYXRpdmUgbGluayBiZWhhdmlvciBjb250YWluZWQgd2l0aGluIHNob3VsZCBzdGF5XG4gKiB0aGUgc2FtZS4gIEJvdGggb2YgdGhlIGZvbGxvd2luZyBleGFtcGxlcyBzaG91bGQgbGluayBiYWNrIHRvIHRoZSByb290OlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiIGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0+XG4gKiAgIDwvUm91dGU+XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCI+XG4gKiAgICAgICA8Um91dGUgZWxlbWVudD17PEFjY291bnRzTGF5b3V0IC8+fT4gICAgICAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgICAgPFJvdXRlIGluZGV4IGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0gLz4gIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICA8L1JvdXRlXG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgPC9Sb3V0ZT5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzPFxuICBUIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoID0gQWdub3N0aWNSb3V0ZU1hdGNoXG4+KG1hdGNoZXM6IFRbXSkge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoXG4gICAgKG1hdGNoLCBpbmRleCkgPT5cbiAgICAgIGluZGV4ID09PSAwIHx8IChtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMClcbiAgKTtcbn1cblxuLy8gUmV0dXJuIHRoZSBhcnJheSBvZiBwYXRobmFtZXMgZm9yIHRoZSBjdXJyZW50IHJvdXRlIG1hdGNoZXMgLSB1c2VkIHRvXG4vLyBnZW5lcmF0ZSB0aGUgcm91dGVQYXRobmFtZXMgaW5wdXQgZm9yIHJlc29sdmVUbygpXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlczxcbiAgVCBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaCA9IEFnbm9zdGljUm91dGVNYXRjaFxuPihtYXRjaGVzOiBUW10sIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBib29sZWFuKSB7XG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuXG4gIC8vIFdoZW4gdjdfcmVsYXRpdmVTcGxhdFBhdGggaXMgZW5hYmxlZCwgdXNlIHRoZSBmdWxsIHBhdGhuYW1lIGZvciB0aGUgbGVhZlxuICAvLyBtYXRjaCBzbyB3ZSBpbmNsdWRlIHNwbGF0IHZhbHVlcyBmb3IgXCIuXCIgbGlua3MuICBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMTA1MiNpc3N1ZWNvbW1lbnQtMTgzNjU4OTMyOVxuICBpZiAodjdfcmVsYXRpdmVTcGxhdFBhdGgpIHtcbiAgICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKChtYXRjaCwgaWR4KSA9PlxuICAgICAgaWR4ID09PSBtYXRjaGVzLmxlbmd0aCAtIDEgPyBtYXRjaC5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVRvKFxuICB0b0FyZzogVG8sXG4gIHJvdXRlUGF0aG5hbWVzOiBzdHJpbmdbXSxcbiAgbG9jYXRpb25QYXRobmFtZTogc3RyaW5nLFxuICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlXG4pOiBQYXRoIHtcbiAgbGV0IHRvOiBQYXJ0aWFsPFBhdGg+O1xuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG8gPSBwYXJzZVBhdGgodG9BcmcpO1xuICB9IGVsc2Uge1xuICAgIHRvID0geyAuLi50b0FyZyB9O1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuXG4gIGxldCBpc0VtcHR5UGF0aCA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiO1xuICBsZXQgdG9QYXRobmFtZSA9IGlzRW1wdHlQYXRoID8gXCIvXCIgOiB0by5wYXRobmFtZTtcblxuICBsZXQgZnJvbTogc3RyaW5nO1xuXG4gIC8vIFJvdXRpbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGF0aG5hbWUgaWYgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG4gIC8vXG4gIC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cbiAgaWYgKHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuXG4gICAgLy8gV2l0aCByZWxhdGl2ZT1cInJvdXRlXCIgKHRoZSBkZWZhdWx0KSwgZWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnNcbiAgICAvLyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmUgVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXlcbiAgICAvLyBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYVxuICAgIC8vIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuXG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG5cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG5cbiAgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgXCJ0b1wiIGhhZCBvbmVcbiAgbGV0IGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCA9XG4gICAgdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgLy8gT3IgaWYgdGhpcyB3YXMgYSBsaW5rIHRvIHRoZSBjdXJyZW50IHBhdGggd2hpY2ggaGFzIGEgdHJhaWxpbmcgc2xhc2hcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID1cbiAgICAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoXG4gICAgIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgKGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCB8fCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaClcbiAgKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvOiBUbyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgKHRvIGFzIFBhdGgpLnBhdGhuYW1lID09PSBcIlwiXG4gICAgPyBcIi9cIlxuICAgIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiXG4gICAgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lXG4gICAgOiB0by5wYXRobmFtZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgam9pblBhdGhzID0gKHBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyA9PlxuICBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiXG4gICAgPyBcIlwiXG4gICAgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIilcbiAgICA/IHNlYXJjaFxuICAgIDogXCI/XCIgKyBzZWFyY2g7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUhhc2ggPSAoaGFzaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuXG5leHBvcnQgdHlwZSBKc29uRnVuY3Rpb24gPSA8RGF0YT4oXG4gIGRhdGE6IERhdGEsXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gUmVzcG9uc2U7XG5cbi8qKlxuICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBjcmVhdGluZyBgYXBwbGljYXRpb24vanNvbmAgcmVzcG9uc2VzLiBDb252ZXJ0cyBgZGF0YWBcbiAqIHRvIEpTT04gYW5kIHNldHMgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGpzb246IEpzb25GdW5jdGlvbiA9IChkYXRhLCBpbml0ID0ge30pID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXQ7XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnMsXG4gIH0pO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja2VkUHJvbWlzZSBleHRlbmRzIFByb21pc2U8YW55PiB7XG4gIF90cmFja2VkPzogYm9vbGVhbjtcbiAgX2RhdGE/OiBhbnk7XG4gIF9lcnJvcj86IGFueTtcbn1cblxuZXhwb3J0IGNsYXNzIEFib3J0ZWREZWZlcnJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIERlZmVycmVkRGF0YSB7XG4gIHByaXZhdGUgcGVuZGluZ0tleXNTZXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHByaXZhdGUgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xuICBwcml2YXRlIGFib3J0UHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgcHJpdmF0ZSB1bmxpc3RlbkFib3J0U2lnbmFsOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIHN1YnNjcmliZXJzOiBTZXQ8KGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpID0+IHZvaWQ+ID1cbiAgICBuZXcgU2V0KCk7XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICBpbml0PzogUmVzcG9uc2VJbml0O1xuICBkZWZlcnJlZEtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHJlc3BvbnNlSW5pdD86IFJlc3BvbnNlSW5pdCkge1xuICAgIGludmFyaWFudChcbiAgICAgIGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSksXG4gICAgICBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIlxuICAgICk7XG5cbiAgICAvLyBTZXQgdXAgYW4gQWJvcnRDb250cm9sbGVyICsgUHJvbWlzZSB3ZSBjYW4gcmFjZSBhZ2FpbnN0IHRvIGV4aXQgZWFybHlcbiAgICAvLyBjYW5jZWxsYXRpb25cbiAgICBsZXQgcmVqZWN0OiAoZTogQWJvcnRlZERlZmVycmVkRXJyb3IpID0+IHZvaWQ7XG4gICAgdGhpcy5hYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PlxuICAgICAgcmVqZWN0KG5ldyBBYm9ydGVkRGVmZXJyZWRFcnJvcihcIkRlZmVycmVkIGRhdGEgYWJvcnRlZFwiKSk7XG4gICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsID0gKCkgPT5cbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuXG4gICAgdGhpcy5kYXRhID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB0aGlzLnRyYWNrUHJvbWlzZShrZXksIHZhbHVlKSxcbiAgICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBBbGwgaW5jb21pbmcgdmFsdWVzIHdlcmUgcmVzb2x2ZWRcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCA9IHJlc3BvbnNlSW5pdDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhY2tQcm9taXNlKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93blxuICApOiBUcmFja2VkUHJvbWlzZSB8IHVua25vd24ge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmVycmVkS2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5hZGQoa2V5KTtcblxuICAgIC8vIFdlIHN0b3JlIGEgbGl0dGxlIHdyYXBwZXIgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aFxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XG4gICAgbGV0IHByb21pc2U6IFRyYWNrZWRQcm9taXNlID0gUHJvbWlzZS5yYWNlKFt2YWx1ZSwgdGhpcy5hYm9ydFByb21pc2VdKS50aGVuKFxuICAgICAgKGRhdGEpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCB1bmRlZmluZWQsIGRhdGEgYXMgdW5rbm93biksXG4gICAgICAoZXJyb3IpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvciBhcyB1bmtub3duKVxuICAgICk7XG5cbiAgICAvLyBSZWdpc3RlciByZWplY3Rpb24gbGlzdGVuZXJzIHRvIGF2b2lkIHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0aW9ucyBvblxuICAgIC8vIGVycm9ycyBvciBhYm9ydGVkIGRlZmVycmVkIHZhbHVlc1xuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIG9uU2V0dGxlKFxuICAgIHByb21pc2U6IFRyYWNrZWRQcm9taXNlLFxuICAgIGtleTogc3RyaW5nLFxuICAgIGVycm9yOiB1bmtub3duLFxuICAgIGRhdGE/OiB1bmtub3duXG4gICk6IHVua25vd24ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvclxuICAgICkge1xuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkL3JlamVjdGVkIHdpdGggdW5kZWZpbmVkLCB3ZSdsbCB0aHJvdyBhbiBlcnJvciBhcyB5b3VcbiAgICAvLyBzaG91bGQgYWx3YXlzIHJlc29sdmUgd2l0aCBhIHZhbHVlIG9yIG51bGxcbiAgICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB1bmRlZmluZWRFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYERlZmVycmVkIGRhdGEgZm9yIGtleSBcIiR7a2V5fVwiIHJlc29sdmVkL3JlamVjdGVkIHdpdGggXFxgdW5kZWZpbmVkXFxgLCBgICtcbiAgICAgICAgICBgeW91IG11c3QgcmVzb2x2ZS9yZWplY3Qgd2l0aCBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYFxuICAgICAgKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gdW5kZWZpbmVkRXJyb3IgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodW5kZWZpbmVkRXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiBkYXRhIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuXG4gIHN1YnNjcmliZShmbjogKGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGspKTtcbiAgICB0aGlzLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWw6IEFib3J0U2lnbmFsKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIGFib3J0ZWQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cblxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nS2V5c1NldC5zaXplID09PSAwO1xuICB9XG5cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSxcbiAgICAgIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCJcbiAgICApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgZ2V0IHBlbmRpbmdLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ0tleXNTZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFRyYWNrZWRQcm9taXNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgKHZhbHVlIGFzIFRyYWNrZWRQcm9taXNlKS5fdHJhY2tlZCA9PT0gdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZTogYW55KSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cblxuZXhwb3J0IHR5cGUgRGVmZXJGdW5jdGlvbiA9IChcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gRGVmZXJyZWREYXRhO1xuXG5leHBvcnQgY29uc3QgZGVmZXI6IERlZmVyRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEZ1bmN0aW9uID0gKFxuICB1cmw6IHN0cmluZyxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0OiBSZWRpcmVjdEZ1bmN0aW9uID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UgdGhhdCB3aWxsIGZvcmNlIGEgZG9jdW1lbnQgcmVsb2FkIHRvIHRoZSBuZXcgbG9jYXRpb24uXG4gKiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0RG9jdW1lbnQ6IFJlZGlyZWN0RnVuY3Rpb24gPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG5leHBvcnQgdHlwZSBFcnJvclJlc3BvbnNlID0ge1xuICBzdGF0dXM6IG51bWJlcjtcbiAgc3RhdHVzVGV4dDogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKlxuICogV2UgZG9uJ3QgZXhwb3J0IHRoZSBjbGFzcyBmb3IgcHVibGljIHVzZSBzaW5jZSBpdCdzIGFuIGltcGxlbWVudGF0aW9uXG4gKiBkZXRhaWwsIGJ1dCB3ZSBleHBvcnQgdGhlIGludGVyZmFjZSBhYm92ZSBzbyBmb2xrcyBjYW4gYnVpbGQgdGhlaXIgb3duXG4gKiBhYnN0cmFjdGlvbnMgYXJvdW5kIGluc3RhbmNlcyB2aWEgaXNSb3V0ZUVycm9yUmVzcG9uc2UoKVxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JSZXNwb25zZUltcGwgaW1wbGVtZW50cyBFcnJvclJlc3BvbnNlIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIHN0YXR1c1RleHQ6IHN0cmluZztcbiAgZGF0YTogYW55O1xuICBwcml2YXRlIGVycm9yPzogRXJyb3I7XG4gIHByaXZhdGUgaW50ZXJuYWw6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzOiBudW1iZXIsXG4gICAgc3RhdHVzVGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGRhdGE6IGFueSxcbiAgICBpbnRlcm5hbCA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcjogYW55KTogZXJyb3IgaXMgRXJyb3JSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgZXJyb3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiZcbiAgICB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiZcbiAgICBcImRhdGFcIiBpbiBlcnJvclxuICApO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBIaXN0b3J5LCBMb2NhdGlvbiwgUGF0aCwgVG8gfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgSGlzdG9yeUFjdGlvbixcbiAgY3JlYXRlTG9jYXRpb24sXG4gIGNyZWF0ZVBhdGgsXG4gIGludmFyaWFudCxcbiAgcGFyc2VQYXRoLFxuICB3YXJuaW5nLFxufSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0LFxuICBEYXRhU3RyYXRlZ3lNYXRjaCxcbiAgQWdub3N0aWNSb3V0ZU9iamVjdCxcbiAgRGF0YVJlc3VsdCxcbiAgRGF0YVN0cmF0ZWd5RnVuY3Rpb24sXG4gIERhdGFTdHJhdGVneUZ1bmN0aW9uQXJncyxcbiAgRGVmZXJyZWREYXRhLFxuICBEZWZlcnJlZFJlc3VsdCxcbiAgRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uLFxuICBFcnJvclJlc3VsdCxcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIEhUTUxGb3JtTWV0aG9kLFxuICBIYW5kbGVyUmVzdWx0LFxuICBJbW11dGFibGVSb3V0ZUtleSxcbiAgTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24sXG4gIE11dGF0aW9uRm9ybU1ldGhvZCxcbiAgUmVkaXJlY3RSZXN1bHQsXG4gIFJvdXRlRGF0YSxcbiAgUm91dGVNYW5pZmVzdCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyxcbiAgU3VibWlzc2lvbixcbiAgU3VjY2Vzc1Jlc3VsdCxcbiAgVUlNYXRjaCxcbiAgVjdfRm9ybU1ldGhvZCxcbiAgVjdfTXV0YXRpb25Gb3JtTWV0aG9kLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHtcbiAgRXJyb3JSZXNwb25zZUltcGwsXG4gIFJlc3VsdFR5cGUsXG4gIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoLFxuICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzLFxuICBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyxcbiAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyxcbiAgaW1tdXRhYmxlUm91dGVLZXlzLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgam9pblBhdGhzLFxuICBtYXRjaFJvdXRlcyxcbiAgcmVzb2x2ZVRvLFxuICBzdHJpcEJhc2VuYW1lLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBSb3V0ZXIgaW5zdGFuY2UgbWFuYWdlcyBhbGwgbmF2aWdhdGlvbiBhbmQgZGF0YSBsb2FkaW5nL211dGF0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlciB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBiYXNlbmFtZSBmb3IgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IGJhc2VuYW1lKCk6IFJvdXRlckluaXRbXCJiYXNlbmFtZVwiXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgZnV0dXJlIGNvbmZpZyBmb3IgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IGZ1dHVyZSgpOiBGdXR1cmVDb25maWc7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFJvdXRlclN0YXRlO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSByb3V0ZXMgZm9yIHRoaXMgcm91dGVyIGluc3RhbmNlXG4gICAqL1xuICBnZXQgcm91dGVzKCk6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IHdpbmRvdygpOiBSb3V0ZXJJbml0W1wid2luZG93XCJdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBpbmNsdWRpbmcgYWRkaW5nIGhpc3RvcnkgbGlzdGVuZXJzIGFuZCBraWNraW5nIG9mZlxuICAgKiBpbml0aWFsIGRhdGEgZmV0Y2hlcy4gIFJldHVybnMgYSBmdW5jdGlvbiB0byBjbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnRcbiAgICogYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBpbml0aWFsaXplKCk6IFJvdXRlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFN1YnNjcmliZSB0byByb3V0ZXIuc3RhdGUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBuZXcgc3RhdGVcbiAgICovXG4gIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcik6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGJlaGF2aW9yIGluIHRoZSByb3V0ZXJcbiAgICpcbiAgICogQHBhcmFtIHNhdmVkU2Nyb2xsUG9zaXRpb25zIE9iamVjdCB0aGF0IHdpbGwgbWFuYWdlIHBvc2l0aW9ucywgaW4gY2FzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQncyBiZWluZyByZXN0b3JlZCBmcm9tIHNlc3Npb25TdG9yYWdlXG4gICAqIEBwYXJhbSBnZXRTY3JvbGxQb3NpdGlvbiAgICBGdW5jdGlvbiB0byBnZXQgdGhlIGFjdGl2ZSBZIHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZ2V0S2V5ICAgICAgICAgICAgICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgdG8gdXNlIGZvciByZXN0b3JhdGlvblxuICAgKi9cbiAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogTmF2aWdhdGUgZm9yd2FyZC9iYWNrd2FyZCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBAcGFyYW0gdG8gRGVsdGEgdG8gbW92ZSBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgbmF2aWdhdGUodG86IG51bWJlcik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBnaXZlbiBwYXRoXG4gICAqIEBwYXJhbSB0byBQYXRoIHRvIG5hdmlnYXRlIHRvXG4gICAqIEBwYXJhbSBvcHRzIE5hdmlnYXRpb24gb3B0aW9ucyAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgbmF2aWdhdGUodG86IFRvIHwgbnVsbCwgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pc3Npb25cbiAgICpcbiAgICogQHBhcmFtIGtleSAgICAgRmV0Y2hlciBrZXlcbiAgICogQHBhcmFtIHJvdXRlSWQgUm91dGUgdGhhdCBvd25zIHRoZSBmZXRjaGVyXG4gICAqIEBwYXJhbSBocmVmICAgIGhyZWYgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdHMgICAgRmV0Y2hlciBvcHRpb25zLCAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgZmV0Y2goXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGhyZWY6IHN0cmluZyB8IG51bGwsXG4gICAgb3B0cz86IFJvdXRlckZldGNoT3B0aW9uc1xuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIHJldmFsaWRhdGlvbiBvZiBhbGwgY3VycmVudCByb3V0ZSBsb2FkZXJzIGFuZCBmZXRjaGVyIGxvYWRzXG4gICAqL1xuICByZXZhbGlkYXRlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBocmVmIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb25cbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqL1xuICBjcmVhdGVIcmVmKGxvY2F0aW9uOiBMb2NhdGlvbiB8IFVSTCk6IHN0cmluZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gVVJMIGVuY29kZSBhIGRlc3RpbmF0aW9uIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBoaXN0b3J5IGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB0b1xuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEdldC9jcmVhdGUgYSBmZXRjaGVyIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIGdldEZldGNoZXI8VERhdGEgPSBhbnk+KGtleTogc3RyaW5nKTogRmV0Y2hlcjxURGF0YT47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBEZWxldGUgdGhlIGZldGNoZXIgZm9yIGEgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIGRlbGV0ZUZldGNoZXIoa2V5OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogQ2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0IGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogR2V0IGEgbmF2aWdhdGlvbiBibG9ja2VyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2VyXG4gICAqIEBwYXJhbSBmbiBUaGUgYmxvY2tlciBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbik6IEJsb2NrZXI7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBEZWxldGUgYSBuYXZpZ2F0aW9uIGJsb2NrZXJcbiAgICogQHBhcmFtIGtleSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrZXJcbiAgICovXG4gIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSE1SIG5lZWRzIHRvIHBhc3MgaW4tZmxpZ2h0IHJvdXRlIHVwZGF0ZXMgdG8gUmVhY3QgUm91dGVyXG4gICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGdyYW51bGFyIHJvdXRlIHVwZGF0ZSBBUElzIChhZGRSb3V0ZSwgdXBkYXRlUm91dGUsIGRlbGV0ZVJvdXRlKVxuICAgKi9cbiAgX2ludGVybmFsU2V0Um91dGVzKHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIGZldGNoIEFib3J0Q29udHJvbGxlcnMgYWNjZXNzZWQgYnkgdW5pdCB0ZXN0c1xuICAgKi9cbiAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIHBlbmRpbmcgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT47XG59XG5cbi8qKlxuICogU3RhdGUgbWFpbnRhaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSByb3V0ZXIuICBEdXJpbmcgYSBuYXZpZ2F0aW9uLCBhbGwgc3RhdGVzXG4gKiByZWZsZWN0IHRoZSB0aGUgXCJvbGRcIiBsb2NhdGlvbiB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gb2YgdGhlIG1vc3QgcmVjZW50IG5hdmlnYXRpb25cbiAgICovXG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uIHJlZmxlY3RlZCBieSB0aGUgcm91dGVyXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNldCBvZiByb3V0ZSBtYXRjaGVzXG4gICAqL1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHdlJ3ZlIGNvbXBsZXRlZCBvdXIgaW5pdGlhbCBkYXRhIGxvYWRcbiAgICovXG4gIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB3ZSBzaG91bGQgc3RhcnQgYXQgZm9yIGEgbmV3IHZpZXdcbiAgICogIC0gbnVtYmVyIC0+IHNjcm9sbCBwb3NpdGlvbiB0byByZXN0b3JlIHRvXG4gICAqICAtIGZhbHNlIC0+IGRvIG5vdCByZXN0b3JlIHNjcm9sbCBhdCBhbGwgKHVzZWQgZHVyaW5nIHN1Ym1pc3Npb25zKVxuICAgKiAgLSBudWxsIC0+IGRvbid0IGhhdmUgYSBzYXZlZCBwb3NpdGlvbiwgc2Nyb2xsIHRvIGhhc2ggb3IgdG9wIG9mIHBhZ2VcbiAgICovXG4gIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVtYmVyIHwgZmFsc2UgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgbmF2aWdhdGlvbiBzaG91bGQgc2tpcCByZXNldHRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKiBpZiB3ZSBhcmUgdW5hYmxlIHRvIHJlc3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKi9cbiAgcHJldmVudFNjcm9sbFJlc2V0OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IG5hdmlnYXRpb25cbiAgICovXG4gIG5hdmlnYXRpb246IE5hdmlnYXRpb247XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBhbnkgaW4tcHJvZ3Jlc3MgcmV2YWxpZGF0aW9uc1xuICAgKi9cbiAgcmV2YWxpZGF0aW9uOiBSZXZhbGlkYXRpb25TdGF0ZTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBsb2FkZXJEYXRhOiBSb3V0ZURhdGE7XG5cbiAgLyoqXG4gICAqIERhdGEgZnJvbSB0aGUgYWN0aW9uIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBhY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBFcnJvcnMgY2F1Z2h0IGZyb20gbG9hZGVycyBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBmZXRjaGVyc1xuICAgKi9cbiAgZmV0Y2hlcnM6IE1hcDxzdHJpbmcsIEZldGNoZXI+O1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBibG9ja2Vyc1xuICAgKi9cbiAgYmxvY2tlcnM6IE1hcDxzdHJpbmcsIEJsb2NrZXI+O1xufVxuXG4vKipcbiAqIERhdGEgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gaHlkcmF0ZSBhIFJvdXRlciBmcm9tIFNTUlxuICovXG5leHBvcnQgdHlwZSBIeWRyYXRpb25TdGF0ZSA9IFBhcnRpYWw8XG4gIFBpY2s8Um91dGVyU3RhdGUsIFwibG9hZGVyRGF0YVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImVycm9yc1wiPlxuPjtcblxuLyoqXG4gKiBGdXR1cmUgZmxhZ3MgdG8gdG9nZ2xlIG5ldyBmZWF0dXJlIGJlaGF2aW9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnV0dXJlQ29uZmlnIHtcbiAgdjdfZmV0Y2hlclBlcnNpc3Q6IGJvb2xlYW47XG4gIHY3X25vcm1hbGl6ZUZvcm1NZXRob2Q6IGJvb2xlYW47XG4gIHY3X3BhcnRpYWxIeWRyYXRpb246IGJvb2xlYW47XG4gIHY3X3ByZXBlbmRCYXNlbmFtZTogYm9vbGVhbjtcbiAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IGJvb2xlYW47XG4gIHVuc3RhYmxlX3NraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbjogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBvcHRpb25zIGZvciBjcmVhdGVSb3V0ZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJJbml0IHtcbiAgcm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W107XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBtYXBSb3V0ZVByb3BlcnRpZXNgIGluc3RlYWRcbiAgICovXG4gIGRldGVjdEVycm9yQm91bmRhcnk/OiBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb247XG4gIG1hcFJvdXRlUHJvcGVydGllcz86IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uO1xuICBmdXR1cmU/OiBQYXJ0aWFsPEZ1dHVyZUNvbmZpZz47XG4gIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgd2luZG93PzogV2luZG93O1xuICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3k/OiBEYXRhU3RyYXRlZ3lGdW5jdGlvbjtcbn1cblxuLyoqXG4gKiBTdGF0ZSByZXR1cm5lZCBmcm9tIGEgc2VydmVyLXNpZGUgcXVlcnkoKSBjYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlckNvbnRleHQge1xuICBiYXNlbmFtZTogUm91dGVyW1wiYmFzZW5hbWVcIl07XG4gIGxvY2F0aW9uOiBSb3V0ZXJTdGF0ZVtcImxvY2F0aW9uXCJdO1xuICBtYXRjaGVzOiBSb3V0ZXJTdGF0ZVtcIm1hdGNoZXNcIl07XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgYWN0aW9uRGF0YTogUm91dGVyU3RhdGVbXCJhY3Rpb25EYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xuICBhY3Rpb25IZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aXZlRGVmZXJyZWRzOiBSZWNvcmQ8c3RyaW5nLCBEZWZlcnJlZERhdGE+IHwgbnVsbDtcbiAgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQ/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgU3RhdGljSGFuZGxlciBpbnN0YW5jZSBtYW5hZ2VzIGEgc2luZ3VsYXIgU1NSIG5hdmlnYXRpb24vZmV0Y2ggZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyIHtcbiAgZGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBvcHRzPzoge1xuICAgICAgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duO1xuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc/OiBib29sZWFuO1xuICAgICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5PzogRGF0YVN0cmF0ZWd5RnVuY3Rpb247XG4gICAgfVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+O1xuICBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHtcbiAgICAgIHJvdXRlSWQ/OiBzdHJpbmc7XG4gICAgICByZXF1ZXN0Q29udGV4dD86IHVua25vd247XG4gICAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3k/OiBEYXRhU3RyYXRlZ3lGdW5jdGlvbjtcbiAgICB9XG4gICk6IFByb21pc2U8YW55Pjtcbn1cblxudHlwZSBWaWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gIG5leHRMb2NhdGlvbjogTG9jYXRpb247XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgZnVuY3Rpb24gc2lnbmF0dXJlIGZvciBjaGFuZ2VzIHRvIHJvdXRlciBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN1YnNjcmliZXIge1xuICAoXG4gICAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICAgIG9wdHM6IHtcbiAgICAgIGRlbGV0ZWRGZXRjaGVyczogc3RyaW5nW107XG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM/OiBWaWV3VHJhbnNpdGlvbk9wdHM7XG4gICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IGJvb2xlYW47XG4gICAgfVxuICApOiB2b2lkO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIGtleSB0byBiZSB1c2VkIGluIHNjcm9sbCByZXN0b3JhdGlvblxuICogZm9yIGEgZ2l2ZW4gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uIHtcbiAgKGxvY2F0aW9uOiBMb2NhdGlvbiwgbWF0Y2hlczogVUlNYXRjaFtdKTogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIGRldGVybWluaW5nIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24ge1xuICAoKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBSZWxhdGl2ZVJvdXRpbmdUeXBlID0gXCJyb3V0ZVwiIHwgXCJwYXRoXCI7XG5cbi8vIEFsbG93ZWQgZm9yIGFueSBuYXZpZ2F0aW9uIG9yIGZldGNoXG50eXBlIEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zID0ge1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG4gIHVuc3RhYmxlX2ZsdXNoU3luYz86IGJvb2xlYW47XG59O1xuXG4vLyBPbmx5IGFsbG93ZWQgZm9yIG5hdmlnYXRpb25zXG50eXBlIEJhc2VOYXZpZ2F0ZU9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPckZldGNoT3B0aW9ucyAmIHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICBmcm9tUm91dGVJZD86IHN0cmluZztcbiAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24/OiBib29sZWFuO1xufTtcblxuLy8gT25seSBhbGxvd2VkIGZvciBzdWJtaXNzaW9uIG5hdmlnYXRpb25zXG50eXBlIEJhc2VTdWJtaXNzaW9uT3B0aW9ucyA9IHtcbiAgZm9ybU1ldGhvZD86IEhUTUxGb3JtTWV0aG9kO1xuICBmb3JtRW5jVHlwZT86IEZvcm1FbmNUeXBlO1xufSAmIChcbiAgfCB7IGZvcm1EYXRhOiBGb3JtRGF0YTsgYm9keT86IHVuZGVmaW5lZCB9XG4gIHwgeyBmb3JtRGF0YT86IHVuZGVmaW5lZDsgYm9keTogYW55IH1cbik7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgbm9ybWFsIChub24tc3VibWlzc2lvbikgbmF2aWdhdGlvblxuICovXG50eXBlIExpbmtOYXZpZ2F0ZU9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgbmF2aWdhdGUoKSBjYWxsIGZvciBhIHN1Ym1pc3Npb24gbmF2aWdhdGlvblxuICovXG50eXBlIFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPcHRpb25zICYgQmFzZVN1Ym1pc3Npb25PcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBuYXZpZ2F0ZSgpIGZvciBhIG5hdmlnYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyTmF2aWdhdGVPcHRpb25zID1cbiAgfCBMaW5rTmF2aWdhdGVPcHRpb25zXG4gIHwgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIGZldGNoKCkgbG9hZFxuICovXG50eXBlIExvYWRGZXRjaE9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPckZldGNoT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIGZldGNoKCkgc3VibWlzc2lvblxuICovXG50eXBlIFN1Ym1pdEZldGNoT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zICYgQmFzZVN1Ym1pc3Npb25PcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBmZXRjaCgpXG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlckZldGNoT3B0aW9ucyA9IExvYWRGZXRjaE9wdGlvbnMgfCBTdWJtaXRGZXRjaE9wdGlvbnM7XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3Igc3RhdGUubmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uU3RhdGVzID0ge1xuICBJZGxlOiB7XG4gICAgc3RhdGU6IFwiaWRsZVwiO1xuICAgIGxvY2F0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAganNvbjogdW5kZWZpbmVkO1xuICAgIHRleHQ6IHVuZGVmaW5lZDtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBsb2NhdGlvbjogTG9jYXRpb247XG4gICAgZm9ybU1ldGhvZDogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl0gfCB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogU3VibWlzc2lvbltcImZvcm1BY3Rpb25cIl0gfCB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogU3VibWlzc2lvbltcImZvcm1EYXRhXCJdIHwgdW5kZWZpbmVkO1xuICAgIGpzb246IFN1Ym1pc3Npb25bXCJqc29uXCJdIHwgdW5kZWZpbmVkO1xuICAgIHRleHQ6IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdIHwgdW5kZWZpbmVkO1xuICB9O1xuICBTdWJtaXR0aW5nOiB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiO1xuICAgIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXTtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl07XG4gICAgdGV4dDogU3VibWlzc2lvbltcInRleHRcIl07XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uID0gTmF2aWdhdGlvblN0YXRlc1trZXlvZiBOYXZpZ2F0aW9uU3RhdGVzXTtcblxuZXhwb3J0IHR5cGUgUmV2YWxpZGF0aW9uU3RhdGUgPSBcImlkbGVcIiB8IFwibG9hZGluZ1wiO1xuXG4vKipcbiAqIFBvdGVudGlhbCBzdGF0ZXMgZm9yIGZldGNoZXJzXG4gKi9cbnR5cGUgRmV0Y2hlclN0YXRlczxURGF0YSA9IGFueT4gPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIHRleHQ6IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkO1xuICAgIGpzb246IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdIHwgdW5kZWZpbmVkO1xuICAgIHRleHQ6IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl0gfCB1bmRlZmluZWQ7XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl0gfCB1bmRlZmluZWQ7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgZm9ybU1ldGhvZDogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl07XG4gICAgZm9ybUFjdGlvbjogU3VibWlzc2lvbltcImZvcm1BY3Rpb25cIl07XG4gICAgZm9ybUVuY1R5cGU6IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXTtcbiAgICB0ZXh0OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgICBmb3JtRGF0YTogU3VibWlzc2lvbltcImZvcm1EYXRhXCJdO1xuICAgIGpzb246IFN1Ym1pc3Npb25bXCJqc29uXCJdO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcjxURGF0YSA9IGFueT4gPVxuICBGZXRjaGVyU3RhdGVzPFREYXRhPltrZXlvZiBGZXRjaGVyU3RhdGVzPFREYXRhPl07XG5cbmludGVyZmFjZSBCbG9ja2VyQmxvY2tlZCB7XG4gIHN0YXRlOiBcImJsb2NrZWRcIjtcbiAgcmVzZXQoKTogdm9pZDtcbiAgcHJvY2VlZCgpOiB2b2lkO1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59XG5cbmludGVyZmFjZSBCbG9ja2VyVW5ibG9ja2VkIHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJQcm9jZWVkaW5nIHtcbiAgc3RhdGU6IFwicHJvY2VlZGluZ1wiO1xuICByZXNldDogdW5kZWZpbmVkO1xuICBwcm9jZWVkOiB1bmRlZmluZWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgQmxvY2tlciA9IEJsb2NrZXJVbmJsb2NrZWQgfCBCbG9ja2VyQmxvY2tlZCB8IEJsb2NrZXJQcm9jZWVkaW5nO1xuXG5leHBvcnQgdHlwZSBCbG9ja2VyRnVuY3Rpb24gPSAoYXJnczoge1xuICBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uO1xuICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xufSkgPT4gYm9vbGVhbjtcblxuaW50ZXJmYWNlIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogc3RhcnROYXZpZ2F0aW9uIGRvZXMgbm90IG5lZWQgdG8gY29tcGxldGUgdGhlIG5hdmlnYXRpb24gYmVjYXVzZSB3ZVxuICAgKiByZWRpcmVjdGVkIG9yIGdvdCBpbnRlcnJ1cHRlZFxuICAgKi9cbiAgc2hvcnRDaXJjdWl0ZWQ/OiBib29sZWFuO1xufVxuXG50eXBlIFBlbmRpbmdBY3Rpb25SZXN1bHQgPSBbc3RyaW5nLCBTdWNjZXNzUmVzdWx0IHwgRXJyb3JSZXN1bHRdO1xuXG5pbnRlcmZhY2UgSGFuZGxlQWN0aW9uUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBUdXBsZSBmb3IgdGhlIHJldHVybmVkIG9yIHRocm93biB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGFjdGlvbi4gIFRoZSByb3V0ZUlkXG4gICAqIGlzIHRoZSBhY3Rpb24gcm91dGUgZm9yIHN1Y2Nlc3MgYW5kIHRoZSBidWJibGVkIGJvdW5kYXJ5IHJvdXRlIGZvciBlcnJvcnMuXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uUmVzdWx0PzogUGVuZGluZ0FjdGlvblJlc3VsdDtcbn1cblxuaW50ZXJmYWNlIEhhbmRsZUxvYWRlcnNSZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIGxvYWRlckRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgbG9hZGVyRGF0YT86IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgLyoqXG4gICAqIGVycm9ycyB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgZXJyb3JzPzogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG59XG5cbi8qKlxuICogQ2FjaGVkIGluZm8gZm9yIGFjdGl2ZSBmZXRjaGVyLmxvYWQoKSBpbnN0YW5jZXMgc28gdGhleSBjYW4gcGFydGljaXBhdGVcbiAqIGluIHJldmFsaWRhdGlvblxuICovXG5pbnRlcmZhY2UgRmV0Y2hMb2FkTWF0Y2gge1xuICByb3V0ZUlkOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJZGVudGlmaWVkIGZldGNoZXIubG9hZCgpIGNhbGxzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxuICovXG5pbnRlcmZhY2UgUmV2YWxpZGF0aW5nRmV0Y2hlciBleHRlbmRzIEZldGNoTG9hZE1hdGNoIHtcbiAga2V5OiBzdHJpbmc7XG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbDtcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdIHwgbnVsbDtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbn1cblxuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnI6IE11dGF0aW9uRm9ybU1ldGhvZFtdID0gW1xuICBcInBvc3RcIixcbiAgXCJwdXRcIixcbiAgXCJwYXRjaFwiLFxuICBcImRlbGV0ZVwiLFxuXTtcbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzID0gbmV3IFNldDxNdXRhdGlvbkZvcm1NZXRob2Q+KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcblxuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kc0FycjogRm9ybU1ldGhvZFtdID0gW1xuICBcImdldFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0Fycixcbl07XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldDxGb3JtTWV0aG9kPih2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcblxuY29uc3QgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5jb25zdCByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDcsIDMwOF0pO1xuXG5leHBvcnQgY29uc3QgSURMRV9OQVZJR0FUSU9OOiBOYXZpZ2F0aW9uU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgY29uc3QgSURMRV9GRVRDSEVSOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBkYXRhOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICBqc29uOiB1bmRlZmluZWQsXG4gIHRleHQ6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBJRExFX0JMT0NLRVI6IEJsb2NrZXJVbmJsb2NrZWQgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gIHJlc2V0OiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG59O1xuXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5cbmNvbnN0IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uID0gKHJvdXRlKSA9PiAoe1xuICBoYXNFcnJvckJvdW5kYXJ5OiBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpLFxufSk7XG5cbmNvbnN0IFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZID0gXCJyZW1peC1yb3V0ZXItdHJhbnNpdGlvbnNcIjtcblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZSBhIHJvdXRlciBhbmQgbGlzdGVuIHRvIGhpc3RvcnkgUE9QIG5hdmlnYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdDogUm91dGVySW5pdCk6IFJvdXRlciB7XG4gIGNvbnN0IHJvdXRlcldpbmRvdyA9IGluaXQud2luZG93XG4gICAgPyBpbml0LndpbmRvd1xuICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gd2luZG93XG4gICAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGlzU2VydmVyID0gIWlzQnJvd3NlcjtcblxuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG5cbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb247XG4gIGlmIChpbml0Lm1hcFJvdXRlUHJvcGVydGllcykge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGluaXQubWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9IGVsc2UgaWYgKGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IChyb3V0ZSkgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cblxuICAvLyBSb3V0ZXMga2V5ZWQgYnkgSURcbiAgbGV0IG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge307XG4gIC8vIFJvdXRlcyBpbiB0cmVlIGZvcm1hdCBmb3IgbWF0Y2hpbmdcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIGluaXQucm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICB1bmRlZmluZWQsXG4gICAgbWFuaWZlc3RcbiAgKTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJhc2VuYW1lID0gaW5pdC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFTdHJhdGVneUltcGwgPSBpbml0LnVuc3RhYmxlX2RhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5O1xuICAvLyBDb25maWcgZHJpdmVuIGJlaGF2aW9yIGZsYWdzXG4gIGxldCBmdXR1cmU6IEZ1dHVyZUNvbmZpZyA9IHtcbiAgICB2N19mZXRjaGVyUGVyc2lzdDogZmFsc2UsXG4gICAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogZmFsc2UsXG4gICAgdjdfcGFydGlhbEh5ZHJhdGlvbjogZmFsc2UsXG4gICAgdjdfcHJlcGVuZEJhc2VuYW1lOiBmYWxzZSxcbiAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2UsXG4gICAgdW5zdGFibGVfc2tpcEFjdGlvbkVycm9yUmV2YWxpZGF0aW9uOiBmYWxzZSxcbiAgICAuLi5pbml0LmZ1dHVyZSxcbiAgfTtcbiAgLy8gQ2xlYW51cCBmdW5jdGlvbiBmb3IgaGlzdG9yeVxuICBsZXQgdW5saXN0ZW5IaXN0b3J5OiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbnMgdG8gY2FsbCBvbiBhbGwgc3RhdGUgY2hhbmdlc1xuICBsZXQgc3Vic2NyaWJlcnMgPSBuZXcgU2V0PFJvdXRlclN1YnNjcmliZXI+KCk7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgb2JqZWN0IHRvIGhvbGQgc2Nyb2xsIHJlc3RvcmF0aW9uIGxvY2F0aW9ucyBkdXJpbmcgcm91dGluZ1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgc2Nyb2xsIHJlc3RvcmF0aW9uIGtleXNcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICAvLyBPbmUtdGltZSBmbGFnIHRvIGNvbnRyb2wgdGhlIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbi4gIEJlY2F1c2VcbiAgLy8gd2UgZG9uJ3QgZ2V0IHRoZSBzYXZlZCBwb3NpdGlvbnMgZnJvbSA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gdW50aWwgX2FmdGVyX1xuICAvLyB0aGUgaW5pdGlhbCByZW5kZXIsIHdlIG5lZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBhIHNlcGFyYXRlIHVwZGF0ZVN0YXRlIHRvXG4gIC8vIHNlbmQgYWxvbmcgdGhlIHJlc3RvcmVTY3JvbGxQb3NpdGlvblxuICAvLyBTZXQgdG8gdHJ1ZSBpZiB3ZSBoYXZlIGBoeWRyYXRpb25EYXRhYCBzaW5jZSB3ZSBhc3N1bWUgd2Ugd2VyZSBTU1InZCBhbmQgdGhhdFxuICAvLyBTU1IgZGlkIHRoZSBpbml0aWFsIHNjcm9sbCByZXN0b3JhdGlvbi5cbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuXG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbEVycm9yczogUm91dGVEYXRhIHwgbnVsbCA9IG51bGw7XG5cbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgZXJyb3IgYm91bmRhcnkgdG8gdGFrZSBvdmVyXG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgfSk7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7IFtyb3V0ZS5pZF06IGVycm9yIH07XG4gIH1cblxuICBsZXQgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG4gIGxldCBoYXNMYXp5Um91dGVzID0gaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sYXp5KTtcbiAgbGV0IGhhc0xvYWRlcnMgPSBpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxvYWRlcik7XG4gIGlmIChoYXNMYXp5Um91dGVzKSB7XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoIWhhc0xvYWRlcnMpIHtcbiAgICAvLyBJZiB3ZSd2ZSBnb3Qgbm8gbG9hZGVycyB0byBydW4sIHRoZW4gd2UncmUgZ29vZCB0byBnb1xuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xuICAgIC8vIElmIHBhcnRpYWwgaHlkcmF0aW9uIGlzIGVuYWJsZWQsIHdlJ3JlIGluaXRpYWxpemVkIHNvIGxvbmcgYXMgd2Ugd2VyZVxuICAgIC8vIHByb3ZpZGVkIHdpdGggaHlkcmF0aW9uRGF0YSBmb3IgZXZlcnkgcm91dGUgd2l0aCBhIGxvYWRlciwgYW5kIG5vIGxvYWRlcnNcbiAgICAvLyB3ZXJlIG1hcmtlZCBmb3IgZXhwbGljaXQgaHlkcmF0aW9uXG4gICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgbGV0IGVycm9ycyA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgOiBudWxsO1xuICAgIGxldCBpc1JvdXRlSW5pdGlhbGl6ZWQgPSAobTogQWdub3N0aWNEYXRhUm91dGVNYXRjaCkgPT4ge1xuICAgICAgLy8gTm8gbG9hZGVyLCBub3RoaW5nIHRvIGluaXRpYWxpemVcbiAgICAgIGlmICghbS5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBFeHBsaWNpdGx5IG9wdGluZy1pbiB0byBydW5uaW5nIG9uIGh5ZHJhdGlvblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbS5yb3V0ZS5sb2FkZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtLnJvdXRlLmxvYWRlci5oeWRyYXRlID09PSB0cnVlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBpbml0aWFsaXplZCBpZiBoeWRyYXRlZCB3aXRoIGRhdGEgb3IgYW4gZXJyb3JcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChsb2FkZXJEYXRhICYmIGxvYWRlckRhdGFbbS5yb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgKGVycm9ycyAmJiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHVuZGVmaW5lZClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIElmIGVycm9ycyBleGlzdCwgZG9uJ3QgY29uc2lkZXIgcm91dGVzIGJlbG93IHRoZSBib3VuZGFyeVxuICAgIGlmIChlcnJvcnMpIHtcbiAgICAgIGxldCBpZHggPSBpbml0aWFsTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAgIChtKSA9PiBlcnJvcnMhW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxNYXRjaGVzLnNsaWNlKDAsIGlkeCArIDEpLmV2ZXJ5KGlzUm91dGVJbml0aWFsaXplZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuZXZlcnkoaXNSb3V0ZUluaXRpYWxpemVkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2l0aG91dCBwYXJ0aWFsIGh5ZHJhdGlvbiAtIHdlJ3JlIGluaXRpYWxpemVkIGlmIHdlIHdlcmUgcHJvdmlkZWQgYW55XG4gICAgLy8gaHlkcmF0aW9uRGF0YSAtIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGNvbXBsZXRlXG4gICAgaW5pdGlhbGl6ZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgfVxuXG4gIGxldCByb3V0ZXI6IFJvdXRlcjtcbiAgbGV0IHN0YXRlOiBSb3V0ZXJTdGF0ZSA9IHtcbiAgICBoaXN0b3J5QWN0aW9uOiBpbml0Lmhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgIC8vIERvbid0IHJlc3RvcmUgb24gaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGlmIHdlIHdlcmUgU1NSJ2RcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsID8gZmFsc2UgOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICBsb2FkZXJEYXRhOiAoaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhKSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiAoaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5hY3Rpb25EYXRhKSB8fCBudWxsLFxuICAgIGVycm9yczogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzKSB8fCBpbml0aWFsRXJyb3JzLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKCksXG4gICAgYmxvY2tlcnM6IG5ldyBNYXAoKSxcbiAgfTtcblxuICAvLyAtLSBTdGF0ZWZ1bCBpbnRlcm5hbCB2YXJpYWJsZXMgdG8gbWFuYWdlIG5hdmlnYXRpb25zIC0tXG4gIC8vIEN1cnJlbnQgbmF2aWdhdGlvbiBpbiBwcm9ncmVzcyAodG8gYmUgY29tbWl0dGVkIGluIGNvbXBsZXRlTmF2aWdhdGlvbilcbiAgbGV0IHBlbmRpbmdBY3Rpb246IEhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlBvcDtcblxuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBwcmV2ZW50IHRoZSBzY3JvbGwgcmVzZXQgaWYgc2Nyb2xsIGNhbm5vdFxuICAvLyBiZSByZXN0b3JlZD9cbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcblxuICAvLyBBYm9ydENvbnRyb2xsZXIgZm9yIHRoZSBhY3RpdmUgbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuXG4gIC8vIFNob3VsZCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGVuYWJsZSBkb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uP1xuICBsZXQgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIFN0b3JlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBzbyB3ZSBjYW4gYXBwbHkgdGhlbSBvbiBQT1BcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnM6IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PiA9IG5ldyBNYXA8XG4gICAgc3RyaW5nLFxuICAgIFNldDxzdHJpbmc+XG4gID4oKTtcblxuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBwZXJzaXN0aW5nIGFwcGxpZWQgdHJhbnNpdGlvbnMgdG8gc2Vzc2lvblN0b3JhZ2VcbiAgbGV0IHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcjogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgZmxhZyB0byBmb3JjZSByZXZhbGlkYXRpb24gb2YgYWxsIGxvYWRlcnM6XG4gIC8vICAtIHN1Ym1pc3Npb25zIChjb21wbGV0ZWQgb3IgaW50ZXJydXB0ZWQpXG4gIC8vICAtIHVzZVJldmFsaWRhdG9yKClcbiAgLy8gIC0gWC1SZW1peC1SZXZhbGlkYXRlIChmcm9tIHJlZGlyZWN0KVxuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgcm91dGVzIHRoYXQgcmVxdWlyZSByZXZhbGlkYXRpb24gZHVlXG4gIC8vIHRvIGEgY2FuY2VsbGVkIGRlZmVycmVkIG9uIGFjdGlvbiBzdWJtaXNzaW9uXG4gIGxldCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIGZldGNoZXIgbG9hZHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBieSBhblxuICAvLyBhY3Rpb24gbmF2aWdhdGlvbiBhbmQgcmVxdWlyZSByZXZhbGlkYXRpb25cbiAgbGV0IGNhbmNlbGxlZEZldGNoZXJMb2Fkczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBBYm9ydENvbnRyb2xsZXJzIGZvciBhbnkgaW4tZmxpZ2h0IGZldGNoZXJzXG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj4oKTtcblxuICAvLyBUcmFjayBsb2FkcyBiYXNlZCBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBzdGFydGVkXG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuXG4gIC8vIFRyYWNrIHRoZSBvdXRzdGFuZGluZyBwZW5kaW5nIG5hdmlnYXRpb24gZGF0YSBsb2FkIHRvIGJlIGNvbXBhcmVkIGFnYWluc3RcbiAgLy8gdGhlIGdsb2JhbGx5IGluY3JlbWVudGluZyBsb2FkIHdoZW4gYSBmZXRjaGVyIGxvYWQgbGFuZHMgYWZ0ZXIgYSBjb21wbGV0ZWRcbiAgLy8gbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcblxuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCBkYXRhIHJlbG9hZHMgYXMgYSByZXN1bHQgb2YgdGhlaXIgYWN0aW9uc1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIHJlZGlyZWN0IG5hdmlnYXRpb25zXG4gIGxldCBmZXRjaFJlZGlyZWN0SWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4oKTtcblxuICAvLyBSZWYtY291bnQgbW91bnRlZCBmZXRjaGVycyBzbyB3ZSBrbm93IHdoZW4gaXQncyBvayB0byBjbGVhbiB0aGVtIHVwXG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCBoYXZlIHJlcXVlc3RlZCBhIGRlbGV0ZSB3aGVuIHVzaW5nIHY3X2ZldGNoZXJQZXJzaXN0LFxuICAvLyB0aGV5J2xsIGJlIG9mZmljaWFsbHkgcmVtb3ZlZCBhZnRlciB0aGV5IHJldHVybiB0byBpZGxlXG4gIGxldCBkZWxldGVkRmV0Y2hlcnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBTdG9yZSBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGZvciBhY3RpdmUgcm91dGUgbWF0Y2hlcy4gIFdoZW4gYVxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxuICAvLyBwcm9taXNlIHJlc29sdmVzIHdlIHVwZGF0ZSBsb2FkZXJEYXRhLiAgSWYgYSBuZXcgbmF2aWdhdGlvbiBzdGFydHMgd2VcbiAgLy8gY2FuY2VsIGFjdGl2ZSBkZWZlcnJlZHMgZm9yIGVsaW1pbmF0ZWQgcm91dGVzLlxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4oKTtcblxuICAvLyBTdG9yZSBibG9ja2VyIGZ1bmN0aW9ucyBpbiBhIHNlcGFyYXRlIE1hcCBvdXRzaWRlIG9mIHJvdXRlciBzdGF0ZSBzaW5jZVxuICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBVSSBzdGF0ZSBpZiB0aGV5IGNoYW5nZVxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBCbG9ja2VyRnVuY3Rpb24+KCk7XG5cbiAgLy8gRmxhZyB0byBpZ25vcmUgdGhlIG5leHQgaGlzdG9yeSB1cGRhdGUsIHNvIHdlIGNhbiByZXZlcnQgdGhlIFVSTCBjaGFuZ2Ugb25cbiAgLy8gYSBQT1AgbmF2aWdhdGlvbiB0aGF0IHdhcyBibG9ja2VkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgdG91Y2hpbmcgcm91dGVyIHN0YXRlXG4gIGxldCBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHJvdXRlciwgYWxsIHNpZGUgZWZmZWN0cyBzaG91bGQgYmUga2lja2VkIG9mZiBmcm9tIGhlcmUuXG4gIC8vIEltcGxlbWVudGVkIGFzIGEgRmx1ZW50IEFQSSBmb3IgZWFzZSBvZjpcbiAgLy8gICBsZXQgcm91dGVyID0gY3JlYXRlUm91dGVyKGluaXQpLmluaXRpYWxpemUoKTtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBJZiBoaXN0b3J5IGluZm9ybXMgdXMgb2YgYSBQT1AgbmF2aWdhdGlvbiwgc3RhcnQgdGhlIG5hdmlnYXRpb24gYnV0IGRvIG5vdCB1cGRhdGVcbiAgICAvLyBzdGF0ZS4gIFdlJ2xsIHVwZGF0ZSBvdXIgb3duIHN0YXRlIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgLy8gSWdub3JlIHRoaXMgZXZlbnQgaWYgaXQgd2FzIGp1c3QgdXMgcmVzZXR0aW5nIHRoZSBVUkwgZnJvbSBhXG4gICAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlKSB7XG4gICAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLFxuICAgICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgYmxvY2tlciBvbiBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gXCIgK1xuICAgICAgICAgICAgXCJ0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgK1xuICAgICAgICAgICAgXCJwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciBcIiArXG4gICAgICAgICAgICBcInZpYSBgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYC9gd2luZG93LmxvY2F0aW9uLmhhc2hgIGluc3RlYWQgb2YgdXNpbmcgXCIgK1xuICAgICAgICAgICAgXCJyb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBcIiArXG4gICAgICAgICAgICBcImNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaGlzdG9yeUFjdGlvbixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb2NrZXJLZXkgJiYgZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuXG4gICAgICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBSZS1kbyB0aGUgc2FtZSBQT1AgbmF2aWdhdGlvbiB3ZSBqdXN0IGJsb2NrZWRcbiAgICAgICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5ISwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIGZlZWxzIGdyb3NzLiAgSG93IGNhbiB3ZSBjbGVhbnVwIHRoZSBsaW5lcyBiZXR3ZWVuXG4gICAgICAvLyBzY3JvbGxSZXN0b3JhdGlvbi9hcHBsaWVkVHJhbnNpdGlvbnMgcGVyc2lzdGFuY2U/XG4gICAgICByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICBsZXQgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMgPSAoKSA9PlxuICAgICAgICBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICByb3V0ZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9ICgpID0+XG4gICAgICAgIHJvdXRlcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICAvLyBOb3RlIHdlIGRvbid0IGRvIGFueSBoYW5kbGluZyBvZiBsYXp5IGhlcmUuICBGb3IgU1BBJ3MgaXQnbGwgZ2V0IGhhbmRsZWRcbiAgICAvLyBpbiB0aGUgbm9ybWFsIG5hdmlnYXRpb24gZmxvdy4gIEZvciBTU1IgaXQncyBleHBlY3RlZCB0aGF0IGxhenkgbW9kdWxlcyBhcmVcbiAgICAvLyByZXNvbHZlZCBwcmlvciB0byByb3V0ZXIgY3JlYXRpb24gc2luY2Ugd2UgY2FuJ3QgZ28gaW50byBhIGZhbGxiYWNrRWxlbWVudFxuICAgIC8vIFVJIGZvciBTU1InZCBhcHBzXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKEhpc3RvcnlBY3Rpb24uUG9wLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBpbml0aWFsSHlkcmF0aW9uOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGEgcm91dGVyIGFuZCBpdCdzIHNpZGUgZWZmZWN0c1xuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKSB7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcbiAgfVxuXG4gIC8vIFN1YnNjcmliZSB0byBzdGF0ZSB1cGRhdGVzIGZvciB0aGUgcm91dGVyXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cblxuICAvLyBVcGRhdGUgb3VyIHN0YXRlIGFuZCBub3RpZnkgdGhlIGNhbGxpbmcgY29udGV4dCBvZiB0aGUgY2hhbmdlXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKFxuICAgIG5ld1N0YXRlOiBQYXJ0aWFsPFJvdXRlclN0YXRlPixcbiAgICBvcHRzOiB7XG4gICAgICBmbHVzaFN5bmM/OiBib29sZWFuO1xuICAgICAgdmlld1RyYW5zaXRpb25PcHRzPzogVmlld1RyYW5zaXRpb25PcHRzO1xuICAgIH0gPSB7fVxuICApOiB2b2lkIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgfTtcblxuICAgIC8vIFByZXAgZmV0Y2hlciBjbGVhbnVwIHNvIHdlIGNhbiB0ZWxsIHRoZSBVSSB3aGljaCBmZXRjaGVyIGRhdGEgZW50cmllc1xuICAgIC8vIGNhbiBiZSByZW1vdmVkXG4gICAgbGV0IGNvbXBsZXRlZEZldGNoZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBkZWxldGVkRmV0Y2hlcnNLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIFVubW91bnRlZCBmcm9tIHRoZSBVSSBhbmQgY2FuIGJlIHRvdGFsbHkgcmVtb3ZlZFxuICAgICAgICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybmVkIHRvIGlkbGUgYnV0IHN0aWxsIG1vdW50ZWQgaW4gdGhlIFVJLCBzbyBzZW1pLXJlbWFpbnMgZm9yXG4gICAgICAgICAgICAvLyByZXZhbGlkYXRpb25zIGFuZCBzdWNoXG4gICAgICAgICAgICBjb21wbGV0ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgYSBsb2NhbCBjb3B5IHNvIHRoYXQgaWYgZmx1c2hTeW5jIGlzIHVzZWQgYW5kIHdlIGVuZCB1cFxuICAgIC8vIHJlbW92aW5nIGFuZCBhZGRpbmcgYSBuZXcgc3Vic2NyaWJlciBkdWUgdG8gdGhlIHVzZUNhbGxiYWNrIGRlcGVuZGVuY2llcyxcbiAgICAvLyB3ZSBkb24ndCBnZXQgb3Vyc2VsdmVzIGludG8gYSBsb29wIGNhbGxpbmcgdGhlIG5ldyBzdWJzY3JpYmVyIGltbWVkaWF0ZWx5XG4gICAgWy4uLnN1YnNjcmliZXJzXS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PlxuICAgICAgc3Vic2NyaWJlcihzdGF0ZSwge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnM6IGRlbGV0ZWRGZXRjaGVyc0tleXMsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0czogb3B0cy52aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogb3B0cy5mbHVzaFN5bmMgPT09IHRydWUsXG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBSZW1vdmUgaWRsZSBmZXRjaGVycyBmcm9tIHN0YXRlIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBpbi1mbGlnaHQgZmV0Y2hlcnMuXG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgY29tcGxldGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KSk7XG4gICAgICBkZWxldGVkRmV0Y2hlcnNLZXlzLmZvckVhY2goKGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBuZXdTdGF0ZTogUGFydGlhbDxPbWl0PFJvdXRlclN0YXRlLCBcImFjdGlvblwiIHwgXCJsb2NhdGlvblwiIHwgXCJuYXZpZ2F0aW9uXCI+PixcbiAgICB7IGZsdXNoU3luYyB9OiB7IGZsdXNoU3luYz86IGJvb2xlYW4gfSA9IHt9XG4gICk6IHZvaWQge1xuICAgIC8vIERlZHVjZSBpZiB3ZSdyZSBpbiBhIGxvYWRpbmcvYWN0aW9uUmVsb2FkIHN0YXRlOlxuICAgIC8vIC0gV2UgaGF2ZSBjb21taXR0ZWQgYWN0aW9uRGF0YSBpbiB0aGUgc3RvcmVcbiAgICAvLyAtIFRoZSBjdXJyZW50IG5hdmlnYXRpb24gd2FzIGEgbXV0YXRpb24gc3VibWlzc2lvblxuICAgIC8vIC0gV2UncmUgcGFzdCB0aGUgc3VibWl0dGluZyBzdGF0ZSBhbmQgaW50byB0aGUgbG9hZGluZyBzdGF0ZVxuICAgIC8vIC0gVGhlIGxvY2F0aW9uIGJlaW5nIGxvYWRlZCBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0XG4gICAgbGV0IGlzQWN0aW9uUmVsb2FkID1cbiAgICAgIHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJlxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJlxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiZcbiAgICAgIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcblxuICAgIGxldCBhY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCBudWxsO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtcHR5IGFjdGlvbkRhdGEgLT4gY2xlYXIgcHJpb3IgYWN0aW9uRGF0YSBkdWUgdG8gYW4gYWN0aW9uIGVycm9yXG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgZGF0YSBpZiB3ZSdyZSB3cmFwcGluZyB1cCB0aGUgYWN0aW9uIHJlbG9hZFxuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGFjdGlvbkRhdGEgb24gYW55IG90aGVyIGNvbXBsZXRlZCBuYXZpZ2F0aW9uc1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHByZXNlcnZlIGFueSBleGlzdGluZyBsb2FkZXJEYXRhIGZyb20gcmUtdXNlZCByb3V0ZXNcbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGFcbiAgICAgID8gbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbmV3U3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IFtdLFxuICAgICAgICAgIG5ld1N0YXRlLmVycm9yc1xuICAgICAgICApXG4gICAgICA6IHN0YXRlLmxvYWRlckRhdGE7XG5cbiAgICAvLyBPbiBhIHN1Y2Nlc3NmdWwgbmF2aWdhdGlvbiB3ZSBjYW4gYXNzdW1lIHdlIGdvdCB0aHJvdWdoIGFsbCBibG9ja2Vyc1xuICAgIC8vIHNvIHdlIGNhbiBzdGFydCBmcmVzaFxuICAgIGxldCBibG9ja2VycyA9IHN0YXRlLmJsb2NrZXJzO1xuICAgIGlmIChibG9ja2Vycy5zaXplID4gMCkge1xuICAgICAgYmxvY2tlcnMgPSBuZXcgTWFwKGJsb2NrZXJzKTtcbiAgICAgIGJsb2NrZXJzLmZvckVhY2goKF8sIGspID0+IGJsb2NrZXJzLnNldChrLCBJRExFX0JMT0NLRVIpKTtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgcmVzcGVjdCB0aGUgdXNlciBmbGFnLiAgT3RoZXJ3aXNlIGRvbid0IHJlc2V0IG9uIG11dGF0aW9uXG4gICAgLy8gc3VibWlzc2lvbiBuYXZpZ2F0aW9ucyB1bmxlc3MgdGhleSByZWRpcmVjdFxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPVxuICAgICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSB8fFxuICAgICAgKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmXG4gICAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJlxuICAgICAgICBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWUpO1xuXG4gICAgaWYgKGluRmxpZ2h0RGF0YVJvdXRlcykge1xuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiB0aGVuIGRvIG5vdCB0b3VjaCBoaXN0b3J5XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlBvcCkge1xuICAgICAgLy8gRG8gbm90aGluZyBmb3IgUE9QIC0gVVJMIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5QdXNoKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cblxuICAgIGxldCB2aWV3VHJhbnNpdGlvbk9wdHM6IFZpZXdUcmFuc2l0aW9uT3B0cyB8IHVuZGVmaW5lZDtcblxuICAgIC8vIE9uIFBPUCwgZW5hYmxlIHRyYW5zaXRpb25zIGlmIHRoZXkgd2VyZSBlbmFibGVkIG9uIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUG9wKSB7XG4gICAgICAvLyBGb3J3YXJkIHRha2VzIHByZWNlZGVuY2Ugc28gdGhleSBiZWhhdmUgbGlrZSB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvblxuICAgICAgbGV0IHByaW9yUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAocHJpb3JQYXRocyAmJiBwcmlvclBhdGhzLmhhcyhsb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwcmV2aW91cyBmb3J3YXJkIG5hdiwgYXNzdW1lIHdlJ3JlIHBvcHBpbmcgYmFjayB0b1xuICAgICAgICAvLyB0aGUgbmV3IGxvY2F0aW9uIGFuZCBlbmFibGUgaWYgdGhhdCBsb2NhdGlvbiBwcmV2aW91c2x5IGVuYWJsZWRcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhcHBsaWVkIHRyYW5zaXRpb24gb24gUFVTSC9SRVBMQUNFXG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSBuZXcgU2V0PHN0cmluZz4oW2xvY2F0aW9uLnBhdGhuYW1lXSk7XG4gICAgICAgIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuc2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCB0b1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIC4uLm5ld1N0YXRlLCAvLyBtYXRjaGVzLCBlcnJvcnMsIGZldGNoZXJzIGdvIHRocm91Z2ggYXMtaXNcbiAgICAgICAgYWN0aW9uRGF0YSxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXNcbiAgICAgICAgKSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBibG9ja2VycyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMgPT09IHRydWUsXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlBvcDtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyA9IFtdO1xuICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyA9IFtdO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZShcbiAgICB0bzogbnVtYmVyIHwgVG8gfCBudWxsLFxuICAgIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnNcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaW5pdC5oaXN0b3J5LmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSxcbiAgICAgIHRvLFxuICAgICAgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLFxuICAgICAgb3B0cz8uZnJvbVJvdXRlSWQsXG4gICAgICBvcHRzPy5yZWxhdGl2ZVxuICAgICk7XG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLFxuICAgICAgZmFsc2UsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuXG4gICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcGF0aCwgb3B0cyAmJiBvcHRzLnN0YXRlKTtcblxuICAgIC8vIFdoZW4gdXNpbmcgbmF2aWdhdGUgYXMgYSBQVVNIL1JFUExBQ0Ugd2UgYXJlbid0IHJlYWRpbmcgYW4gYWxyZWFkeS1lbmNvZGVkXG4gICAgLy8gVVJMIGZyb20gd2luZG93LmxvY2F0aW9uLCBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBoZXJlIHNvIHRoZSBiZWhhdmlvclxuICAgIC8vIHJlbWFpbnMgdGhlIHNhbWUgYXMgUE9QIGFuZCBub24tZGF0YS1yb3V0ZXIgdXNhZ2VzLiAgbmV3IFVSTCgpIGRvZXMgYWxsXG4gICAgLy8gdGhlIHNhbWUgZW5jb2Rpbmcgd2UnZCBnZXQgZnJvbSBhIGhpc3RvcnkucHVzaFN0YXRlL3dpbmRvdy5sb2NhdGlvbiByZWFkXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gdG91Y2ggaGlzdG9yeVxuICAgIG5leHRMb2NhdGlvbiA9IHtcbiAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgIC4uLmluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbihuZXh0TG9jYXRpb24pLFxuICAgIH07XG5cbiAgICBsZXQgdXNlclJlcGxhY2UgPSBvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsID8gb3B0cy5yZXBsYWNlIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG5cbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlJlcGxhY2U7XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHN1Ym1pc3Npb24gIT0gbnVsbCAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmXG4gICAgICBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoXG4gICAgKSB7XG4gICAgICAvLyBCeSBkZWZhdWx0IG9uIHN1Ym1pc3Npb25zIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIHdlIFJFUExBQ0Ugc28gdGhhdFxuICAgICAgLy8gdXNlcnMgZG9uJ3QgaGF2ZSB0byBkb3VibGUtY2xpY2sgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCB0byB0aGUgcHJpb3JcbiAgICAgIC8vIGxvY2F0aW9uLiAgSWYgdGhlIHVzZXIgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZyb20gdGhlXG4gICAgICAvLyBhY3Rpb24vbG9hZGVyIHRoaXMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgcmVkaXJlY3Qgd2lsbCBiZSBhIFBVU0hcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlJlcGxhY2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9XG4gICAgICBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0c1xuICAgICAgICA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMudW5zdGFibGVfZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcblxuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb24sXG4gICAgfSk7XG5cbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSEsIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmMsXG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXZhbGlkYXRlIGFsbCBjdXJyZW50IGxvYWRlcnMuICBJZiBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3Mgb3IgaWYgdGhpc1xuICAvLyBpcyBpbnRlcnJ1cHRlZCBieSBhIG5hdmlnYXRpb24sIGFsbG93IHRoaXMgdG8gXCJzdWNjZWVkXCIgYnkgY2FsbGluZyBhbGxcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7IHJldmFsaWRhdGlvbjogXCJsb2FkaW5nXCIgfSk7XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgc3VibWl0dGluZyBhbiBhY3Rpb24sIHdlIGRvbid0IG5lZWQgdG8gc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uLCB3ZSdsbCBqdXN0IGxldCB0aGUgZm9sbG93IHVwIGxvYWRlciBleGVjdXRpb24gY2FsbCBhbGwgbG9hZGVyc1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcInN1Ym1pdHRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbiBhbiBpZGxlIHN0YXRlLCBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uIGZvciB0aGUgY3VycmVudFxuICAgIC8vIGFjdGlvbi9sb2NhdGlvbiBhbmQgbWFyayBpdCBhcyB1bmludGVycnVwdGVkLCB3aGljaCB3aWxsIHNraXAgdGhlIGhpc3RvcnlcbiAgICAvLyB1cGRhdGUgaW4gY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oc3RhdGUuaGlzdG9yeUFjdGlvbiwgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBjdXJyZW50bHkgaW4gYSBsb2FkaW5nIHN0YXRlLCBqdXN0IHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiB0byB0aGUgbmF2aWdhdGlvbi5sb2NhdGlvbiBidXQgZG8gbm90IHRyaWdnZXIgYW4gdW5pbnRlcnJ1cHRlZFxuICAgIC8vIHJldmFsaWRhdGlvbiBzbyB0aGF0IGhpc3RvcnkgY29ycmVjdGx5IHVwZGF0ZXMgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICBzdGFydE5hdmlnYXRpb24oXG4gICAgICBwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLFxuICAgICAgeyBvdmVycmlkZU5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb24gfVxuICAgICk7XG4gIH1cblxuICAvLyBTdGFydCBhIG5hdmlnYXRpb24gdG8gdGhlIGdpdmVuIGFjdGlvbi9sb2NhdGlvbi4gIENhbiBvcHRpb25hbGx5IHByb3ZpZGUgYVxuICAvLyBvdmVycmlkZU5hdmlnYXRpb24gd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgbm9ybWFsTG9hZCBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0XG4gIC8vIG5hdmlnYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKFxuICAgIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb24sXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG9wdHM/OiB7XG4gICAgICBpbml0aWFsSHlkcmF0aW9uPzogYm9vbGVhbjtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbjtcbiAgICAgIHBlbmRpbmdFcnJvcj86IEVycm9yUmVzcG9uc2VJbXBsO1xuICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uPzogYm9vbGVhbjtcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gICAgICByZXBsYWNlPzogYm9vbGVhbjtcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uPzogYm9vbGVhbjtcbiAgICAgIGZsdXNoU3luYz86IGJvb2xlYW47XG4gICAgfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9XG4gICAgICAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IChvcHRzICYmIG9wdHMuZW5hYmxlVmlld1RyYW5zaXRpb24pID09PSB0cnVlO1xuXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgZGVmZXJyZWQgb24gNDA0cyBzaW5jZSB3ZSBkb24ndCBrZWVwIGFueSByb3V0ZXNcbiAgICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcygpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBpdCdzIG9ubHkgYSBoYXNoIGNoYW5nZSBhbmQgbm90IGEgcmV2YWxpZGF0aW9uIG9yXG4gICAgLy8gbXV0YXRpb24gc3VibWlzc2lvbi5cbiAgICAvL1xuICAgIC8vIElnbm9yZSBvbiBpbml0aWFsIHBhZ2UgbG9hZHMgYmVjYXVzZSBzaW5jZSB0aGUgaW5pdGlhbCBsb2FkIHdpbGwgYWx3YXlzXG4gICAgLy8gYmUgXCJzYW1lIGhhc2hcIi4gIEZvciBleGFtcGxlLCBvbiAvcGFnZSNoYXNoIGFuZCBzdWJtaXQgYSA8Rm9ybSBtZXRob2Q9XCJwb3N0XCI+XG4gICAgLy8gd2hpY2ggd2lsbCBkZWZhdWx0IHRvIGEgbmF2aWdhdGlvbiB0byAvcGFnZVxuICAgIGlmIChcbiAgICAgIHN0YXRlLmluaXRpYWxpemVkICYmXG4gICAgICAhaXNSZXZhbGlkYXRpb25SZXF1aXJlZCAmJlxuICAgICAgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmXG4gICAgICAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKVxuICAgICkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7IG1hdGNoZXMgfSwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvblJlc3VsdDogUGVuZGluZ0FjdGlvblJlc3VsdCB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChvcHRzICYmIG9wdHMucGVuZGluZ0Vycm9yKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZ0Vycm9yLCBpdCBtZWFucyB0aGUgdXNlciBhdHRlbXB0ZWQgYSBHRVQgc3VibWlzc2lvblxuICAgICAgLy8gd2l0aCBiaW5hcnkgRm9ybURhdGEgc28gYXNzaWduIGhlcmUgYW5kIHNraXAgdG8gaGFuZGxlTG9hZGVycy4gIFRoYXRcbiAgICAgIC8vIHdheSB3ZSBoYW5kbGUgY2FsbGluZyBsb2FkZXJzIGFib3ZlIHRoZSBib3VuZGFyeSBldGMuICBJdCdzIG5vdCByZWFsbHlcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIGFuIGFjdGlvbkVycm9yIGluIHRoYXQgc2Vuc2UuXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ID0gW1xuICAgICAgICBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkLFxuICAgICAgICB7IHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsIGVycm9yOiBvcHRzLnBlbmRpbmdFcnJvciB9LFxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgb3B0cyAmJlxuICAgICAgb3B0cy5zdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKVxuICAgICkge1xuICAgICAgLy8gQ2FsbCBhY3Rpb24gaWYgd2UgcmVjZWl2ZWQgYW4gYWN0aW9uIHN1Ym1pc3Npb25cbiAgICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHsgcmVwbGFjZTogb3B0cy5yZXBsYWNlLCBmbHVzaFN5bmMgfVxuICAgICAgKTtcblxuICAgICAgaWYgKGFjdGlvblJlc3VsdC5zaG9ydENpcmN1aXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIG9wdHMuc3VibWlzc2lvbik7XG4gICAgICBmbHVzaFN5bmMgPSBmYWxzZTtcblxuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgICAgcmVxdWVzdC51cmwsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7IHNob3J0Q2lyY3VpdGVkLCBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5mZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgb3B0cyAmJiBvcHRzLmluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICAgKTtcblxuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG5vdyB0aGF0IHRoZSBhY3Rpb24vbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmXG4gICAgLy8gd2Ugc2hvcnQgY2lyY3VpdGVkIGJlY2F1c2UgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIHdpbGwgaGF2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiBhc3NpZ25lZCB0byBhIG5ldyBjb250cm9sbGVyIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIC4uLmdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCksXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIG1hdGNoZWQgYnkgdGhlIGxlYWYgcm91dGUgZm9yIHRoaXMgbmF2aWdhdGlvbiBhbmQgaGFuZGxlXG4gIC8vIHJlZGlyZWN0cy9lcnJvcnNcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIHN1Ym1pc3Npb246IFN1Ym1pc3Npb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG9wdHM6IHsgcmVwbGFjZT86IGJvb2xlYW47IGZsdXNoU3luYz86IGJvb2xlYW4gfSA9IHt9XG4gICk6IFByb21pc2U8SGFuZGxlQWN0aW9uUmVzdWx0PiB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcblxuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgbmF2aWdhdGlvbiA9IGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICB1cGRhdGVTdGF0ZSh7IG5hdmlnYXRpb24gfSwgeyBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlIH0pO1xuXG4gICAgLy8gQ2FsbCBvdXIgYWN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgIGxldCByZXN1bHQ6IERhdGFSZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBtYXRjaGVzXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1swXTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgcmVwbGFjZTogYm9vbGVhbjtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2UgPSBvcHRzLnJlcGxhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBkaWRuJ3QgZXhwbGljaXR5IGluZGljYXRlIHJlcGxhY2UgYmVoYXZpb3IsIHJlcGxhY2UgaWZcbiAgICAgICAgLy8gd2UgcmVkaXJlY3RlZCB0byB0aGUgZXhhY3Qgc2FtZSBsb2NhdGlvbiB3ZSdyZSBjdXJyZW50bHkgYXQgdG8gYXZvaWRcbiAgICAgICAgLy8gZG91YmxlIGJhY2stYnV0dG9uc1xuICAgICAgICBsZXQgbG9jYXRpb24gPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgICAgIHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpISxcbiAgICAgICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICApO1xuICAgICAgICByZXBsYWNlID0gbG9jYXRpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVzdWx0LCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG5cbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyBhcmUgUkVQTEFDRSBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZVxuICAgICAgLy8gYWN0aW9uIHRocmV3IGFuIGVycm9yIHRoYXQnbGwgYmUgcmVuZGVyZWQgaW4gYW4gZXJyb3JFbGVtZW50LCB3ZSBmYWxsXG4gICAgICAvLyBiYWNrIHRvIFBVU0ggc28gdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgYmFjayB0b1xuICAgICAgLy8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5IGFnYWluXG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gSGlzdG9yeUFjdGlvbi5QdXNoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFthY3Rpb25NYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbixcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICBmZXRjaGVyU3VibWlzc2lvbj86IFN1Ym1pc3Npb24sXG4gICAgcmVwbGFjZT86IGJvb2xlYW4sXG4gICAgaW5pdGlhbEh5ZHJhdGlvbj86IGJvb2xlYW4sXG4gICAgZmx1c2hTeW5jPzogYm9vbGVhbixcbiAgICBwZW5kaW5nQWN0aW9uUmVzdWx0PzogUGVuZGluZ0FjdGlvblJlc3VsdFxuICApOiBQcm9taXNlPEhhbmRsZUxvYWRlcnNSZXN1bHQ+IHtcbiAgICAvLyBGaWd1cmUgb3V0IHRoZSByaWdodCBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gdXNlIGZvciBkYXRhIGxvYWRpbmdcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPVxuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcblxuICAgIC8vIElmIHRoaXMgd2FzIGEgcmVkaXJlY3QgZnJvbSBhbiBhY3Rpb24gd2UgZG9uJ3QgaGF2ZSBhIFwic3VibWlzc2lvblwiIGJ1dFxuICAgIC8vIHdlIGhhdmUgaXQgb24gdGhlIGxvYWRpbmcgbmF2aWdhdGlvbiBzbyB1c2UgdGhhdCBpZiBhdmFpbGFibGVcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9XG4gICAgICBzdWJtaXNzaW9uIHx8XG4gICAgICBmZXRjaGVyU3VibWlzc2lvbiB8fFxuICAgICAgZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKGxvYWRpbmdOYXZpZ2F0aW9uKTtcblxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uICYmIGluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBmdXR1cmUudW5zdGFibGVfc2tpcEFjdGlvbkVycm9yUmV2YWxpZGF0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZGVsZXRlZEZldGNoZXJzLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgICk7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyBkZWZlcnJlZHMgZm9yIG5vLWxvbmdlci1tYXRjaGVkIHJvdXRlcyBvciByb3V0ZXMgd2UncmVcbiAgICAvLyBhYm91dCB0byByZWxvYWQuICBOb3RlIHRoYXQgaWYgdGhpcyBpcyBhbiBhY3Rpb24gcmVsb2FkIHdlIHdvdWxkIGhhdmVcbiAgICAvLyBhbHJlYWR5IGNhbmNlbGxlZCBhbGwgcGVuZGluZyBkZWZlcnJlZHMgc28gdGhpcyB3b3VsZCBiZSBhIG5vLW9wXG4gICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgICAgKHJvdXRlSWQpID0+XG4gICAgICAgICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKSB8fFxuICAgICAgICAobWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKVxuICAgICk7XG5cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgICBlcnJvcnM6XG4gICAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSlcbiAgICAgICAgICAgICAgPyB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciB9XG4gICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAuLi5nZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpLFxuICAgICAgICAgIC4uLih1cGRhdGVkRmV0Y2hlcnMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge30pLFxuICAgICAgICB9LFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9uLCB3ZSByZW1haW4gaW4gb3VyIGN1cnJlbnQgaWRsZVxuICAgIC8vIHN0YXRlLiAgSWYgbm90LCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBvdXIgbG9hZGluZyBzdGF0ZSBhbmQgbG9hZCBkYXRhLFxuICAgIC8vIHByZXNlcnZpbmcgYW55IG5ldyBhY3Rpb24gZGF0YSBvciBleGlzdGluZyBhY3Rpb24gZGF0YSAoaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyBhIHJldmFsaWRhdGlvbiBpbnRlcnJ1cHRpbmcgYW4gYWN0aW9uUmVsb2FkKVxuICAgIC8vIElmIHdlIGhhdmUgcGFydGlhbEh5ZHJhdGlvbiBlbmFibGVkLCB0aGVuIGRvbid0IHVwZGF0ZSB0aGUgc3RhdGUgZm9yIHRoZVxuICAgIC8vIGluaXRpYWwgZGF0YSBsb2FkIHNpbmNlIGl0J3Mgbm90IGEgXCJuYXZpZ2F0aW9uXCJcbiAgICBpZiAoXG4gICAgICAhaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uICYmXG4gICAgICAoIWZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uIHx8ICFpbml0aWFsSHlkcmF0aW9uKVxuICAgICkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQocmYua2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgYWN0aW9uRGF0YTogUmVjb3JkPHN0cmluZywgUm91dGVEYXRhPiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAocGVuZGluZ0FjdGlvblJlc3VsdCAmJiAhaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGNhc3QgdG8gYGFueWAgY3VycmVudGx5IGJlY2F1c2UgYFJvdXRlRGF0YWB1c2VzIGFueSBhbmQgaXRcbiAgICAgICAgLy8gd291bGQgYmUgYSBicmVha2luZyBjaGFuZ2UgdG8gdXNlIGFueS5cbiAgICAgICAgLy8gVE9ETzogdjcgLSBjaGFuZ2UgYFJvdXRlRGF0YWAgdG8gdXNlIGB1bmtub3duYCBpbnN0ZWFkIG9mIGBhbnlgXG4gICAgICAgIGFjdGlvbkRhdGEgPSB7XG4gICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGEgYXMgYW55LFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGVTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAgIC4uLihhY3Rpb25EYXRhICE9PSB1bmRlZmluZWQgPyB7IGFjdGlvbkRhdGEgfSA6IHt9KSxcbiAgICAgICAgICAuLi4ocmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGZsdXNoU3luYyxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHJmLmtleSkpIHtcbiAgICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAvLyBGZXRjaGVycyB1c2UgYW4gaW5kZXBlbmRlbnQgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgYWJvcnRpbmcgYSBmZXRjaGVyXG4gICAgICAgIC8vICh2aWEgZGVsZXRlRmV0Y2hlcikgZG9lcyBub3QgYWJvcnQgdGhlIHRyaWdnZXJpbmcgbmF2aWdhdGlvbiB0aGF0XG4gICAgICAgIC8vIHRyaWdnZXJlZCB0aGUgcmV2YWxpZGF0aW9uXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcm94eSBuYXZpZ2F0aW9uIGFib3J0IHRocm91Z2ggdG8gcmV2YWxpZGF0aW9uIGZldGNoZXJzXG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChmKSA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPVxuICAgICAgYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgKTtcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcblxuICAgIC8vIElmIGFueSBsb2FkZXJzIHJldHVybmVkIGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChbLi4ubG9hZGVyUmVzdWx0cywgLi4uZmV0Y2hlclJlc3VsdHNdKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID1cbiAgICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0LnJlc3VsdCwge1xuICAgICAgICByZXBsYWNlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKChhYm9ydGVkKSA9PiB7XG4gICAgICAgIC8vIE5vdGU6IE5vIG5lZWQgdG8gdXBkYXRlU3RhdGUgaGVyZSBzaW5jZSB0aGUgVHJhY2tlZFByb21pc2Ugb25cbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpcyBzdGFibGUgYWNyb3NzIHJlc29sdmUvcmVqZWN0XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcbiAgICAgICAgaWYgKGFib3J0ZWQgfHwgZGVmZXJyZWREYXRhLmRvbmUpIHtcbiAgICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIER1cmluZyBwYXJ0aWFsIGh5ZHJhdGlvbiwgcHJlc2VydmUgU1NSIGVycm9ycyBmb3Igcm91dGVzIHRoYXQgZG9uJ3QgcmUtcnVuXG4gICAgaWYgKGZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uICYmIGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhzdGF0ZS5lcnJvcnMpXG4gICAgICAgIC5maWx0ZXIoKFtpZF0pID0+ICFtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGlkKSlcbiAgICAgICAgLmZvckVhY2goKFtyb3V0ZUlkLCBlcnJvcl0pID0+IHtcbiAgICAgICAgICBlcnJvcnMgPSBPYmplY3QuYXNzaWduKGVycm9ycyB8fCB7fSwgeyBbcm91dGVJZF06IGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID1cbiAgICAgIHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uKHNob3VsZFVwZGF0ZUZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9KSxcbiAgICB9O1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nIHwgbnVsbCxcbiAgICBvcHRzPzogUm91dGVyRmV0Y2hPcHRpb25zXG4gICkge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgK1xuICAgICAgICAgIFwiVHJ5IG1vdmluZyBpdCB0byBhIHVzZUVmZmVjdCBvciBhIGNhbGxiYWNrLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsXG4gICAgICBocmVmLFxuICAgICAgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLFxuICAgICAgcm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoIH0pLFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCxcbiAgICAgIHRydWUsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG5cbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBmbHVzaFN5bmMsXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxuICAgIC8vIHJldmFsaWRhdGlvbnNcbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHsgcm91dGVJZCwgcGF0aCB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgICAga2V5LFxuICAgICAgcm91dGVJZCxcbiAgICAgIHBhdGgsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIG1hdGNoZWQgZmV0Y2hlci5zdWJtaXQoKSwgYW5kIHRoZW4gaGFuZGxlIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBhbmQgcmV2YWxpZGF0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgICByZXF1ZXN0TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGZsdXNoU3luYzogYm9vbGVhbixcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcblxuICAgIGlmICghbWF0Y2gucm91dGUuYWN0aW9uICYmICFtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luYyxcbiAgICB9KTtcblxuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBhY3Rpb25SZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgIFwiYWN0aW9uXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBbbWF0Y2hdLFxuICAgICAgcmVxdWVzdE1hdGNoZXNcbiAgICApO1xuICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHRzWzBdO1xuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZW4gdXNpbmcgdjdfZmV0Y2hlclBlcnNpc3QsIHdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIHRvIHRoZSBVSVxuICAgIC8vIG9yIHJlZGlyZWN0cyBwcm9jZXNzZWQgZm9yIHVubW91bnRlZCBmZXRjaGVycyBzbyB3ZSBqdXN0IHJldmVydCB0aGVtIHRvXG4gICAgLy8gaWRsZVxuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QgJiYgZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpIHx8IGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gTGV0IFN1Y2Nlc3NSZXN1bHQncyBmYWxsIHRocm91Z2ggZm9yIHJldmFsaWRhdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgYWN0aW9uIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgICAvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhpcyByZWRpcmVjdCBuYXZpZ2F0aW9uLiAgV2UgYWxyZWFkeVxuICAgICAgICAgIC8vIHNldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHNvIGFsbCBsb2FkZXJzIGZvciB0aGUgbmV3IHJvdXRlIHNob3VsZFxuICAgICAgICAgIC8vIGZpcmUgdW5sZXNzIG9wdGVkIG91dCB2aWEgc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oZmV0Y2hSZXF1ZXN0LCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIlxuICAgICAgICA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBiYXNlbmFtZSlcbiAgICAgICAgOiBzdGF0ZS5tYXRjaGVzO1xuXG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG5cbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcblxuICAgIGxldCBsb2FkRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG5cbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgZmFsc2UsXG4gICAgICBmdXR1cmUudW5zdGFibGVfc2tpcEFjdGlvbkVycm9yUmV2YWxpZGF0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZGVsZXRlZEZldGNoZXJzLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgW21hdGNoLnJvdXRlLmlkLCBhY3Rpb25SZXN1bHRdXG4gICAgKTtcblxuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnNcbiAgICAgIC5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSlcbiAgICAgIC5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoc3RhbGVLZXkpKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKHN0YWxlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PlxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcblxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG5cbiAgICBsZXQgeyBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChbLi4ubG9hZGVyUmVzdWx0cywgLi4uZmV0Y2hlclJlc3VsdHNdKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID1cbiAgICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXZhbGlkYXRpb25SZXF1ZXN0LCByZWRpcmVjdC5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgIGFjdGl2ZURlZmVycmVkc1xuICAgICk7XG5cbiAgICAvLyBTaW5jZSB3ZSBsZXQgcmV2YWxpZGF0aW9ucyBjb21wbGV0ZSBldmVuIGlmIHRoZSBzdWJtaXR0aW5nIGZldGNoZXIgd2FzXG4gICAgLy8gZGVsZXRlZCwgb25seSBwdXQgaXQgYmFjayB0byBpZGxlIGlmIGl0IGhhc24ndCBiZWVuIGRlbGV0ZWRcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG5cbiAgICBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhIG5hdmlnYXRpb24gbG9hZGluZyBzdGF0ZSBhbmQgdGhpcyBmZXRjaGVyIGlzXG4gICAgLy8gbW9yZSByZWNlbnQgdGhhbiB0aGUgbmF2aWdhdGlvbiwgd2Ugd2FudCB0aGUgbmV3ZXIgZGF0YSBzbyBhYm9ydCB0aGVcbiAgICAvLyBuYXZpZ2F0aW9uIGFuZCBjb21wbGV0ZSBpdCB3aXRoIHRoZSBmZXRjaGVyIGRhdGFcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJlxuICAgICAgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWRcbiAgICApIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuXG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgd2l0aCB0aGUgZmV0Y2hlciBkYXRhLCBwcmVzZXJ2aW5nIGFueSBleGlzdGluZ1xuICAgICAgLy8gbG9hZGVyRGF0YSBmb3IgbG9hZGVycyB0aGF0IGRpZCBub3QgbmVlZCB0byByZWxvYWQuICBXZSBoYXZlIHRvXG4gICAgICAvLyBtYW51YWxseSBtZXJnZSBoZXJlIHNpbmNlIHdlIGFyZW4ndCBnb2luZyB0aHJvdWdoIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgKSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCB0aGUgbWF0Y2hlZCBsb2FkZXIgZm9yIGZldGNoZXIubG9hZCgpLCBoYW5kbGluZyByZWRpcmVjdHMsIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGZsdXNoU3luYzogYm9vbGVhbixcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuICApIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKFxuICAgICAga2V5LFxuICAgICAgZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gICAgICApLFxuICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICk7XG5cbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcblxuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICBcImxvYWRlclwiLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgW21hdGNoXSxcbiAgICAgIG1hdGNoZXNcbiAgICApO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzWzBdO1xuXG4gICAgLy8gRGVmZXJyZWQgaXNuJ3Qgc3VwcG9ydGVkIGZvciBmZXRjaGVyIGxvYWRzLCBhd2FpdCBldmVyeXRoaW5nIGFuZCB0cmVhdCBpdFxuICAgIC8vIGFzIGEgbm9ybWFsIGxvYWQuICByZXNvbHZlRGVmZXJyZWREYXRhIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGlzXG4gICAgLy8gZmV0Y2hlciBnZXRzIGFib3J0ZWQsIHNvIHdlIGp1c3QgbGVhdmUgcmVzdWx0IHVudG91Y2hlZCBhbmQgc2hvcnQgY2lyY3VpdFxuICAgIC8vIGJlbG93IGlmIHRoYXQgaGFwcGVuc1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIChhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCwgdHJ1ZSkpIHx8XG4gICAgICAgIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc28gbG9uZyBhcyB3ZSB3ZXJlbid0IGFib3J0ZWQgYnkgb3VyIG91ciBvd24gZmV0Y2hlclxuICAgIC8vIHJlLWxvYWQgd2hpY2ggd291bGQgaGF2ZSBwdXQgX25ld18gY29udHJvbGxlciBpcyBpbiBmZXRjaENvbnRyb2xsZXJzXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBlcnJvcnMgYnViYmxpbmcgdXAgb3IgcmVkaXJlY3RzIGZvbGxvd2VkIGZvciB1bm1vdW50ZWRcbiAgICAvLyBmZXRjaGVycywgc28gc2hvcnQgY2lyY3VpdCBoZXJlIGlmIGl0IHdhcyByZW1vdmVkIGZyb20gdGhlIFVJXG4gICAgaWYgKGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvYWRlciB0aHJldyBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHdhcyBraWNrZWQgb2ZmIGFmdGVyIG91ciBsb2FkZXIgc3RhcnRlZCwgc28gdGhhdFxuICAgICAgICAvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhpcyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIHJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcblxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cbiAgICogTm9ybWFsbHksIGEgcmVkaXJlY3QgXCJyZXBsYWNlc1wiIHRoZSBuYXZpZ2F0aW9uIHRoYXQgdHJpZ2dlcmVkIGl0LiAgU28sIGZvclxuICAgKiBleGFtcGxlOlxuICAgKlxuICAgKiAgLSB1c2VyIGlzIG9uIC9hXG4gICAqICAtIHVzZXIgY2xpY2tzIGEgbGluayB0byAvYlxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xuICAgKlxuICAgKiBJbiBhIG5vbi1KUyBhcHAgdGhlIGJyb3dzZXIgd291bGQgdHJhY2sgdGhlIGluLWZsaWdodCBuYXZpZ2F0aW9uIHRvIC9iIGFuZFxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXG4gICAqIHRoZSBlbmQgaXQgd291bGQgb25seSBldmVyIHVwZGF0ZSB0aGUgVVJMIGJhciB3aXRoIC9jLlxuICAgKlxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXG4gICAqIHRoaXMgYmVoYXZpb3IgYW5kIHdlIGFsc28gZG8gbm90IHVwZGF0ZSBoaXN0b3J5IHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gICAqIG5hdmlnYXRpb24gKGluY2x1ZGluZyBwcm9jZXNzZWQgcmVkaXJlY3RzKS4gIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZXZlclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXG4gICAqIHRoZSBoaXN0b3J5IGFjdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uIChQVVNIIG9yIFJFUExBQ0UpLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICByZWRpcmVjdDogUmVkaXJlY3RSZXN1bHQsXG4gICAge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgcmVwbGFjZSxcbiAgICB9OiB7XG4gICAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIGZldGNoZXJTdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIH0gPSB7fVxuICApIHtcbiAgICBpZiAocmVkaXJlY3QucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBsb2NhdGlvbiA9IHJlZGlyZWN0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gICAgaW52YXJpYW50KGxvY2F0aW9uLCBcIkV4cGVjdGVkIGEgTG9jYXRpb24gaGVhZGVyIG9uIHRoZSByZWRpcmVjdCBSZXNwb25zZVwiKTtcbiAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24oXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuICAgIGxldCByZWRpcmVjdExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uLCB7XG4gICAgICBfaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG5cbiAgICAgIGlmIChyZWRpcmVjdC5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpKSB7XG4gICAgICAgIC8vIEhhcmQgcmVsb2FkIGlmIHRoZSByZXNwb25zZSBjb250YWluZWQgWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgICAgICBjb25zdCB1cmwgPSBpbml0Lmhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9XG4gICAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgICAgdXJsLm9yaWdpbiAhPT0gcm91dGVyV2luZG93LmxvY2F0aW9uLm9yaWdpbiB8fFxuICAgICAgICAgIC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRoYXQgZG9lcyBub3QgbWF0Y2ggb3VyIGJhc2VuYW1lXG4gICAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEb2N1bWVudFJlbG9hZCkge1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGFib3J0IG9uIHJlZGlyZWN0cywgc2luY2Ugd2UgZG9uJ3QgZGV0ZWN0IHRoZVxuICAgIC8vIHJlZGlyZWN0IHVudGlsIHRoZSBhY3Rpb24vbG9hZGVycyBoYXZlIHNldHRsZWRcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9XG4gICAgICByZXBsYWNlID09PSB0cnVlID8gSGlzdG9yeUFjdGlvbi5SZXBsYWNlIDogSGlzdG9yeUFjdGlvbi5QdXNoO1xuXG4gICAgLy8gVXNlIHRoZSBpbmNvbWluZyBzdWJtaXNzaW9uIGlmIHByb3ZpZGVkLCBmYWxsYmFjayBvbiB0aGUgYWN0aXZlIG9uZSBpblxuICAgIC8vIHN0YXRlLm5hdmlnYXRpb25cbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoXG4gICAgICAhc3VibWlzc2lvbiAmJlxuICAgICAgIWZldGNoZXJTdWJtaXNzaW9uICYmXG4gICAgICBmb3JtTWV0aG9kICYmXG4gICAgICBmb3JtQWN0aW9uICYmXG4gICAgICBmb3JtRW5jVHlwZVxuICAgICkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdhcyBhIDMwNy8zMDggc3VibWlzc2lvbiB3ZSB3YW50IHRvIHByZXNlcnZlIHRoZSBIVFRQIG1ldGhvZCBhbmRcbiAgICAvLyByZS1zdWJtaXQgdGhlIEdFVC9QT1NUL1BVVC9QQVRDSC9ERUxFVEUgYXMgYSBzdWJtaXNzaW9uIG5hdmlnYXRpb24gdG8gdGhlXG4gICAgLy8gcmVkaXJlY3RlZCBsb2NhdGlvblxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbjtcbiAgICBpZiAoXG4gICAgICByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMuaGFzKHJlZGlyZWN0LnJlc3BvbnNlLnN0YXR1cykgJiZcbiAgICAgIGFjdGl2ZVN1Ym1pc3Npb24gJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKVxuICAgICkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgLi4uYWN0aXZlU3VibWlzc2lvbixcbiAgICAgICAgICBmb3JtQWN0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcyBmbGFnIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBuYXZpZ2F0aW9uIHN1Ym1pc3Npb24sIHdlIHdpbGwgcHJlc2VydmUgaXQgdGhyb3VnaCB0aGVcbiAgICAgIC8vIHJlZGlyZWN0IG5hdmlnYXRpb25cbiAgICAgIGxldCBvdmVycmlkZU5hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihcbiAgICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgc3VibWlzc2lvblxuICAgICAgKTtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdEhpc3RvcnlBY3Rpb24sIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uLFxuICAgICAgICAvLyBTZW5kIGZldGNoZXIgc3VibWlzc2lvbnMgdGhyb3VnaCBmb3Igc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcyBmbGFnIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXRpbGl0eSB3cmFwcGVyIGZvciBjYWxsaW5nIGRhdGFTdHJhdGVneSBjbGllbnQtc2lkZSB3aXRob3V0IGhhdmluZyB0b1xuICAvLyBwYXNzIGFyb3VuZCB0aGUgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgIHR5cGU6IFwibG9hZGVyXCIgfCBcImFjdGlvblwiLFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuICApOiBQcm9taXNlPERhdGFSZXN1bHRbXT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgICBkYXRhU3RyYXRlZ3lJbXBsLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlc3VsdHMubWFwKChyZXN1bHQsIGkpID0+IHtcbiAgICAgICAgICBpZiAoaXNSZWRpcmVjdEhhbmRsZXJSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnJlc3VsdCBhcyBSZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgICAgICAgIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udmVydEhhbmRsZXJSZXN1bHRUb0RhdGFSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgdGhlIG91dGVyIGRhdGFTdHJhdGVneSBtZXRob2QgdGhyb3dzLCBqdXN0IHJldHVybiB0aGUgZXJyb3IgZm9yIGFsbFxuICAgICAgLy8gbWF0Y2hlcyAtIGFuZCBpdCdsbCBuYXR1cmFsbHkgYnViYmxlIHRvIHRoZSByb290XG4gICAgICByZXR1cm4gbWF0Y2hlc1RvTG9hZC5tYXAoKCkgPT4gKHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgIGN1cnJlbnRNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBmZXRjaGVyc1RvTG9hZDogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICAgIHJlcXVlc3Q6IFJlcXVlc3RcbiAgKSB7XG4gICAgbGV0IFtsb2FkZXJSZXN1bHRzLCAuLi5mZXRjaGVyUmVzdWx0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBtYXRjaGVzVG9Mb2FkLmxlbmd0aFxuICAgICAgICA/IGNhbGxEYXRhU3RyYXRlZ3koXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcylcbiAgICAgICAgOiBbXSxcbiAgICAgIC4uLmZldGNoZXJzVG9Mb2FkLm1hcCgoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2ggJiYgZi5jb250cm9sbGVyKSB7XG4gICAgICAgICAgbGV0IGZldGNoZXJSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICAgICAgICBpbml0Lmhpc3RvcnksXG4gICAgICAgICAgICBmLnBhdGgsXG4gICAgICAgICAgICBmLmNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgICBmZXRjaGVyUmVxdWVzdCxcbiAgICAgICAgICAgIFtmLm1hdGNoXSxcbiAgICAgICAgICAgIGYubWF0Y2hlc1xuICAgICAgICAgICkudGhlbigocikgPT4gclswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZTxEYXRhUmVzdWx0Pih7XG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgICAgICAgIHBhdGhuYW1lOiBmLnBhdGgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgXSk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICAgICAgICBjdXJyZW50TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgICAgbG9hZGVyUmVzdWx0cy5tYXAoKCkgPT4gcmVxdWVzdC5zaWduYWwpLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVxuICAgICAgKSxcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IGYubWF0Y2gpLFxuICAgICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgICAgZmV0Y2hlcnNUb0xvYWQubWFwKChmKSA9PiAoZi5jb250cm9sbGVyID8gZi5jb250cm9sbGVyLnNpZ25hbCA6IG51bGwpKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycnVwdEFjdGl2ZUxvYWRzKCkge1xuICAgIC8vIEV2ZXJ5IGludGVycnVwdGlvbiB0cmlnZ2VycyBhIHJldmFsaWRhdGlvblxuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG5cbiAgICAvLyBBYm9ydCBpbi1mbGlnaHQgZmV0Y2hlciBsb2Fkc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMucHVzaChrZXkpO1xuICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZldGNoZXJTdGF0ZShcbiAgICBrZXk6IHN0cmluZyxcbiAgICBmZXRjaGVyOiBGZXRjaGVyLFxuICAgIG9wdHM6IHsgZmx1c2hTeW5jPzogYm9vbGVhbiB9ID0ge31cbiAgKSB7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEZldGNoZXJFcnJvcihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgZXJyb3I6IGFueSxcbiAgICBvcHRzOiB7IGZsdXNoU3luYz86IGJvb2xlYW4gfSA9IHt9XG4gICkge1xuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgIH0sXG4gICAgICB7IGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlIH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcjxURGF0YSA9IGFueT4oa2V5OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPiB7XG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApICsgMSk7XG4gICAgICAvLyBJZiB0aGlzIGZldGNoZXIgd2FzIHByZXZpb3VzbHkgbWFya2VkIGZvciBkZWxldGlvbiwgdW5tYXJrIGl0IHNpbmNlIHdlXG4gICAgICAvLyBoYXZlIGEgbmV3IGluc3RhbmNlXG4gICAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIC8vIERvbid0IGFib3J0IHRoZSBjb250cm9sbGVyIGlmIHRoaXMgaXMgYSBkZWxldGlvbiBvZiBhIGZldGNoZXIuc3VibWl0KClcbiAgICAvLyBpbiBpdCdzIGxvYWRpbmcgcGhhc2Ugc2luY2UgLSB3ZSBkb24ndCB3YW50IHRvIGFib3J0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgLy8gcmV2YWxpZGF0aW9uIGFuZCB3YW50IHRoZW0gdG8gY29tcGxldGUgYW5kIGxhbmRcbiAgICBpZiAoXG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmXG4gICAgICAhKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgZmV0Y2hSZWxvYWRJZHMuaGFzKGtleSkpXG4gICAgKSB7XG4gICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICB9XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIGRlbGV0ZWRGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXJBbmRVcGRhdGVTdGF0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleTogc3RyaW5nKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBgRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogJHtrZXl9YCk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoZmV0Y2hlci5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk6IGJvb2xlYW4ge1xuICAgIGxldCBkb25lS2V5cyA9IFtdO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB1cGRhdGVkRmV0Y2hlcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgICAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5ZWV0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKHllZXRlZEtleXMpO1xuICAgIHJldHVybiB5ZWV0ZWRLZXlzLmxlbmd0aCA+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleTogc3RyaW5nLCBmbjogQmxvY2tlckZ1bmN0aW9uKSB7XG4gICAgbGV0IGJsb2NrZXI6IEJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG5cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlQmxvY2tlcihrZXk6IHN0cmluZykge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHVwZGF0ZSBibG9ja2VycywgZW5zdXJpbmcgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnNcbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXk6IHN0cmluZywgbmV3QmxvY2tlcjogQmxvY2tlcikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuXG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcbiAgICAvLyBodHRwczovL21lcm1haWQubGl2ZS9lZGl0I3Bha286ZU5xVmtjOU93ekFNeGw4bDhubmpBWXJFdERJT0hFQklnd3ZLSlRSZUd5M19sRHBJcU8yN2s2YXdNRzBYY3JMbG56ODdud2RvbkVTb2dLWFhCdUU3OXJxNzVYWk8zLXlIZHMwUkpWdXY3MFlyUGxVckNFZTJIZnJPUlMzcnVicVpmdWh0cGc1Qzl3azV0WjRWS2NSVXE4OHE5WjhSUzAtNDhjRTFpSEprTDB1Z2JIdUZMdXM5TDZzcFp5OG5YOU1QMkNOZG9tVmFwb3NxdTNmR2F5VDhUOC1qSlF3aGVwb19VdHBnQlFhREVVb20wNGRaaEFOMWFKQkRsVUtKQnhFMWNlQjJTbWowTWxuLUlCVzVBRlUyZHdVaWt0dF8yUWFxMmRCZmFLZEV1cDg1VVY3WWQtZEtqbG5rYWJsMlB2cjBEVGtUcmVNXG4gICAgaW52YXJpYW50KFxuICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIpLFxuICAgICAgYEludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiAke2Jsb2NrZXIuc3RhdGV9IC0+ICR7bmV3QmxvY2tlci5zdGF0ZX1gXG4gICAgKTtcblxuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICBuZXh0TG9jYXRpb24sXG4gICAgaGlzdG9yeUFjdGlvbixcbiAgfToge1xuICAgIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gICAgbmV4dExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xuICB9KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugb255IHN1cHBvcnQgYSBzaW5nbGUgYWN0aXZlIGJsb2NrZXIgYXQgdGhlIG1vbWVudCBzaW5jZSB3ZSBkb24ndCBoYXZlXG4gICAgLy8gYW55IGNvbXBlbGxpbmcgdXNlIGNhc2VzIGZvciBtdWx0aS1ibG9ja2VyIHlldFxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cblxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuXG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIC8vIElmIHRoZSBibG9ja2VyIGlzIGN1cnJlbnRseSBwcm9jZWVkaW5nLCB3ZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrXG4gICAgICAvLyBpdCBhbmQgY2FuIGxldCB0aGlzIG5hdmlnYXRpb24gY29udGludWVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBrbm93IHdlJ3JlIHVuYmxvY2tlZC9ibG9ja2VkIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlXG4gICAgLy8gdXNlci1wcm92aWRlZCBibG9ja2VyIGZ1bmN0aW9uXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoXG4gICAgcHJlZGljYXRlPzogKHJvdXRlSWQ6IHN0cmluZykgPT4gYm9vbGVhblxuICApOiBzdHJpbmdbXSB7XG4gICAgbGV0IGNhbmNlbGxlZFJvdXRlSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZmQsIHJvdXRlSWQpID0+IHtcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShyb3V0ZUlkKSkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlZmVycmVkIC0gYnV0IGRvIG5vdCByZW1vdmUgZnJvbSBhY3RpdmVEZWZlcnJlZHMgaGVyZSAtXG4gICAgICAgIC8vIHdlIHJlbHkgb24gdGhlIHN1YnNjcmliZXJzIHRvIGRvIHRoYXQgc28gb3VyIHRlc3RzIGNhbiBhc3NlcnQgcHJvcGVyXG4gICAgICAgIC8vIGNsZWFudXAgdmlhIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkc1xuICAgICAgICBkZmQuY2FuY2VsKCk7XG4gICAgICAgIGNhbmNlbGxlZFJvdXRlSWRzLnB1c2gocm91dGVJZCk7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbmNlbGxlZFJvdXRlSWRzO1xuICB9XG5cbiAgLy8gT3B0IGluIHRvIGNhcHR1cmluZyBhbmQgcmVwb3J0aW5nIHNjcm9sbCBwb3NpdGlvbnMgZHVyaW5nIG5hdmlnYXRpb25zLFxuICAvLyB1c2VkIGJ5IHRoZSA8U2Nyb2xsUmVzdG9yYXRpb24+IGNvbXBvbmVudFxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICBwb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0UG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gZ2V0S2V5IHx8IG51bGw7XG5cbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiB5IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNjcm9sbEtleShsb2NhdGlvbjogTG9jYXRpb24sIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSkge1xuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleSkge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcy5tYXAoKG0pID0+IGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBrZXkgfHwgbG9jYXRpb24ua2V5O1xuICAgIH1cbiAgICByZXR1cm4gbG9jYXRpb24ua2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuICApOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm5hbFNldFJvdXRlcyhuZXdSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10pIHtcbiAgICBtYW5pZmVzdCA9IHt9O1xuICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICBuZXdSb3V0ZXMsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBtYW5pZmVzdFxuICAgICk7XG4gIH1cblxuICByb3V0ZXIgPSB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IGZ1dHVyZSgpIHtcbiAgICAgIHJldHVybiBmdXR1cmU7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHJvdXRlcldpbmRvdztcbiAgICB9LFxuICAgIGluaXRpYWxpemUsXG4gICAgc3Vic2NyaWJlLFxuICAgIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uLFxuICAgIG5hdmlnYXRlLFxuICAgIGZldGNoLFxuICAgIHJldmFsaWRhdGUsXG4gICAgLy8gUGFzc3Rocm91Z2ggdG8gaGlzdG9yeS1hd2FyZSBjcmVhdGVIcmVmIHVzZWQgYnkgdXNlSHJlZiBzbyB3ZSBnZXQgcHJvcGVyXG4gICAgLy8gaGFzaC1hd2FyZSBVUkxzIGluIERPTSBwYXRoc1xuICAgIGNyZWF0ZUhyZWY6ICh0bzogVG8pID0+IGluaXQuaGlzdG9yeS5jcmVhdGVIcmVmKHRvKSxcbiAgICBlbmNvZGVMb2NhdGlvbjogKHRvOiBUbykgPT4gaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKHRvKSxcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXI6IGRlbGV0ZUZldGNoZXJBbmRVcGRhdGVTdGF0ZSxcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzLFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVTdGF0aWNIYW5kbGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCA9IFN5bWJvbChcImRlZmVycmVkXCIpO1xuXG4vKipcbiAqIEZ1dHVyZSBmbGFncyB0byB0b2dnbGUgbmV3IGZlYXR1cmUgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyRnV0dXJlQ29uZmlnIHtcbiAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IGJvb2xlYW47XG4gIHY3X3Rocm93QWJvcnRSZWFzb246IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU3RhdGljSGFuZGxlck9wdGlvbnMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gICAqL1xuICBkZXRlY3RFcnJvckJvdW5kYXJ5PzogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uO1xuICBtYXBSb3V0ZVByb3BlcnRpZXM/OiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbiAgZnV0dXJlPzogUGFydGlhbDxTdGF0aWNIYW5kbGVyRnV0dXJlQ29uZmlnPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzogQ3JlYXRlU3RhdGljSGFuZGxlck9wdGlvbnNcbik6IFN0YXRpY0hhbmRsZXIge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcblxuICBsZXQgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uO1xuICBpZiAob3B0cz8ubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cz8uZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IChyb3V0ZSkgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlOiBTdGF0aWNIYW5kbGVyRnV0dXJlQ29uZmlnID0ge1xuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZSxcbiAgICB2N190aHJvd0Fib3J0UmVhc29uOiBmYWxzZSxcbiAgICAuLi4ob3B0cyA/IG9wdHMuZnV0dXJlIDogbnVsbCksXG4gIH07XG5cbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5kZWZpbmVkLFxuICAgIG1hbmlmZXN0XG4gICk7XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICpcbiAgICogLSBgb3B0cy5yZXF1ZXN0Q29udGV4dGAgaXMgYW4gb3B0aW9uYWwgc2VydmVyIGNvbnRleHQgdGhhdCB3aWxsIGJlIHBhc3NlZFxuICAgKiAgIHRvIGFjdGlvbnMvbG9hZGVycyBpbiB0aGUgYGNvbnRleHRgIHBhcmFtZXRlclxuICAgKiAtIGBvcHRzLnNraXBMb2FkZXJFcnJvckJ1YmJsaW5nYCBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCB3aWxsIHByZXZlbnRcbiAgICogICB0aGUgYnViYmxpbmcgb2YgZXJyb3JzIHdoaWNoIGFsbG93cyBzaW5nbGUtZmV0Y2gtdHlwZSBpbXBsZW1lbnRhdGlvbnNcbiAgICogICB3aGVyZSB0aGUgY2xpZW50IHdpbGwgaGFuZGxlIHRoZSBidWJibGluZyBhbmQgd2UgbWF5IG5lZWQgdG8gcmV0dXJuIGRhdGFcbiAgICogICBmb3IgdGhlIGhhbmRsaW5nIHJvdXRlXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gICAgfToge1xuICAgICAgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duO1xuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc/OiBib29sZWFuO1xuICAgICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5PzogRGF0YVN0cmF0ZWd5RnVuY3Rpb247XG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8U3RhdGljSGFuZGxlckNvbnRleHQgfCBSZXNwb25zZT4ge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuXG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA9PT0gdHJ1ZSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2hlbiByZXR1cm5pbmcgU3RhdGljSGFuZGxlckNvbnRleHQsIHdlIHBhdGNoIGJhY2sgaW4gdGhlIGxvY2F0aW9uIGhlcmVcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIGl0IGZvciBSZWFjdCBDb250ZXh0LiAgQnV0IHRoaXMgaGVscHMga2VlcCBvdXIgc3VibWl0IGFuZFxuICAgIC8vIGxvYWRSb3V0ZURhdGEgb3BlcmF0aW5nIG9uIGEgUmVxdWVzdCBpbnN0ZWFkIG9mIGEgTG9jYXRpb25cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeVJvdXRlKCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciB0YXJnZXRlZCByb3V0ZSByZXF1ZXN0cywgZWl0aGVyXG4gICAqIGZvciBmZXRjaCA/X2RhdGEgcmVxdWVzdHMgb3IgcmVzb3VyY2Ugcm91dGUgcmVxdWVzdHMuICBJbiB0aGlzIGNhc2UsIHdlXG4gICAqIGFyZSBvbmx5IGV2ZXIgY2FsbGluZyBhIHNpbmdsZSBhY3Rpb24gb3IgbG9hZGVyLCBhbmQgd2UgYXJlIHJldHVybmluZyB0aGVcbiAgICogcmV0dXJuZWQgdmFsdWUgZGlyZWN0bHkuICBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgYmUgYSBSZXNwb25zZSByZXR1cm5lZFxuICAgKiBmcm9tIHRoZSBhY3Rpb24vbG9hZGVyLCBidXQgaXQgbWF5IGJlIGEgcHJpbWl0aXZlIG9yIG90aGVyIHZhbHVlIGFzIHdlbGwgLVxuICAgKiBhbmQgaW4gc3VjaCBjYXNlcyB0aGUgY2FsbGluZyBjb250ZXh0IHNob3VsZCBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogV2UgZG8gcmVzcGVjdCB0aGUgdGhyb3cvcmV0dXJuIGRpZmZlcmVudGlhdGlvbiwgc28gaWYgYW4gYWN0aW9uL2xvYWRlclxuICAgKiB0aHJvd3MsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyB0aGUgdmFsdWUuICBUaGlzIGlzIGltcG9ydGFudCBzbyB3ZVxuICAgKiBjYW4gZG8gcHJvcGVyIGJvdW5kYXJ5IGlkZW50aWZpY2F0aW9uIGluIFJlbWl4IHdoZXJlIGEgdGhyb3duIFJlc3BvbnNlXG4gICAqIG11c3QgZ28gdG8gdGhlIENhdGNoIEJvdW5kYXJ5IGJ1dCBhIHJldHVybmVkIFJlc3BvbnNlIGlzIGhhcHB5LXBhdGguXG4gICAqXG4gICAqIE9uZSB0aGluZyB0byBub3RlIGlzIHRoYXQgYW55IFJvdXRlci1pbml0aWF0ZWQgRXJyb3JzIHRoYXQgbWFrZSBzZW5zZVxuICAgKiB0byBhc3NvY2lhdGUgd2l0aCBhIHN0YXR1cyBjb2RlIHdpbGwgYmUgdGhyb3duIGFzIGFuIEVycm9yUmVzcG9uc2VcbiAgICogaW5zdGFuY2Ugd2hpY2ggaW5jbHVkZSB0aGUgcmF3IEVycm9yLCBzdWNoIHRoYXQgdGhlIGNhbGxpbmcgY29udGV4dCBjYW5cbiAgICogc2VyaWFsaXplIHRoZSBlcnJvciBhcyB0aGV5IHNlZSBmaXQgd2hpbGUgaW5jbHVkaW5nIHRoZSBwcm9wZXIgcmVzcG9uc2VcbiAgICogY29kZS4gIEV4YW1wbGVzIGhlcmUgYXJlIDQwNCBhbmQgNDA1IGVycm9ycyB0aGF0IG9jY3VyIHByaW9yIHRvIHJlYWNoaW5nXG4gICAqIGFueSB1c2VyLWRlZmluZWQgbG9hZGVycy5cbiAgICpcbiAgICogLSBgb3B0cy5yb3V0ZUlkYCBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHNwZWNpZmljIHJvdXRlIGhhbmRsZXIgdG8gY2FsbC5cbiAgICogICBJZiBub3QgcHJvdmlkZWQgdGhlIGhhbmRsZXIgd2lsbCBkZXRlcm1pbmUgdGhlIHByb3BlciByb3V0ZSBieSBtYXRjaGluZ1xuICAgKiAgIGFnYWluc3QgYHJlcXVlc3QudXJsYFxuICAgKiAtIGBvcHRzLnJlcXVlc3RDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBzZXJ2ZXIgY29udGV4dCB0aGF0IHdpbGwgYmUgcGFzc2VkXG4gICAqICAgIHRvIGFjdGlvbnMvbG9hZGVycyBpbiB0aGUgYGNvbnRleHRgIHBhcmFtZXRlclxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneSxcbiAgICB9OiB7XG4gICAgICByZXF1ZXN0Q29udGV4dD86IHVua25vd247XG4gICAgICByb3V0ZUlkPzogc3RyaW5nO1xuICAgICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5PzogRGF0YVN0cmF0ZWd5RnVuY3Rpb247XG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkXG4gICAgICA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZClcbiAgICAgIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgZmFsc2UsXG4gICAgICBtYXRjaFxuICAgICk7XG5cbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmxvYWRlckRhdGEpIHtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAocmVzdWx0LmFjdGl2ZURlZmVycmVkcz8uW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3k6IERhdGFTdHJhdGVneUZ1bmN0aW9uIHwgbnVsbCxcbiAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogYm9vbGVhbixcbiAgICByb3V0ZU1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbFxuICApOiBQcm9taXNlPE9taXQ8U3RhdGljSGFuZGxlckNvbnRleHQsIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIj4gfCBSZXNwb25zZT4ge1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZU1hdGNoIHx8IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgICAgcm91dGVNYXRjaCAhPSBudWxsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgcm91dGVNYXRjaFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdClcbiAgICAgICAgPyByZXN1bHRcbiAgICAgICAgOiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiBmb3IgYVxuICAgICAgLy8gYHF1ZXJ5Um91dGVgIGNhbGwsIHdlIHRocm93IHRoZSBgSGFuZGxlclJlc3VsdGAgdG8gYmFpbCBvdXQgZWFybHlcbiAgICAgIC8vIGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyB0aGUgcmF3IFJlc3BvbnNlIGhlcmUgYWNjb3JkaW5nbHlcbiAgICAgIGlmIChpc0hhbmRsZXJSZXN1bHQoZSkgJiYgaXNSZXNwb25zZShlLnJlc3VsdCkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIFJlZGlyZWN0cyBhcmUgYWx3YXlzIHJldHVybmVkIHNpbmNlIHRoZXkgZG9uJ3QgcHJvcGFnYXRlIHRvIGNhdGNoXG4gICAgICAvLyBib3VuZGFyaWVzXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgYWN0aW9uTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5OiBEYXRhU3RyYXRlZ3lGdW5jdGlvbiB8IG51bGwsXG4gICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc6IGJvb2xlYW4sXG4gICAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIFthY3Rpb25NYXRjaF0sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1swXTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFVoaGhoIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgYWx3YXlzIHRocm93IHRoZXNlIGZyb21cbiAgICAgIC8vIGNhbGxMb2FkZXJPckFjdGlvbiwgYnV0IHRoZSB0eXBlIG5hcnJvd2luZyBoZXJlIGtlZXBzIFRTIGhhcHB5IGFuZCB3ZVxuICAgICAgLy8gY2FuIGdldCBiYWNrIG9uIHRoZSBcInRocm93IGFsbCByZWRpcmVjdCByZXNwb25zZXNcIiB0cmFpbiBoZXJlIHNob3VsZFxuICAgICAgLy8gdGhpcyBldmVyIGhhcHBlbiA6L1xuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpISxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiZGVmZXItYWN0aW9uXCIgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIC8vIE5vdGU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgbm9uLVJlc3BvbnNlIHZhbHVlcyBpZiB3ZSBnZXQgaGVyZSwgc2luY2VcbiAgICAgIC8vIGlzUm91dGVSZXF1ZXN0IHNob3VsZCB0aHJvdyBhbnkgUmVzcG9uc2UgcmVjZWl2ZWQgaW4gY2FsbExvYWRlck9yQWN0aW9uXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAvLyBOb3RlOiBzdGF0dXNDb2RlICsgaGVhZGVycyBhcmUgdW51c2VkIGhlcmUgc2luY2UgcXVlcnlSb3V0ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIG9yIHZhbHVlXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcbiAgICB9KTtcblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBza2lwTG9hZGVyRXJyb3JCdWJibGluZ1xuICAgICAgICA/IGFjdGlvbk1hdGNoXG4gICAgICAgIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG5cbiAgICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgbG9hZGVyUmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneSxcbiAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgICApO1xuXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGF0dXNcbiAgICAgICAgICA6IHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGxcbiAgICAgICAgICA/IHJlc3VsdC5zdGF0dXNDb2RlXG4gICAgICAgICAgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgIGxvYWRlclJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgIG51bGxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhLFxuICAgICAgfSxcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgLi4uKHJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30pLFxuICAgICAgYWN0aW9uSGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgICAgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH1cbiAgICAgICAgOiB7fSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlRGF0YShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3k6IERhdGFTdHJhdGVneUZ1bmN0aW9uIHwgbnVsbCxcbiAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogYm9vbGVhbixcbiAgICByb3V0ZU1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbCxcbiAgICBwZW5kaW5nQWN0aW9uUmVzdWx0PzogUGVuZGluZ0FjdGlvblJlc3VsdFxuICApOiBQcm9taXNlPFxuICAgIHwgT21pdDxcbiAgICAgICAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gICAgICAgIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIiB8IFwiYWN0aW9uRGF0YVwiIHwgXCJhY3Rpb25IZWFkZXJzXCJcbiAgICAgID5cbiAgICB8IFJlc3BvbnNlXG4gID4ge1xuICAgIGxldCBpc1JvdXRlUmVxdWVzdCA9IHJvdXRlTWF0Y2ggIT0gbnVsbDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnlSb3V0ZSgpKVxuICAgIGlmIChcbiAgICAgIGlzUm91dGVSZXF1ZXN0ICYmXG4gICAgICAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmXG4gICAgICAhcm91dGVNYXRjaD8ucm91dGUubGF6eVxuICAgICkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZU1hdGNoPy5yb3V0ZS5pZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0TWF0Y2hlcyA9IHJvdXRlTWF0Y2hcbiAgICAgID8gW3JvdXRlTWF0Y2hdXG4gICAgICA6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKVxuICAgICAgPyBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdKVxuICAgICAgOiBtYXRjaGVzO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gcmVxdWVzdE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0ucm91dGUubG9hZGVyIHx8IG0ucm91dGUubGF6eVxuICAgICk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5KCkpXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICAvLyBBZGQgYSBudWxsIGZvciBhbGwgbWF0Y2hlZCByb3V0ZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgICAgICBsb2FkZXJEYXRhOiBtYXRjaGVzLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBtKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbS5yb3V0ZS5pZF06IG51bGwgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKSxcbiAgICAgICAgZXJyb3JzOlxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3lcbiAgICApO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCwgZnV0dXJlKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICBhY3RpdmVEZWZlcnJlZHMsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZ1xuICAgICk7XG5cbiAgICAvLyBBZGQgYSBudWxsIGZvciBhbnkgbm9uLWxvYWRlciBtYXRjaGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICBsZXQgZXhlY3V0ZWRMb2FkZXJzID0gbmV3IFNldDxzdHJpbmc+KFxuICAgICAgbWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PiBtYXRjaC5yb3V0ZS5pZClcbiAgICApO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHM6XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zaXplID4gMFxuICAgICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKGFjdGl2ZURlZmVycmVkcy5lbnRyaWVzKCkpXG4gICAgICAgICAgOiBudWxsLFxuICAgIH07XG4gIH1cblxuICAvLyBVdGlsaXR5IHdyYXBwZXIgZm9yIGNhbGxpbmcgZGF0YVN0cmF0ZWd5IHNlcnZlci1zaWRlIHdpdGhvdXQgaGF2aW5nIHRvXG4gIC8vIHBhc3MgYXJvdW5kIHRoZSBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgdHlwZTogXCJsb2FkZXJcIiB8IFwiYWN0aW9uXCIsXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneTogRGF0YVN0cmF0ZWd5RnVuY3Rpb24gfCBudWxsXG4gICk6IFByb21pc2U8RGF0YVJlc3VsdFtdPiB7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbChcbiAgICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5LFxuICAgICAgdHlwZSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgcmVxdWVzdENvbnRleHRcbiAgICApO1xuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgcmVzdWx0cy5tYXAoKHJlc3VsdCwgaSkgPT4ge1xuICAgICAgICBpZiAoaXNSZWRpcmVjdEhhbmRsZXJSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQgYXMgUmVzcG9uc2U7XG4gICAgICAgICAgLy8gVGhyb3cgcmVkaXJlY3RzIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgdGhlbSB3aXRoIGFuIEhUVFAgcmVkaXJlY3RcbiAgICAgICAgICB0aHJvdyBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICAgIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkgJiYgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrXG4gICAgICAgICAgLy8gZGlyZWN0bHkgd2l0aG91dCB1bndyYXBwaW5nXG4gICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRIYW5kbGVyUmVzdWx0VG9EYXRhUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZSxcbiAgfTtcbn1cblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGVscGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHaXZlbiBhbiBleGlzdGluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCBhbmQgYW4gZXJyb3IgdGhyb3duIGF0IHJlbmRlciB0aW1lLFxuICogcHJvdmlkZSBhbiB1cGRhdGVkIFN0YXRpY0hhbmRsZXJDb250ZXh0IHN1aXRhYmxlIGZvciBhIHNlY29uZCBTU1IgcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKFxuICByb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10sXG4gIGNvbnRleHQ6IFN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICBlcnJvcjogYW55XG4pIHtcbiAgbGV0IG5ld0NvbnRleHQ6IFN0YXRpY0hhbmRsZXJDb250ZXh0ID0ge1xuICAgIC4uLmNvbnRleHQsXG4gICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzIDogNTAwLFxuICAgIGVycm9yczoge1xuICAgICAgW2NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgfHwgcm91dGVzWzBdLmlkXTogZXJyb3IsXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW4sXG4gIGZ1dHVyZTogU3RhdGljSGFuZGxlckZ1dHVyZUNvbmZpZ1xuKSB7XG4gIGlmIChmdXR1cmUudjdfdGhyb3dBYm9ydFJlYXNvbiAmJiByZXF1ZXN0LnNpZ25hbC5yZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IHJlcXVlc3Quc2lnbmFsLnJlYXNvbjtcbiAgfVxuXG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gKTtcbn1cblxuZnVuY3Rpb24gaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihcbiAgb3B0czogQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnNcbik6IG9wdHMgaXMgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyB7XG4gIHJldHVybiAoXG4gICAgb3B0cyAhPSBudWxsICYmXG4gICAgKChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwpIHx8XG4gICAgICAoXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvKFxuICBsb2NhdGlvbjogUGF0aCxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBiYXNlbmFtZTogc3RyaW5nLFxuICBwcmVwZW5kQmFzZW5hbWU6IGJvb2xlYW4sXG4gIHRvOiBUbyB8IG51bGwsXG4gIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBib29sZWFuLFxuICBmcm9tUm91dGVJZD86IHN0cmluZyxcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlXG4pIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG4gIGxldCBhY3RpdmVSb3V0ZU1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgdW5kZWZpbmVkO1xuICBpZiAoZnJvbVJvdXRlSWQpIHtcbiAgICAvLyBHcmFiIG1hdGNoZXMgdXAgdG8gdGhlIGNhbGxpbmcgcm91dGUgc28gb3VyIHJvdXRlLXJlbGF0aXZlIGxvZ2ljIGlzXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIGNvcnJlY3Qgc291cmNlIHJvdXRlXG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb250ZXh0dWFsTWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCA9PT0gZnJvbVJvdXRlSWQpIHtcbiAgICAgICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvLyBSZXNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvID8gdG8gOiBcIi5cIixcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCksXG4gICAgc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuXG4gIC8vIFdoZW4gYHRvYCBpcyBub3Qgc3BlY2lmaWVkIHdlIGluaGVyaXQgc2VhcmNoL2hhc2ggZnJvbSB0aGUgY3VycmVudFxuICAvLyBsb2NhdGlvbiwgdW5saWtlIHdoZW4gdG89XCIuXCIgYW5kIHdlIGp1c3QgaW5oZXJpdCB0aGUgcGF0aC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICBpZiAodG8gPT0gbnVsbCkge1xuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIH1cblxuICAvLyBBZGQgYW4gP2luZGV4IHBhcmFtIGZvciBtYXRjaGVkIGluZGV4IHJvdXRlcyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmIChcbiAgICAodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmXG4gICAgYWN0aXZlUm91dGVNYXRjaCAmJlxuICAgIGFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiZcbiAgICAhaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKVxuICApIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoXG4gICAgICA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIilcbiAgICAgIDogXCI/aW5kZXhcIjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUuICBJZlxuICAvLyB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzXG4gIC8vIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhIHRyYWlsaW5nIHNsYXNoXG4gIC8vIG9uIHJvb3QgYWN0aW9uc1xuICBpZiAocHJlcGVuZEJhc2VuYW1lICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPVxuICAgICAgcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuXG4vLyBOb3JtYWxpemUgbmF2aWdhdGlvbiBvcHRpb25zIGJ5IGNvbnZlcnRpbmcgZm9ybU1ldGhvZD1HRVQgZm9ybURhdGEgb2JqZWN0cyB0b1xuLy8gVVJMU2VhcmNoUGFyYW1zIHNvIHRoZXkgYmVoYXZlIGlkZW50aWNhbGx5IHRvIGxpbmtzIHdpdGggcXVlcnkgcGFyYW1zXG5mdW5jdGlvbiBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gIG5vcm1hbGl6ZUZvcm1NZXRob2Q6IGJvb2xlYW4sXG4gIGlzRmV0Y2hlcjogYm9vbGVhbixcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRzPzogQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnNcbik6IHtcbiAgcGF0aDogc3RyaW5nO1xuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgZXJyb3I/OiBFcnJvclJlc3BvbnNlSW1wbDtcbn0ge1xuICAvLyBSZXR1cm4gbG9jYXRpb24gdmVyYmF0aW0gb24gbm9uLXN1Ym1pc3Npb24gbmF2aWdhdGlvbnNcbiAgaWYgKCFvcHRzIHx8ICFpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCB9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2QgfSksXG4gICAgfTtcbiAgfVxuXG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImludmFsaWQtYm9keVwiIH0pLFxuICB9KTtcblxuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kXG4gICAgPyAocmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIGFzIFY3X0Zvcm1NZXRob2QpXG4gICAgOiAocmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpIGFzIEZvcm1NZXRob2QpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuXG4gIGlmIChvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgLy8gdGV4dCBvbmx5IHN1cHBvcnQgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRleHQgPVxuICAgICAgICB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgPyBvcHRzLmJvZHlcbiAgICAgICAgICA6IG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8XG4gICAgICAgICAgICBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXNcbiAgICAgICAgICA/IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICAgICAgICBBcnJheS5mcm9tKG9wdHMuYm9keS5lbnRyaWVzKCkpLnJlZHVjZShcbiAgICAgICAgICAgICAgKGFjYywgW25hbWUsIHZhbHVlXSkgPT4gYCR7YWNjfSR7bmFtZX09JHt2YWx1ZX1cXG5gLFxuICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBTdHJpbmcob3B0cy5ib2R5KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICAvLyBqc29uIG9ubHkgc3VwcG9ydHMgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPVxuICAgICAgICAgIHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG9wdHMuYm9keSkgOiBvcHRzLmJvZHk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGludmFyaWFudChcbiAgICB0eXBlb2YgRm9ybURhdGEgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiXG4gICk7XG5cbiAgbGV0IHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE6IEZvcm1EYXRhO1xuXG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uID0ge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTpcbiAgICAgIChvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUpIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgZm9ybURhdGEsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgfTtcblxuICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICB9XG5cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcbiAgLy8gcmVzdWx0aW5nIGxvY2F0aW9uIHNpbmNlIGFsbCBsb2FkZXJzIHdpbGwgcnVuLiAgQnV0IGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zXG4gIC8vIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciBzbyB3ZSBuZWVkIHRvIHByZXNlcnZlIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcblxuICByZXR1cm4geyBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLCBzdWJtaXNzaW9uIH07XG59XG5cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJvdW5kYXJ5SWQ6IHN0cmluZ1xuKSB7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzO1xuICBpZiAoYm91bmRhcnlJZCkge1xuICAgIGxldCBpbmRleCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZGFyeU1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoXG4gIGhpc3Rvcnk6IEhpc3RvcnksXG4gIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uIHwgdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogTG9jYXRpb24sXG4gIGlzSW5pdGlhbExvYWQ6IGJvb2xlYW4sXG4gIHNraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbjogYm9vbGVhbixcbiAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZDogYm9vbGVhbixcbiAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdLFxuICBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdLFxuICBkZWxldGVkRmV0Y2hlcnM6IFNldDxzdHJpbmc+LFxuICBmZXRjaExvYWRNYXRjaGVzOiBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4sXG4gIGZldGNoUmVkaXJlY3RJZHM6IFNldDxzdHJpbmc+LFxuICByb3V0ZXNUb1VzZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgYmFzZW5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcGVuZGluZ0FjdGlvblJlc3VsdD86IFBlbmRpbmdBY3Rpb25SZXN1bHRcbik6IFtBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sIFJldmFsaWRhdGluZ0ZldGNoZXJbXV0ge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgID8gaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKVxuICAgICAgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yXG4gICAgICA6IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgIDogdW5kZWZpbmVkO1xuICBsZXQgY3VycmVudFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0YXRlLmxvY2F0aW9uKTtcbiAgbGV0IG5leHRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChsb2NhdGlvbik7XG5cbiAgLy8gUGljayBuYXZpZ2F0aW9uIG1hdGNoZXMgdGhhdCBhcmUgbmV0LW5ldyBvciBxdWFsaWZ5IGZvciByZXZhbGlkYXRpb25cbiAgbGV0IGJvdW5kYXJ5SWQgPVxuICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKVxuICAgICAgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IGJvdW5kYXJ5SWRcbiAgICA/IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpXG4gICAgOiBtYXRjaGVzO1xuXG4gIC8vIERvbid0IHJldmFsaWRhdGUgbG9hZGVycyBieSBkZWZhdWx0IGFmdGVyIGFjdGlvbiA0eHgvNXh4IHJlc3BvbnNlc1xuICAvLyB3aGVuIHRoZSBmbGFnIGlzIGVuYWJsZWQuICBUaGV5IGNhbiBzdGlsbCBvcHQtaW50byByZXZhbGlkYXRpb24gdmlhXG4gIC8vIGBzaG91bGRSZXZhbGlkYXRlYCB2aWEgYGFjdGlvblJlc3VsdGBcbiAgbGV0IGFjdGlvblN0YXR1cyA9IHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgICA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uc3RhdHVzQ29kZVxuICAgIDogdW5kZWZpbmVkO1xuICBsZXQgc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA9XG4gICAgc2tpcEFjdGlvbkVycm9yUmV2YWxpZGF0aW9uICYmIGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMgPj0gNDAwO1xuXG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCB7IHJvdXRlIH0gPSBtYXRjaDtcbiAgICBpZiAocm91dGUubGF6eSkge1xuICAgICAgLy8gV2UgaGF2ZW4ndCBsb2FkZWQgdGhpcyByb3V0ZSB5ZXQgc28gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIGdvdCBhIGxvYWRlciFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0luaXRpYWxMb2FkKSB7XG4gICAgICBpZiAodHlwZW9mIHJvdXRlLmxvYWRlciAhPT0gXCJmdW5jdGlvblwiIHx8IHJvdXRlLmxvYWRlci5oeWRyYXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVtyb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAvLyBEb24ndCByZS1ydW4gaWYgdGhlIGxvYWRlciByYW4gYW5kIHRocmV3IGFuIGVycm9yXG4gICAgICAgICghc3RhdGUuZXJyb3JzIHx8IHN0YXRlLmVycm9yc1tyb3V0ZS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGNhbGwgdGhlIGxvYWRlciBvbiBuZXcgcm91dGUgaW5zdGFuY2VzIGFuZCBwZW5kaW5nIGRlZmVyIGNhbmNlbGxhdGlvbnNcbiAgICBpZiAoXG4gICAgICBpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8XG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5zb21lKChpZCkgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igd2hlbiB3ZSByZXZhbGlkYXRlLiAgSWYgdGhlIHJvdXRlXG4gICAgLy8gcHJvdmlkZXMgaXQncyBvd24gaW1wbGVtZW50YXRpb24sIHRoZW4gd2UgZ2l2ZSB0aGVtIGZ1bGwgY29udHJvbCBidXRcbiAgICAvLyBwcm92aWRlIHRoaXMgdmFsdWUgc28gdGhleSBjYW4gbGV2ZXJhZ2UgaXQgaWYgbmVlZGVkIGFmdGVyIHRoZXkgY2hlY2tcbiAgICAvLyB0aGVpciBvd24gc3BlY2lmaWMgdXNlIGNhc2VzXG4gICAgbGV0IGN1cnJlbnRSb3V0ZU1hdGNoID0gc3RhdGUubWF0Y2hlc1tpbmRleF07XG4gICAgbGV0IG5leHRSb3V0ZU1hdGNoID0gbWF0Y2g7XG5cbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgdW5zdGFibGVfYWN0aW9uU3RhdHVzOiBhY3Rpb25TdGF0dXMsXG4gICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvblxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHxcbiAgICAgICAgICBjdXJyZW50VXJsLnBhdGhuYW1lICsgY3VycmVudFVybC5zZWFyY2ggPT09XG4gICAgICAgICAgICBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHxcbiAgICAgICAgICAvLyBTZWFyY2ggcGFyYW1zIGFmZmVjdCBhbGwgbG9hZGVyc1xuICAgICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fFxuICAgICAgICAgIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpLFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZTpcbiAgICAvLyAgLSBvbiBpbml0aWFsIGxvYWQgKHNob3VsZG4ndCBiZSBhbnkgZmV0Y2hlcnMgdGhlbiBhbnl3YXkpXG4gICAgLy8gIC0gaWYgZmV0Y2hlciB3b24ndCBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlclxuICAgIC8vICAgIC0gbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIFVSTCAodjdfZmV0Y2hlclBlcnNpc3Q9ZmFsc2UpXG4gICAgLy8gICAgLSB3YXMgdW5tb3VudGVkIGJ1dCBwZXJzaXN0ZWQgZHVlIHRvIHY3X2ZldGNoZXJQZXJzaXN0PXRydWVcbiAgICBpZiAoXG4gICAgICBpc0luaXRpYWxMb2FkIHx8XG4gICAgICAhbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpIHx8XG4gICAgICBkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgZmV0Y2hlciBwYXRoIG5vIGxvbmdlciBtYXRjaGVzLCBwdXNoIGl0IGluIHdpdGggbnVsbCBtYXRjaGVzIHNvXG4gICAgLy8gd2UgY2FuIHRyaWdnZXIgYSA0MDQgaW4gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhLiAgTm90ZSB0aGlzIGlzXG4gICAgLy8gY3VycmVudGx5IG9ubHkgYSB1c2UtY2FzZSBmb3IgUmVtaXggSE1SIHdoZXJlIHRoZSByb3V0ZSB0cmVlIGNhbiBjaGFuZ2VcbiAgICAvLyBhdCBydW50aW1lIGFuZCByZW1vdmUgYSByb3V0ZSBwcmV2aW91c2x5IGxvYWRlZCB2aWEgYSBmZXRjaGVyXG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXG4gICAgICAgIG1hdGNoOiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmV2YWxpZGF0aW5nIGZldGNoZXJzIGFyZSBkZWNvdXBsZWQgZnJvbSB0aGUgcm91dGUgbWF0Y2hlcyBzaW5jZSB0aGV5XG4gICAgLy8gbG9hZCBmcm9tIGEgc3RhdGljIGhyZWYuICBUaGV5IHJldmFsaWRhdGUgYmFzZWQgb24gZXhwbGljaXQgcmV2YWxpZGF0aW9uXG4gICAgLy8gKHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGUpXG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlck1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2goZmV0Y2hlck1hdGNoZXMsIGYucGF0aCk7XG5cbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAvLyBBbHdheXMgcmV2YWxpZGF0ZSBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZmV0Y2hlciAmJlxuICAgICAgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiZcbiAgICAgIGZldGNoZXIuZGF0YSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGUgZmV0Y2hlciBoYXNuJ3QgZXZlciBjb21wbGV0ZWQgbG9hZGluZyB5ZXQsIHRoZW4gdGhpcyBpc24ndCBhXG4gICAgICAvLyByZXZhbGlkYXRpb24sIGl0IHdvdWxkIGp1c3QgYmUgYSBicmFuZCBuZXcgbG9hZCBpZiBhbiBleHBsaWNpdFxuICAgICAgLy8gcmV2YWxpZGF0aW9uIGlzIHJlcXVpcmVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gaXNSZXZhbGlkYXRpb25SZXF1aXJlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayBvbiBhbnkgdXNlci1kZWZpbmVkIHNob3VsZFJldmFsaWRhdGUsIGRlZmF1bHRpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0IHJldmFsaWRhdGlvbnMgb25seVxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCB7XG4gICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgIGN1cnJlbnRQYXJhbXM6IHN0YXRlLm1hdGNoZXNbc3RhdGUubWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgdW5zdGFibGVfYWN0aW9uU3RhdHVzOiBhY3Rpb25TdGF0dXMsXG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBzaG91bGRTa2lwUmV2YWxpZGF0aW9uXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuXG5mdW5jdGlvbiBpc05ld0xvYWRlcihcbiAgY3VycmVudExvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgY3VycmVudE1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuKSB7XG4gIGxldCBpc05ldyA9XG4gICAgLy8gW2FdIC0+IFthLCBiXVxuICAgICFjdXJyZW50TWF0Y2ggfHxcbiAgICAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZDtcblxuICAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBoYXZlIGRhdGEgZm9yIGEgcmUtdXNlZCByb3V0ZSwgcG90ZW50aWFsbHlcbiAgLy8gZnJvbSBhIHByaW9yIGVycm9yIG9yIGZyb20gYSBjYW5jZWxsZWQgcGVuZGluZyBkZWZlcnJlZFxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xuXG4gIC8vIEFsd2F5cyBsb2FkIGlmIHRoaXMgaXMgYSBuZXQtbmV3IHJvdXRlIG9yIHdlIGRvbid0IHlldCBoYXZlIGRhdGFcbiAgcmV0dXJuIGlzTmV3IHx8IGlzTWlzc2luZ0RhdGE7XG59XG5cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShcbiAgY3VycmVudE1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxuICAgIC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICAoY3VycmVudFBhdGggIT0gbnVsbCAmJlxuICAgICAgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmXG4gICAgICBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihcbiAgbG9hZGVyTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGFyZzogU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJnc1xuKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIHJvdXRlLmxhenkoKSBtZXRob2RzIHRvIGxhemlseSBsb2FkIHJvdXRlIG1vZHVsZXMgKGxvYWRlciwgYWN0aW9uLFxuICogc2hvdWxkUmV2YWxpZGF0ZSkgYW5kIHVwZGF0ZSB0aGUgcm91dGVNYW5pZmVzdCBpbiBwbGFjZSB3aGljaCBzaGFyZXMgb2JqZWN0c1xuICogd2l0aCBkYXRhUm91dGVzIHNvIHRob3NlIGdldCB1cGRhdGVkIGFzIHdlbGwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRMYXp5Um91dGVNb2R1bGUoXG4gIHJvdXRlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3Rcbikge1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuXG4gIC8vIElmIHRoZSBsYXp5IHJvdXRlIGZ1bmN0aW9uIHdhcyBleGVjdXRlZCBhbmQgcmVtb3ZlZCBieSBhbm90aGVyIHBhcmFsbGVsXG4gIC8vIGNhbGwgdGhlbiB3ZSBjYW4gcmV0dXJuIC0gZmlyc3QgbGF6eSgpIHRvIGZpbmlzaCB3aW5zIGJlY2F1c2UgdGhlIHJldHVyblxuICAvLyB2YWx1ZSBvZiBsYXp5IGlzIGV4cGVjdGVkIHRvIGJlIHN0YXRpY1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG5cbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAvLyB3ZSBjb3VsZCB5ZXQgYmUgc2l0dGluZyBvbiB0aGlzIHJvdXRlIGFzIHdlIGNhbid0IGdldCB0aGVyZSB3aXRob3V0XG4gIC8vIHJlc29sdmluZyBsYXp5KCkgZmlyc3QuXG4gIC8vXG4gIC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIEhNUiBcInVwZGF0ZVwiIHVzZS1jYXNlIHdoZXJlIHdlIG1heSBhY3RpdmVseSBiZVxuICAvLyBvbiB0aGUgcm91dGUgYmVpbmcgdXBkYXRlZC4gIFRoZSBtYWluIGNvbmNlcm4gYm9pbHMgZG93biB0byBcImRvZXMgdGhpc1xuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xuICAvLyB2YWx1ZXM/XCIuICBJZiBub3QsIGl0IHNob3VsZCBiZSBzYWZlIHRvIHVwZGF0ZSBpbiBwbGFjZS5cbiAgbGV0IHJvdXRlVXBkYXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9XG4gICAgICByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5IGFzIGtleW9mIHR5cGVvZiByb3V0ZVRvVXBkYXRlXTtcblxuICAgIGxldCBpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgPVxuICAgICAgc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAgIC8vIG9uIHRoZSByb3V0ZSB1cGRhdGVzXG4gICAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG5cbiAgICB3YXJuaW5nKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGAgK1xuICAgICAgICBgZGVmaW5lZCBidXQgaXRzIGxhenkgZnVuY3Rpb24gaXMgYWxzbyByZXR1cm5pbmcgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eS4gYCArXG4gICAgICAgIGBUaGUgbGF6eSByb3V0ZSBwcm9wZXJ0eSBcIiR7bGF6eVJvdXRlUHJvcGVydHl9XCIgd2lsbCBiZSBpZ25vcmVkLmBcbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCAmJlxuICAgICAgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkgYXMgSW1tdXRhYmxlUm91dGVLZXkpXG4gICAgKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID1cbiAgICAgICAgbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5IGFzIGtleW9mIHR5cGVvZiBsYXp5Um91dGVdO1xuICAgIH1cbiAgfVxuXG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xuICAvLyB0aGUgdXBkYXRlZCB2ZXJzaW9uIHRvIG1hcFJvdXRlUHJvcGVydGllc1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG5cbiAgLy8gTXV0YXRlIHRoZSBgaGFzRXJyb3JCb3VuZGFyeWAgcHJvcGVydHkgb24gdGhlIHJvdXRlIGJhc2VkIG9uIHRoZSByb3V0ZVxuICAvLyB1cGRhdGVzIGFuZCByZW1vdmUgdGhlIGBsYXp5YCBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNvbHZlIHRoZSBsYXp5XG4gIC8vIHJvdXRlIGFnYWluLlxuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHtcbiAgICAvLyBUbyBrZWVwIHRoaW5ncyBmcmFtZXdvcmsgYWdub3N0aWMsIHdlIHVzZSB0aGUgcHJvdmlkZWRcbiAgICAvLyBgbWFwUm91dGVQcm9wZXJ0aWVzYCAob3Igd3JhcHBlZCBgZGV0ZWN0RXJyb3JCb3VuZGFyeWApIGZ1bmN0aW9uIHRvXG4gICAgLy8gc2V0IHRoZSBmcmFtZXdvcmstYXdhcmUgcHJvcGVydGllcyAoYGVsZW1lbnRgL2BoYXNFcnJvckJvdW5kYXJ5YCkgc2luY2VcbiAgICAvLyB0aGUgbG9naWMgd2lsbCBkaWZmZXIgYmV0d2VlbiBmcmFtZXdvcmtzLlxuICAgIC4uLm1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZVRvVXBkYXRlKSxcbiAgICBsYXp5OiB1bmRlZmluZWQsXG4gIH0pO1xufVxuXG4vLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBkYXRhU3RyYXRlZ3lgIHdoaWNoIGZldGNoZXMgYWxsIGxvYWRlcnMgaW4gcGFyYWxsZWxcbmZ1bmN0aW9uIGRlZmF1bHREYXRhU3RyYXRlZ3koXG4gIG9wdHM6IERhdGFTdHJhdGVneUZ1bmN0aW9uQXJnc1xuKTogUmV0dXJuVHlwZTxEYXRhU3RyYXRlZ3lGdW5jdGlvbj4ge1xuICByZXR1cm4gUHJvbWlzZS5hbGwob3B0cy5tYXRjaGVzLm1hcCgobSkgPT4gbS5yZXNvbHZlKCkpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneUltcGwoXG4gIGRhdGFTdHJhdGVneUltcGw6IERhdGFTdHJhdGVneUZ1bmN0aW9uLFxuICB0eXBlOiBcImxvYWRlclwiIHwgXCJhY3Rpb25cIixcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0LFxuICBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uLFxuICByZXF1ZXN0Q29udGV4dD86IHVua25vd25cbik6IFByb21pc2U8SGFuZGxlclJlc3VsdFtdPiB7XG4gIGxldCByb3V0ZUlkc1RvTG9hZCA9IG1hdGNoZXNUb0xvYWQucmVkdWNlKFxuICAgIChhY2MsIG0pID0+IGFjYy5hZGQobS5yb3V0ZS5pZCksXG4gICAgbmV3IFNldDxzdHJpbmc+KClcbiAgKTtcbiAgbGV0IGxvYWRlZE1hdGNoZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBTZW5kIGFsbCBtYXRjaGVzIGhlcmUgdG8gYWxsb3cgZm9yIGEgbWlkZGxld2FyZS10eXBlIGltcGxlbWVudGF0aW9uLlxuICAvLyBoYW5kbGVyIHdpbGwgYmUgYSBuby1vcCBmb3IgdW5uZWVkZWQgcm91dGVzIGFuZCB3ZSBmaWx0ZXIgdGhvc2UgcmVzdWx0c1xuICAvLyBiYWNrIG91dCBiZWxvdy5cbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCBkYXRhU3RyYXRlZ3lJbXBsKHtcbiAgICBtYXRjaGVzOiBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICAgIGxldCBzaG91bGRMb2FkID0gcm91dGVJZHNUb0xvYWQuaGFzKG1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIC8vIGByZXNvbHZlYCBlbmNhcHN1bGF0ZXMgdGhlIHJvdXRlLmxhenksIGV4ZWN1dGluZyB0aGVcbiAgICAgIC8vIGxvYWRlci9hY3Rpb24sIGFuZCBtYXBwaW5nIHJldHVybiB2YWx1ZXMvdGhyb3duIGVycm9ycyB0byBhXG4gICAgICAvLyBIYW5kbGVyUmVzdWx0LiAgVXNlcnMgY2FuIHBhc3MgYSBjYWxsYmFjayB0byB0YWtlIGZpbmUtZ3JhaW5lZCBjb250cm9sXG4gICAgICAvLyBvdmVyIHRoZSBleGVjdXRpb24gb2YgdGhlIGxvYWRlci9hY3Rpb25cbiAgICAgIGxldCByZXNvbHZlOiBEYXRhU3RyYXRlZ3lNYXRjaFtcInJlc29sdmVcIl0gPSAoaGFuZGxlck92ZXJyaWRlKSA9PiB7XG4gICAgICAgIGxvYWRlZE1hdGNoZXMuYWRkKG1hdGNoLnJvdXRlLmlkKTtcbiAgICAgICAgcmV0dXJuIHNob3VsZExvYWRcbiAgICAgICAgICA/IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIGhhbmRsZXJPdmVycmlkZSxcbiAgICAgICAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgcmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgc2hvdWxkTG9hZCxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgIH07XG4gICAgfSksXG4gICAgcmVxdWVzdCxcbiAgICBwYXJhbXM6IG1hdGNoZXNbMF0ucGFyYW1zLFxuICAgIGNvbnRleHQ6IHJlcXVlc3RDb250ZXh0LFxuICB9KTtcblxuICAvLyBUaHJvdyBpZiBhbnkgbG9hZFJvdXRlIGltcGxlbWVudGF0aW9ucyBub3QgY2FsbGVkIHNpbmNlIHRoZXkgYXJlIHdoYXRcbiAgLy8gZW5zdXJlcyBhIHJvdXRlIGlzIGZ1bGx5IGxvYWRlZFxuICBtYXRjaGVzLmZvckVhY2goKG0pID0+XG4gICAgaW52YXJpYW50KFxuICAgICAgbG9hZGVkTWF0Y2hlcy5oYXMobS5yb3V0ZS5pZCksXG4gICAgICBgXFxgbWF0Y2gucmVzb2x2ZSgpXFxgIHdhcyBub3QgY2FsbGVkIGZvciByb3V0ZSBpZCBcIiR7bS5yb3V0ZS5pZH1cIi4gYCArXG4gICAgICAgIFwiWW91IG11c3QgY2FsbCBgbWF0Y2gucmVzb2x2ZSgpYCBvbiBldmVyeSBtYXRjaCBwYXNzZWQgdG8gXCIgK1xuICAgICAgICBcImBkYXRhU3RyYXRlZ3lgIHRvIGVuc3VyZSBhbGwgcm91dGVzIGFyZSBwcm9wZXJseSBsb2FkZWQuXCJcbiAgICApXG4gICk7XG5cbiAgLy8gRmlsdGVyIG91dCBhbnkgbWlkZGxld2FyZS1vbmx5IG1hdGNoZXMgZm9yIHdoaWNoIHdlIGRpZG4ndCBuZWVkIHRvIHJ1biBoYW5kbGVyc1xuICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoKF8sIGkpID0+IHJvdXRlSWRzVG9Mb2FkLmhhcyhtYXRjaGVzW2ldLnJvdXRlLmlkKSk7XG59XG5cbi8vIERlZmF1bHQgbG9naWMgZm9yIGNhbGxpbmcgYSBsb2FkZXIvYWN0aW9uIGlzIHRoZSB1c2VyIGhhcyBubyBzcGVjaWZpZWQgYSBkYXRhU3RyYXRlZ3lcbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbihcbiAgdHlwZTogXCJsb2FkZXJcIiB8IFwiYWN0aW9uXCIsXG4gIHJlcXVlc3Q6IFJlcXVlc3QsXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgaGFuZGxlck92ZXJyaWRlOiBQYXJhbWV0ZXJzPERhdGFTdHJhdGVneU1hdGNoW1wicmVzb2x2ZVwiXT5bMF0sXG4gIHN0YXRpY0NvbnRleHQ/OiB1bmtub3duXG4pOiBQcm9taXNlPEhhbmRsZXJSZXN1bHQ+IHtcbiAgbGV0IHJlc3VsdDogSGFuZGxlclJlc3VsdDtcbiAgbGV0IG9uUmVqZWN0OiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG5cbiAgbGV0IHJ1bkhhbmRsZXIgPSAoXG4gICAgaGFuZGxlcjogQWdub3N0aWNSb3V0ZU9iamVjdFtcImxvYWRlclwiXSB8IEFnbm9zdGljUm91dGVPYmplY3RbXCJhY3Rpb25cIl1cbiAgKTogUHJvbWlzZTxIYW5kbGVyUmVzdWx0PiA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0OiAoKSA9PiB2b2lkO1xuICAgIC8vIFRoaXMgd2lsbCBuZXZlciByZXNvbHZlIHNvIHNhZmUgdG8gdHlwZSBpdCBhcyBQcm9taXNlPEhhbmRsZXJSZXN1bHQ+IHRvXG4gICAgLy8gc2F0aXNmeSB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlPEhhbmRsZXJSZXN1bHQ+KChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICAgIG9uUmVqZWN0ID0gKCkgPT4gcmVqZWN0KCk7XG4gICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcblxuICAgIGxldCBhY3R1YWxIYW5kbGVyID0gKGN0eD86IHVua25vd24pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgWW91IGNhbm5vdCBjYWxsIHRoZSBoYW5kbGVyIGZvciBhIHJvdXRlIHdoaWNoIGRlZmluZXMgYSBib29sZWFuIGAgK1xuICAgICAgICAgICAgICBgXCIke3R5cGV9XCIgW3JvdXRlSWQ6ICR7bWF0Y2gucm91dGUuaWR9XWBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlcihcbiAgICAgICAge1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgICAgY29udGV4dDogc3RhdGljQ29udGV4dCxcbiAgICAgICAgfSxcbiAgICAgICAgLi4uKGN0eCAhPT0gdW5kZWZpbmVkID8gW2N0eF0gOiBbXSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGxldCBoYW5kbGVyUHJvbWlzZTogUHJvbWlzZTxIYW5kbGVyUmVzdWx0PjtcbiAgICBpZiAoaGFuZGxlck92ZXJyaWRlKSB7XG4gICAgICBoYW5kbGVyUHJvbWlzZSA9IGhhbmRsZXJPdmVycmlkZSgoY3R4OiB1bmtub3duKSA9PiBhY3R1YWxIYW5kbGVyKGN0eCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHZhbCA9IGF3YWl0IGFjdHVhbEhhbmRsZXIoKTtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0OiB2YWwgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlclByb21pc2UsIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcblxuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IFt2YWx1ZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaGFuZGxlckVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWUhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9hZCBsYXp5IHJvdXRlIG1vZHVsZSwgdGhlbiBydW4gYW55IHJldHVybmVkIGhhbmRsZXJcbiAgICAgICAgYXdhaXQgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCk7XG5cbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIC8vIEhhbmRsZXIgc3RpbGwgcnVucyBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGF6eSgpIHJvdXRlIGhhcyBubyBsb2FkZXIgdG8gcnVuLiAgU2hvcnQgY2lyY3VpdCBoZXJlIHNvIHdlIGRvbid0XG4gICAgICAgICAgLy8gaGl0IHRoZSBpbnZhcmlhbnQgYmVsb3cgdGhhdCBlcnJvcnMgb24gcmV0dXJuaW5nIHVuZGVmaW5lZC5cbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIHJlc3VsdDogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXN1bHQucmVzdWx0ICE9PSB1bmRlZmluZWQsXG4gICAgICBgWW91IGRlZmluZWQgJHt0eXBlID09PSBcImFjdGlvblwiID8gXCJhbiBhY3Rpb25cIiA6IFwiYSBsb2FkZXJcIn0gZm9yIHJvdXRlIGAgK1xuICAgICAgICBgXCIke21hdGNoLnJvdXRlLmlkfVwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZyb20geW91ciBcXGAke3R5cGV9XFxgIGAgK1xuICAgICAgICBgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmBcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGFscmVhZHkgYmUgY2F0Y2hpbmcgYW5kIGNvbnZlcnRpbmcgbm9ybWFsIGhhbmRsZXIgZXhlY3V0aW9ucyB0b1xuICAgIC8vIEhhbmRsZXJSZXN1bHRzIGFuZCByZXR1cm5pbmcgdGhlbSwgc28gYW55dGhpbmcgdGhhdCB0aHJvd3MgaGVyZSBpcyBhblxuICAgIC8vIHVuZXhwZWN0ZWQgZXJyb3Igd2Ugc3RpbGwgbmVlZCB0byB3cmFwXG4gICAgcmV0dXJuIHsgdHlwZTogUmVzdWx0VHlwZS5lcnJvciwgcmVzdWx0OiBlIH07XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKG9uUmVqZWN0KSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRIYW5kbGVyUmVzdWx0VG9EYXRhUmVzdWx0KFxuICBoYW5kbGVyUmVzdWx0OiBIYW5kbGVyUmVzdWx0XG4pOiBQcm9taXNlPERhdGFSZXN1bHQ+IHtcbiAgbGV0IHsgcmVzdWx0LCB0eXBlLCBzdGF0dXMgfSA9IGhhbmRsZXJSZXN1bHQ7XG5cbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBkYXRhOiBhbnk7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgLy8gQ2hlY2sgYmV0d2VlbiB3b3JkIGJvdW5kYXJpZXMgaW5zdGVhZCBvZiBzdGFydHNXaXRoKCkgZHVlIHRvIHRoZSBsYXN0XG4gICAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLCBlcnJvcjogZSB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBkYXRhKSxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICBkYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgZXJyb3I6IHJlc3VsdCxcbiAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogc3RhdHVzLFxuICAgIH07XG4gIH1cblxuICBpZiAoaXNEZWZlcnJlZERhdGEocmVzdWx0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxuICAgICAgZGVmZXJyZWREYXRhOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgJiYgbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycyksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgZGF0YTogcmVzdWx0LCBzdGF0dXNDb2RlOiBzdGF0dXMgfTtcbn1cblxuLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICByb3V0ZUlkOiBzdHJpbmcsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgYmFzZW5hbWU6IHN0cmluZyxcbiAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IGJvb2xlYW5cbikge1xuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICBpbnZhcmlhbnQoXG4gICAgbG9jYXRpb24sXG4gICAgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiXG4gICk7XG5cbiAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgdHJpbW1lZE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDFcbiAgICApO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8oXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIHRyaW1tZWRNYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICB0cnVlLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgICk7XG4gICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24oXG4gIGxvY2F0aW9uOiBzdHJpbmcsXG4gIGN1cnJlbnRVcmw6IFVSTCxcbiAgYmFzZW5hbWU6IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgcHJvdG9jb2wrb3JpZ2luIGZvciBzYW1lLW9yaWdpbiArIHNhbWUtYmFzZW5hbWUgYWJzb2x1dGUgcmVkaXJlY3RzXG4gICAgbGV0IG5vcm1hbGl6ZWRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIGxldCB1cmwgPSBub3JtYWxpemVkTG9jYXRpb24uc3RhcnRzV2l0aChcIi8vXCIpXG4gICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIG5vcm1hbGl6ZWRMb2NhdGlvbilcbiAgICAgIDogbmV3IFVSTChub3JtYWxpemVkTG9jYXRpb24pO1xuICAgIGxldCBpc1NhbWVCYXNlbmFtZSA9IHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgIT0gbnVsbDtcbiAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG4gICAgfVxuICB9XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cblxuLy8gVXRpbGl0eSBtZXRob2QgZm9yIGNyZWF0aW5nIHRoZSBSZXF1ZXN0IGluc3RhbmNlcyBmb3IgbG9hZGVycy9hY3Rpb25zIGR1cmluZ1xuLy8gY2xpZW50LXNpZGUgbmF2aWdhdGlvbnMgYW5kIGZldGNoZXMuICBEdXJpbmcgU1NSIHdlIHdpbGwgYWx3YXlzIGhhdmUgYVxuLy8gUmVxdWVzdCBpbnN0YW5jZSBmcm9tIHRoZSBzdGF0aWMgaGFuZGxlciAocXVlcnkvcXVlcnlSb3V0ZSlcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICBoaXN0b3J5OiBIaXN0b3J5LFxuICBsb2NhdGlvbjogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uXG4pOiBSZXF1ZXN0IHtcbiAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0cmlwSGFzaEZyb21QYXRoKGxvY2F0aW9uKSkudG9TdHJpbmcoKTtcbiAgbGV0IGluaXQ6IFJlcXVlc3RJbml0ID0geyBzaWduYWwgfTtcblxuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtRW5jVHlwZSB9ID0gc3VibWlzc2lvbjtcbiAgICAvLyBEaWRuJ3QgdGhpbmsgd2UgbmVlZGVkIHRoaXMgYnV0IGl0IHR1cm5zIG91dCB1bmxpa2Ugb3RoZXIgbWV0aG9kcywgcGF0Y2hcbiAgICAvLyB3b24ndCBiZSBwcm9wZXJseSBub3JtYWxpemVkIHRvIHVwcGVyY2FzZSBhbmQgcmVzdWx0cyBpbiBhIDQwNSBlcnJvci5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZFxuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaW5pdC5oZWFkZXJzID0gbmV3IEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBmb3JtRW5jVHlwZSB9KTtcbiAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHN1Ym1pc3Npb24uanNvbik7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi50ZXh0O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiAmJlxuICAgICAgc3VibWlzc2lvbi5mb3JtRGF0YVxuICAgICkge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLmZvcm1EYXRhO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGluaXQpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YTogRm9ybURhdGEpOiBVUkxTZWFyY2hQYXJhbXMge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjb252ZXJ0aW5nLWFuLWVudHJ5LWxpc3QtdG8tYS1saXN0LW9mLW5hbWUtdmFsdWUtcGFpcnNcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2YWx1ZS5uYW1lKTtcbiAgfVxuXG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogRm9ybURhdGEge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBQZW5kaW5nQWN0aW9uUmVzdWx0IHwgdW5kZWZpbmVkLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4sXG4gIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nOiBib29sZWFuXG4pOiB7XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGw7XG4gIHN0YXR1c0NvZGU6IG51bWJlcjtcbiAgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG59IHtcbiAgLy8gRmlsbCBpbiBsb2FkZXJEYXRhL2Vycm9ycyBmcm9tIG91ciBsb2FkZXJzXG4gIGxldCBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl0gPSB7fTtcbiAgbGV0IGVycm9yczogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl0gfCBudWxsID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IGZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+ID0ge307XG4gIGxldCBwZW5kaW5nRXJyb3IgPVxuICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKVxuICAgICAgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nIGFjdGlvbiBlcnJvciwgd2UgcmVwb3J0IGl0IGF0IHRoZSBoaWdoZXN0LXJvdXRlXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcbiAgICAgIC8vIGl0IHdhcyBjb25zdW1lZFxuICAgICAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yID0gcGVuZGluZ0Vycm9yO1xuICAgICAgICBwZW5kaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcblxuICAgICAgaWYgKHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nKSB7XG4gICAgICAgIGVycm9yc1tpZF0gPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBlcnJvclxuICAgICAgICAvLyBib3VuZGFyeSwgZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaC4gIFByZWZlciBoaWdoZXIgZXJyb3IgdmFsdWVzXG4gICAgICAgIC8vIGlmIGxvd2VyIGVycm9ycyBidWJibGUgdG8gdGhlIHNhbWUgYm91bmRhcnlcbiAgICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBPbmNlIHdlIGZpbmQgb3VyIGZpcnN0IChoaWdoZXN0KSBlcnJvciwgd2Ugc2V0IHRoZSBzdGF0dXMgY29kZSBhbmRcbiAgICAgIC8vIHByZXZlbnQgZGVlcGVyIHN0YXR1cyBjb2RlcyBmcm9tIG92ZXJyaWRpbmdcbiAgICAgIGlmICghZm91bmRFcnJvcikge1xuICAgICAgICBmb3VuZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgc3RhdHVzQ29kZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGF0dXNcbiAgICAgICAgICA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zZXQoaWQsIHJlc3VsdC5kZWZlcnJlZERhdGEpO1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YTtcbiAgICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICAgIGlmIChcbiAgICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsICYmXG4gICAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJlxuICAgICAgICAgICFmb3VuZEVycm9yXG4gICAgICAgICkge1xuICAgICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAgIC8vIGxvYWRlcnMgYXJlIHN1Y2Nlc3NmdWwgd2UgdGFrZSB0aGUgZGVlcGVzdCBzdGF0dXMgY29kZS5cbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICYmIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiYgIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2UgZGlkbid0IGNvbnN1bWUgdGhlIHBlbmRpbmcgYWN0aW9uIGVycm9yIChpLmUuLCBhbGwgbG9hZGVyc1xuICAvLyByZXNvbHZlZCksIHRoZW4gY29uc3VtZSBpdCBoZXJlLiAgQWxzbyBjbGVhciBvdXQgYW55IGxvYWRlckRhdGEgZm9yIHRoZVxuICAvLyB0aHJvd2luZyByb3V0ZVxuICBpZiAocGVuZGluZ0Vycm9yICE9PSB1bmRlZmluZWQgJiYgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGVycm9ycyA9IHsgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nRXJyb3IgfTtcbiAgICBsb2FkZXJEYXRhW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9ycyxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcbiAgICBsb2FkZXJIZWFkZXJzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzTG9hZGVyRGF0YShcbiAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBQZW5kaW5nQWN0aW9uUmVzdWx0IHwgdW5kZWZpbmVkLFxuICByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICBmZXRjaGVyUmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn0ge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICBtYXRjaGVzVG9Mb2FkLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICBhY3RpdmVEZWZlcnJlZHMsXG4gICAgZmFsc2UgLy8gVGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWQgY2xpZW50IHNpZGUgc28gd2UgYWx3YXlzIHdhbnQgdG8gYnViYmxlXG4gICk7XG5cbiAgLy8gUHJvY2VzcyByZXN1bHRzIGZyb20gb3VyIHJldmFsaWRhdGluZyBmZXRjaGVyc1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHsga2V5LCBtYXRjaCwgY29udHJvbGxlciB9ID0gcmV2YWxpZGF0aW5nRmV0Y2hlcnNbaW5kZXhdO1xuICAgIGludmFyaWFudChcbiAgICAgIGZldGNoZXJSZXN1bHRzICE9PSB1bmRlZmluZWQgJiYgZmV0Y2hlclJlc3VsdHNbaW5kZXhdICE9PSB1bmRlZmluZWQsXG4gICAgICBcIkRpZCBub3QgZmluZCBjb3JyZXNwb25kaW5nIGZldGNoZXIgcmVzdWx0XCJcbiAgICApO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1tpbmRleF07XG5cbiAgICAvLyBQcm9jZXNzIGZldGNoZXIgbm9uLXJlZGlyZWN0IGVycm9yc1xuICAgIGlmIChjb250cm9sbGVyICYmIGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIGFib3J0ZWQgZmV0Y2hlcnNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2g/LnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBuZXdMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBSb3V0ZURhdGEge1xuICBsZXQgbWVyZ2VkTG9hZGVyRGF0YSA9IHsgLi4ubmV3TG9hZGVyRGF0YSB9O1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKG5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAobmV3TG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8tb3AgLSB0aGlzIGlzIHNvIHdlIGlnbm9yZSBleGlzdGluZyBkYXRhIGlmIHdlIGhhdmUgYSBrZXkgaW4gdGhlXG4gICAgICAgIC8vIGluY29taW5nIG9iamVjdCB3aXRoIGFuIHVuZGVmaW5lZCB2YWx1ZSwgd2hpY2ggaXMgaG93IHdlIHVuc2V0IGEgcHJpb3JcbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpZiB3ZSBlbmNvdW50ZXIgYSBsb2FkZXIgZXJyb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQgJiYgbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICAvLyBQcmVzZXJ2ZSBleGlzdGluZyBrZXlzIG5vdCBpbmNsdWRlZCBpbiBuZXdMb2FkZXJEYXRhIGFuZCB3aGVyZSBhIGxvYWRlclxuICAgICAgLy8gd2Fzbid0IHJlbW92ZWQgYnkgSE1SXG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gRG9uJ3Qga2VlcCBhbnkgbG9hZGVyIGRhdGEgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbkRhdGFGb3JDb21taXQoXG4gIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFBlbmRpbmdBY3Rpb25SZXN1bHQgfCB1bmRlZmluZWRcbikge1xuICBpZiAoIXBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSlcbiAgICA/IHtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHByaW9yIGFjdGlvbkRhdGEgb24gZXJyb3JzXG4gICAgICAgIGFjdGlvbkRhdGE6IHt9LFxuICAgICAgfVxuICAgIDoge1xuICAgICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGEsXG4gICAgICAgIH0sXG4gICAgICB9O1xufVxuXG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByb3V0ZUlkPzogc3RyaW5nXG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWRcbiAgICA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSlcbiAgICA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIChcbiAgICBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHxcbiAgICBtYXRjaGVzWzBdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKToge1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG4gIHJvdXRlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdDtcbn0ge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPVxuICAgIHJvdXRlcy5sZW5ndGggPT09IDFcbiAgICAgID8gcm91dGVzWzBdXG4gICAgICA6IHJvdXRlcy5maW5kKChyKSA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgICAgICAgIGlkOiBgX19zaGltLWVycm9yLXJvdXRlX19gLFxuICAgICAgICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogW1xuICAgICAge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgICByb3V0ZSxcbiAgICAgIH0sXG4gICAgXSxcbiAgICByb3V0ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihcbiAgc3RhdHVzOiBudW1iZXIsXG4gIHtcbiAgICBwYXRobmFtZSxcbiAgICByb3V0ZUlkLFxuICAgIG1ldGhvZCxcbiAgICB0eXBlLFxuICB9OiB7XG4gICAgcGF0aG5hbWU/OiBzdHJpbmc7XG4gICAgcm91dGVJZD86IHN0cmluZztcbiAgICBtZXRob2Q/OiBzdHJpbmc7XG4gICAgdHlwZT86IFwiZGVmZXItYWN0aW9uXCIgfCBcImludmFsaWQtYm9keVwiO1xuICB9ID0ge31cbikge1xuICBsZXQgc3RhdHVzVGV4dCA9IFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIjtcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBAcmVtaXgtcnVuL3JvdXRlciBlcnJvclwiO1xuXG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGAgK1xuICAgICAgICBgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlZmVyLWFjdGlvblwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcImRlZmVyKCkgaXMgbm90IHN1cHBvcnRlZCBpbiBhY3Rpb25zXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIlVuYWJsZSB0byBlbmNvZGUgc3VibWlzc2lvbiBib2R5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGBZb3UgbWFkZSBhICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBgICtcbiAgICAgICAgYHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgIHN0YXR1cyB8fCA1MDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSxcbiAgICB0cnVlXG4gICk7XG59XG5cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QoXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXVxuKTogeyByZXN1bHQ6IFJlZGlyZWN0UmVzdWx0OyBpZHg6IG51bWJlciB9IHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4geyByZXN1bHQsIGlkeDogaSB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoOiBUbykge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoeyAuLi5wYXJzZWRQYXRoLCBoYXNoOiBcIlwiIH0pO1xufVxuXG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGE6IExvY2F0aW9uLCBiOiBMb2NhdGlvbik6IGJvb2xlYW4ge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiB0aGUgaGFzaCBpcyByZW1vdmVkIHRoZSBicm93c2VyIHdpbGwgcmUtcGVyZm9ybSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNIYW5kbGVyUmVzdWx0KHJlc3VsdDogdW5rbm93bik6IHJlc3VsdCBpcyBIYW5kbGVyUmVzdWx0IHtcbiAgcmV0dXJuIChcbiAgICByZXN1bHQgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiZcbiAgICBcInR5cGVcIiBpbiByZXN1bHQgJiZcbiAgICBcInJlc3VsdFwiIGluIHJlc3VsdCAmJlxuICAgIChyZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5kYXRhIHx8IHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0SGFuZGxlclJlc3VsdChyZXN1bHQ6IEhhbmRsZXJSZXN1bHQpIHtcbiAgcmV0dXJuIChcbiAgICBpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3VsdC5yZXN1bHQuc3RhdHVzKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0RlZmVycmVkUmVzdWx0KHJlc3VsdDogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBEZWZlcnJlZFJlc3VsdCB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5kZWZlcnJlZDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQ6IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgRXJyb3JSZXN1bHQge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0PzogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBSZWRpcmVjdFJlc3VsdCB7XG4gIHJldHVybiAocmVzdWx0ICYmIHJlc3VsdC50eXBlKSA9PT0gUmVzdWx0VHlwZS5yZWRpcmVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmZXJyZWREYXRhKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBEZWZlcnJlZERhdGEge1xuICBsZXQgZGVmZXJyZWQ6IERlZmVycmVkRGF0YSA9IHZhbHVlO1xuICByZXR1cm4gKFxuICAgIGRlZmVycmVkICYmXG4gICAgdHlwZW9mIGRlZmVycmVkID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLmRhdGEgPT09IFwib2JqZWN0XCIgJiZcbiAgICB0eXBlb2YgZGVmZXJyZWQuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2YgZGVmZXJyZWQuY2FuY2VsID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2YgZGVmZXJyZWQucmVzb2x2ZURhdGEgPT09IFwiZnVuY3Rpb25cIlxuICApO1xufVxuXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdDogYW55KTogcmVzdWx0IGlzIFJlc3BvbnNlIHtcbiAgaWYgKCFpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIHJldHVybiBzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2Q6IHN0cmluZyk6IG1ldGhvZCBpcyBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZCB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSBhcyBGb3JtTWV0aG9kKTtcbn1cblxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChcbiAgbWV0aG9kOiBzdHJpbmdcbik6IG1ldGhvZCBpcyBNdXRhdGlvbkZvcm1NZXRob2QgfCBWN19NdXRhdGlvbkZvcm1NZXRob2Qge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZC50b0xvd2VyQ2FzZSgpIGFzIE11dGF0aW9uRm9ybU1ldGhvZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gIGN1cnJlbnRNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IChBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbClbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBzaWduYWxzOiAoQWJvcnRTaWduYWwgfCBudWxsKVtdLFxuICBpc0ZldGNoZXI6IGJvb2xlYW4sXG4gIGN1cnJlbnRMb2FkZXJEYXRhPzogUm91dGVEYXRhXG4pIHtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJlc3VsdHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaW5kZXhdO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdO1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBtYXRjaCwgdGhlbiB3ZSBjYW4gaGF2ZSBhIGRlZmVycmVkIHJlc3VsdCB0byBkb1xuICAgIC8vIGFueXRoaW5nIHdpdGguICBUaGlzIGlzIGZvciByZXZhbGlkYXRpbmcgZmV0Y2hlcnMgd2hlcmUgdGhlIHJvdXRlIHdhc1xuICAgIC8vIHJlbW92ZWQgZHVyaW5nIEhNUlxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50TWF0Y2ggPSBjdXJyZW50TWF0Y2hlcy5maW5kKFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgPT09IG1hdGNoIS5yb3V0ZS5pZFxuICAgICk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID1cbiAgICAgIGN1cnJlbnRNYXRjaCAhPSBudWxsICYmXG4gICAgICAhaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpICYmXG4gICAgICAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSAmJiAoaXNGZXRjaGVyIHx8IGlzUmV2YWxpZGF0aW5nTG9hZGVyKSkge1xuICAgICAgLy8gTm90ZTogd2UgZG8gbm90IGhhdmUgdG8gdG91Y2ggYWN0aXZlRGVmZXJyZWRzIGhlcmUgc2luY2Ugd2UgcmFjZSB0aGVtXG4gICAgICAvLyBhZ2FpbnN0IHRoZSBzaWduYWwgaW4gcmVzb2x2ZURlZmVycmVkRGF0YSBhbmQgdGhleSdsbCBnZXQgYWJvcnRlZFxuICAgICAgLy8gdGhlcmUgaWYgbmVlZGVkXG4gICAgICBsZXQgc2lnbmFsID0gc2lnbmFsc1tpbmRleF07XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgXCJFeHBlY3RlZCBhbiBBYm9ydFNpZ25hbCBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXIgZGVmZXJyZWQgcmVzdWx0XCJcbiAgICAgICk7XG4gICAgICBhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCBpc0ZldGNoZXIpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQgfHwgcmVzdWx0c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKFxuICByZXN1bHQ6IERlZmVycmVkUmVzdWx0LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICB1bndyYXAgPSBmYWxzZVxuKTogUHJvbWlzZTxTdWNjZXNzUmVzdWx0IHwgRXJyb3JSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHVud3JhcCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEudW53cmFwcGVkRGF0YSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpLmdldEFsbChcImluZGV4XCIpLnNvbWUoKHYpID0+IHYgPT09IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBsb2NhdGlvbjogTG9jYXRpb24gfCBzdHJpbmdcbikge1xuICBsZXQgc2VhcmNoID1cbiAgICB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKFxuICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJlxuICAgIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2ggfHwgXCJcIilcbiAgKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBsZWFmIGluZGV4IHJvdXRlIHdoZW4gaW5kZXggaXMgcHJlc2VudFxuICAgIHJldHVybiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIGdyYWIgdGhlIGRlZXBlc3QgXCJwYXRoIGNvbnRyaWJ1dGluZ1wiIG1hdGNoIChpZ25vcmluZyBpbmRleCBhbmRcbiAgLy8gcGF0aGxlc3MgbGF5b3V0IHJvdXRlcylcbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIHJldHVybiBwYXRoTWF0Y2hlc1twYXRoTWF0Y2hlcy5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKFxuICBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uXG4pOiBTdWJtaXNzaW9uIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIHRleHQsIGZvcm1EYXRhLCBqc29uIH0gPVxuICAgIG5hdmlnYXRpb247XG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKFxuICBsb2NhdGlvbjogTG9jYXRpb24sXG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uXG4pOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKFxuICBsb2NhdGlvbjogTG9jYXRpb24sXG4gIHN1Ym1pc3Npb246IFN1Ym1pc3Npb25cbik6IE5hdmlnYXRpb25TdGF0ZXNbXCJTdWJtaXR0aW5nXCJdIHtcbiAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJTdWJtaXR0aW5nXCJdID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gIH07XG4gIHJldHVybiBuYXZpZ2F0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb24sXG4gIGRhdGE/OiBGZXRjaGVyW1wiZGF0YVwiXVxuKTogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0ge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhLFxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhLFxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ0ZldGNoZXIoXG4gIHN1Ym1pc3Npb246IFN1Ym1pc3Npb24sXG4gIGV4aXN0aW5nRmV0Y2hlcj86IEZldGNoZXJcbik6IEZldGNoZXJTdGF0ZXNbXCJTdWJtaXR0aW5nXCJdIHtcbiAgbGV0IGZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJTdWJtaXR0aW5nXCJdID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB1bmRlZmluZWQsXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuXG5mdW5jdGlvbiBnZXREb25lRmV0Y2hlcihkYXRhOiBGZXRjaGVyW1wiZGF0YVwiXSk6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdIHtcbiAgbGV0IGZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgdGV4dDogdW5kZWZpbmVkLFxuICAgIGRhdGEsXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKFxuICBfd2luZG93OiBXaW5kb3csXG4gIHRyYW5zaXRpb25zOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj5cbikge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVlcbiAgICApO1xuICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbiB8fCB7fSkpIHtcbiAgICAgICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zLnNldChrLCBuZXcgU2V0KHYgfHwgW10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIG5vLW9wLCB1c2UgZGVmYXVsdCBlbXB0eSBvYmplY3RcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKFxuICBfd2luZG93OiBXaW5kb3csXG4gIHRyYW5zaXRpb25zOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj5cbikge1xuICBpZiAodHJhbnNpdGlvbnMuc2l6ZSA+IDApIHtcbiAgICBsZXQganNvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlICgke2Vycm9yfSkuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8jZW5kcmVnaW9uXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDWSxJQUFBQSxNQUFNLDBCQUFOQSxNQUFNO0VBQU5BLE1BQU07RUFBTkEsTUFBTTtFQUFOQSxNQUFNO0VBQUEsT0FBTkEsTUFBTTtBQUFBOztBQXdCbEI7QUFDQTtBQUNBOztBQWtCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0ZBLE1BQU1DLGlCQUFpQixHQUFHLFVBQVU7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsbUJBQW1CQSxD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