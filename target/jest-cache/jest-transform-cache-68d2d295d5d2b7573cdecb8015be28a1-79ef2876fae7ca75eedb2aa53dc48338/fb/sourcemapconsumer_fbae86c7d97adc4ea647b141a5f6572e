ff5c0c6fbc3d3d48fa51819f9a49abfd
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;
function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }
  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__originalMappings;
  }
});
SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;
  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var sourceRoot = this.sourceRoot;
  var boundCallback = aCallback.bind(context);
  var names = this._names;
  var sources = this._sources;
  var sourceMapURL = this._sourceMapURL;
  for (var i = 0, n = mappings.length; i < n; i++) {
    var mapping = mappings[i];
    var source = mapping.source === null ? null : sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
    boundCallback({
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : names.at(mapping.name)
    });
  }
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }
  var mappings = [];
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }
  return mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }
  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }
  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }
  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }
  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }
  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  });

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];
  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;
    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;
      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }
      destOriginalMappings.push(destMapping);
    }
    destGeneratedMappings.push(destMapping);
  }
  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */

const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
  let l = array.length;
  let n = array.length - start;
  if (n <= 1) {
    return;
  } else if (n == 2) {
    let a = array[start];
    let b = array[start + 1];
    if (compareGenerated(a, b) > 0) {
      array[start] = b;
      array[start + 1] = a;
    }
  } else if (n < 20) {
    for (let i = start; i < l; i++) {
      for (let j = i; j > start; j--) {
        let a = array[j - 1];
        let b = array[j];
        if (compareGenerated(a, b) <= 0) {
          break;
        }
        array[j - 1] = b;
        array[j] = a;
      }
    }
  } else {
    quickSort(array, compareGenerated, start);
  }
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;
  let subarrayStart = 0;
  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
      sortGenerated(generatedMappings, subarrayStart);
      subarrayStart = generatedMappings.length;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine;
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);
      segment = [];
      while (index < end) {
        base64VLQ.decode(aStr, index, temp);
        value = temp.value;
        index = temp.rest;
        segment.push(value);
      }
      if (segment.length === 2) {
        throw new Error('Found a source, but no line and column');
      }
      if (segment.length === 3) {
        throw new Error('Found a source and line, but no column');
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;
      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;
        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }
      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        let currentSource = mapping.source;
        while (originalMappings.length <= currentSource) {
          originalMappings.push(null);
        }
        if (originalMappings[currentSource] === null) {
          originalMappings[currentSource] = [];
        }
        originalMappings[currentSource].push(mapping);
      }
    }
  }
  sortGenerated(generatedMappings, subarrayStart);
  this.__generatedMappings = generatedMappings;
  for (var i = 0; i < originalMappings.length; i++) {
    if (originalMappings[i] != null) {
      quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
    }
  }
  this.__originalMappings = [].concat(...originalMappings);
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }
  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];
      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };
  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._generatedMappings[index];
    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name = util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }
  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }
  var url;
  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }
    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }
  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }
  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');
    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }
    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];
  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }
  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);
    if (content || content === '') {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }
  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];
      var source = section.consumer._sources.at(mapping.source);
      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      this._sources.add(source);
      source = this._sources.indexOf(source);
      var name = null;
      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
      }

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };
      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }
  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImJpbmFyeVNlYXJjaCIsIkFycmF5U2V0IiwiYmFzZTY0VkxRIiwicXVpY2tTb3J0IiwiU291cmNlTWFwQ29uc3VtZXIiLCJhU291cmNlTWFwIiwiYVNvdXJjZU1hcFVSTCIsInNvdXJjZU1hcCIsInBhcnNlU291cmNlTWFwSW5wdXQiLCJzZWN0aW9ucyIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXIiLCJmcm9tU291cmNlTWFwIiwicHJvdG90eXBlIiwiX3ZlcnNpb24iLCJfX2dlbmVyYXRlZE1hcHBpbmdzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3BhcnNlTWFwcGluZ3MiLCJfbWFwcGluZ3MiLCJzb3VyY2VSb290IiwiX19vcmlnaW5hbE1hcHBpbmdzIiwiX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yIiwiYVN0ciIsImluZGV4IiwiYyIsImNoYXJBdCIsIlNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MiLCJhU291cmNlUm9vdCIsIkVycm9yIiwiR0VORVJBVEVEX09SREVSIiwiT1JJR0lOQUxfT1JERVIiLCJHUkVBVEVTVF9MT1dFUl9CT1VORCIsIkxFQVNUX1VQUEVSX0JPVU5EIiwiZWFjaE1hcHBpbmciLCJTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyIsImFDYWxsYmFjayIsImFDb250ZXh0IiwiYU9yZGVyIiwiY29udGV4dCIsIm9yZGVyIiwibWFwcGluZ3MiLCJfZ2VuZXJhdGVkTWFwcGluZ3MiLCJfb3JpZ2luYWxNYXBwaW5ncyIsImJvdW5kQ2FsbGJhY2siLCJiaW5kIiwibmFtZXMiLCJfbmFtZXMiLCJzb3VyY2VzIiwiX3NvdXJjZXMiLCJzb3VyY2VNYXBVUkwiLCJfc291cmNlTWFwVVJMIiwiaSIsIm4iLCJsZW5ndGgiLCJtYXBwaW5nIiwic291cmNlIiwiYXQiLCJjb21wdXRlU291cmNlVVJMIiwiZ2VuZXJhdGVkTGluZSIsImdlbmVyYXRlZENvbHVtbiIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwibmFtZSIsImFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsImFBcmdzIiwibGluZSIsImdldEFyZyIsIm5lZWRsZSIsIl9maW5kU291cmNlSW5kZXgiLCJfZmluZE1hcHBpbmciLCJjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyIsImNvbHVtbiIsInVuZGVmaW5lZCIsInB1c2giLCJsYXN0Q29sdW1uIiwiZXhwb3J0cyIsInZlcnNpb24iLCJzb3VyY2VzQ29udGVudCIsImZpbGUiLCJub3JtYWxpemUiLCJtYXAiLCJTdHJpbmciLCJpc0Fic29sdXRlIiwicmVsYXRpdmUiLCJmcm9tQXJyYXkiLCJfYWJzb2x1dGVTb3VyY2VzIiwidG9BcnJheSIsInMiLCJjcmVhdGUiLCJjb25zdW1lciIsImFTb3VyY2UiLCJyZWxhdGl2ZVNvdXJjZSIsImhhcyIsImluZGV4T2YiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiX3NvdXJjZVJvb3QiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIl9maWxlIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJzbGljZSIsImRlc3RHZW5lcmF0ZWRNYXBwaW5ncyIsImRlc3RPcmlnaW5hbE1hcHBpbmdzIiwic3JjTWFwcGluZyIsImRlc3RNYXBwaW5nIiwiTWFwcGluZyIsImNvbXBhcmVHZW5lcmF0ZWQiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZSIsInNvcnRHZW5lcmF0ZWQiLCJhcnJheSIsInN0YXJ0IiwibCIsImEiLCJiIiwiaiIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNPcmlnaW5hbExpbmUiLCJwcmV2aW91c09yaWdpbmFsQ29sdW1uIiwicHJldmlvdXNTb3VyY2UiLCJwcmV2aW91c05hbWUiLCJjYWNoZWRTZWdtZW50cyIsInRlbXAiLCJvcmlnaW5hbE1hcHBpbmdzIiwic3RyIiwic2VnbWVudCIsImVuZCIsInZhbHVlIiwic3ViYXJyYXlTdGFydCIsImRlY29kZSIsInJlc3QiLCJjdXJyZW50U291cmNlIiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZSIsImNvbmNhdCIsIlNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nIiwiYU5lZWRsZSIsImFNYXBwaW5ncyIsImFMaW5lTmFtZSIsImFDb2x1bW5OYW1lIiwiYUNvbXBhcmF0b3IiLCJhQmlhcyIsIlR5cGVFcnJvciIsInNlYXJjaCIsImNvbXB1dGVDb2x1bW5TcGFucyIsIlNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucyIsIm5leHRNYXBwaW5nIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsIkluZmluaXR5Iiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCIsImhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwiQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcyIsInNpemUiLCJzb21lIiwic2MiLCJzb3VyY2VDb250ZW50Rm9yIiwiU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvciIsIm51bGxPbk1pc3NpbmciLCJ1cmwiLCJ1cmxQYXJzZSIsImZpbGVVcmlBYnNQYXRoIiwicmVwbGFjZSIsInNjaGVtZSIsInBhdGgiLCJnZW5lcmF0ZWRQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwibGFzdE9mZnNldCIsIl9zZWN0aW9ucyIsIm9mZnNldCIsIm9mZnNldExpbmUiLCJvZmZzZXRDb2x1bW4iLCJnZW5lcmF0ZWRPZmZzZXQiLCJjb25zdHJ1Y3RvciIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yIiwic2VjdGlvbkluZGV4Iiwic2VjdGlvbiIsImNtcCIsImJpYXMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJldmVyeSIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yIiwiY29udGVudCIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvciIsImdlbmVyYXRlZFBvc2l0aW9uIiwicmV0IiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MiLCJzZWN0aW9uTWFwcGluZ3MiLCJhZGQiLCJhZGp1c3RlZE1hcHBpbmciXSwic291cmNlcyI6WyJzb3VyY2UtbWFwLWNvbnN1bWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTClcbiAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG5cblNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICB2YXIgYm91bmRDYWxsYmFjayA9IGFDYWxsYmFjay5iaW5kKGNvbnRleHQpO1xuICAgIHZhciBuYW1lcyA9IHRoaXMuX25hbWVzO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICB2YXIgc291cmNlTWFwVVJMID0gdGhpcy5fc291cmNlTWFwVVJMO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCBzb3VyY2VNYXBVUkwpO1xuICAgICAgYm91bmRDYWxsYmFjayh7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgobmVlZGxlLnNvdXJjZSk7XG4gICAgaWYgKG5lZWRsZS5zb3VyY2UgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICBzb3VyY2VSb290ID0gdXRpbC5ub3JtYWxpemUoc291cmNlUm9vdCk7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICB9KTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGluZGV4IG9mIGEgc291cmNlLiAgUmV0dXJucyAtMSBpZiBub3RcbiAqIGZvdW5kLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZFNvdXJjZUluZGV4ID0gZnVuY3Rpb24oYVNvdXJjZSkge1xuICB2YXIgcmVsYXRpdmVTb3VyY2UgPSBhU291cmNlO1xuICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gIH1cblxuICBpZiAodGhpcy5fc291cmNlcy5oYXMocmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7XG4gIH1cblxuICAvLyBNYXliZSBhU291cmNlIGlzIGFuIGFic29sdXRlIFVSTCBhcyByZXR1cm5lZCBieSB8c291cmNlc3wuICBJblxuICAvLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcy5fYWJzb2x1dGVTb3VyY2VzW2ldID09IGFTb3VyY2UpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAqIEBwYXJhbSBTdHJpbmcgYVNvdXJjZU1hcFVSTFxuICogICAgICAgIFRoZSBVUkwgYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgY2FuIGJlIGZvdW5kIChvcHRpb25hbClcbiAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcbiAgICBzbWMuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7XG4gICAgc21jLl9hYnNvbHV0ZVNvdXJjZXMgPSBzbWMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzbWMuc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gICAgfSk7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMuc2xpY2UoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblxuY29uc3QgY29tcGFyZUdlbmVyYXRlZCA9IHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWROb0xpbmU7XG5mdW5jdGlvbiBzb3J0R2VuZXJhdGVkKGFycmF5LCBzdGFydCkge1xuICBsZXQgbCA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IG4gPSBhcnJheS5sZW5ndGggLSBzdGFydDtcbiAgaWYgKG4gPD0gMSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChuID09IDIpIHtcbiAgICBsZXQgYSA9IGFycmF5W3N0YXJ0XTtcbiAgICBsZXQgYiA9IGFycmF5W3N0YXJ0ICsgMV07XG4gICAgaWYgKGNvbXBhcmVHZW5lcmF0ZWQoYSwgYikgPiAwKSB7XG4gICAgICBhcnJheVtzdGFydF0gPSBiO1xuICAgICAgYXJyYXlbc3RhcnQgKyAxXSA9IGE7XG4gICAgfVxuICB9IGVsc2UgaWYgKG4gPCAyMCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGw7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydDsgai0tKSB7XG4gICAgICAgIGxldCBhID0gYXJyYXlbaiAtIDFdO1xuICAgICAgICBsZXQgYiA9IGFycmF5W2pdO1xuICAgICAgICBpZiAoY29tcGFyZUdlbmVyYXRlZChhLCBiKSA8PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbaiAtIDFdID0gYjtcbiAgICAgICAgYXJyYXlbal0gPSBhO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoYXJyYXksIGNvbXBhcmVHZW5lcmF0ZWQsIHN0YXJ0KTtcbiAgfVxufVxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIGxldCBzdWJhcnJheVN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgICAgICBzb3J0R2VuZXJhdGVkKGdlbmVyYXRlZE1hcHBpbmdzLCBzdWJhcnJheVN0YXJ0KTtcbiAgICAgICAgc3ViYXJyYXlTdGFydCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRTb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICB3aGlsZSAob3JpZ2luYWxNYXBwaW5ncy5sZW5ndGggPD0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3JpZ2luYWxNYXBwaW5nc1tjdXJyZW50U291cmNlXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5nc1tjdXJyZW50U291cmNlXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzW2N1cnJlbnRTb3VyY2VdLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb3J0R2VuZXJhdGVkKGdlbmVyYXRlZE1hcHBpbmdzLCBzdWJhcnJheVN0YXJ0KTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWxNYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9yaWdpbmFsTWFwcGluZ3NbaV0gIT0gbnVsbCkge1xuICAgICAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5nc1tpXSwgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9uc05vU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXS5jb25jYXQoLi4ub3JpZ2luYWxNYXBwaW5ncyk7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQgfHwgY29udGVudCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0g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LE1BQU0sRUFBRSxJQUFJLENBQUNMLGFBQWEsQ0FBQztNQUN2RixJQUFJLENBQUNGLFFBQVEsQ0FBQzRJLEdBQUcsQ0FBQ3JJLE1BQU0sQ0FBQztNQUN6QkEsTUFBTSxHQUFHLElBQUksQ0FBQ1AsUUFBUSxDQUFDOEMsT0FBTyxDQUFDdkMsTUFBTSxDQUFDO01BRXRDLElBQUlPLElBQUksR0FBRyxJQUFJO01BQ2YsSUFBSVIsT0FBTyxDQUFDUSxJQUFJLEVBQUU7UUFDaEJBLElBQUksR0FBR2tILE9BQU8sQ0FBQ3RGLFFBQVEsQ0FBQzVDLE1BQU0sQ0FBQ1UsRUFBRSxDQUFDRixPQUFPLENBQUNRLElBQUksQ0FBQztRQUMvQyxJQUFJLENBQUNoQixNQUFNLENBQUM4SSxHQUFHLENBQUM5SCxJQUFJLENBQUM7UUFDckJBLElBQUksR0FBRyxJQUFJLENBQUNoQixNQUFNLENBQUNnRCxPQUFPLENBQUNoQyxJQUFJLENBQUM7TUFDbEM7O01BRUE7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFJK0gsZUFBZSxHQUFHO1FBQ3BCdEksTUFBTSxFQUFFQSxNQUFNO1FBQ2RHLGFBQWEsRUFBRUosT0FBTyxDQUFDSSxhQUFhLElBQ2pDc0gsT0FBTyxDQUFDSixlQUFlLENBQUNsSCxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQzdDQyxlQUFlLEVBQUVMLE9BQU8sQ0FBQ0ssZUFBZSxJQUNyQ3FILE9BQU8sQ0FBQ0osZUFBZSxDQUFDbEgsYUFBYSxLQUFLSixPQUFPLENBQUNJLGFBQWEsR0FDOURzSCxPQUFPLENBQUNKLGVBQWUsQ0FBQ2pILGVBQWUsR0FBRyxDQUFDLEdBQzNDLENBQUMsQ0FBQztRQUNOQyxZQUFZLEVBQUVOLE9BQU8sQ0FBQ00sWUFBWTtRQUNsQ0MsY0FBYyxFQUFFUCxPQUFPLENBQUNPLGNBQWM7UUFDdENDLElBQUksRUFBRUE7TUFDUixDQUFDO01BRUQsSUFBSSxDQUFDcEQsbUJBQW1CLENBQUNnRSxJQUFJLENBQUNtSCxlQUFlLENBQUM7TUFDOUMsSUFBSSxPQUFPQSxlQUFlLENBQUNqSSxZQUFZLEtBQUssUUFBUSxFQUFFO1FBQ3BELElBQUksQ0FBQ3pDLGtCQUFrQixDQUFDdUQsSUFBSSxDQUFDbUgsZUFBZSxDQUFDO01BQy9DO0lBQ0Y7RUFDRjtFQUVBL0wsU0FBUyxDQUFDLElBQUksQ0FBQ1ksbUJBQW1CLEVBQUVqQixJQUFJLENBQUM2SixtQ0FBbUMsQ0FBQztFQUM3RXhKLFNBQVMsQ0FBQyxJQUFJLENBQUNxQixrQkFBa0IsRUFBRTFCLElBQUksQ0FBQzhFLDBCQUEwQixDQUFDO0FBQ3JFLENBQUM7QUFFSEssT0FBTyxDQUFDdkUsd0JBQXdCLEdBQUdBLHdCQUF3QiIsImlnbm9yZUxpc3QiOltdfQ==