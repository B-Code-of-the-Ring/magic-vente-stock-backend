ec6406c0abcece1667739fac2eb6deaa
/**
 * @license React
 * react-dom-test-utils.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var React = require('react');
    var ReactDOM = require('react-dom');
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.

    function warn(format) {
      {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          printWarning('warn', format, args);
        }
      }
    }
    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning('error', format, args);
        }
      }
    }
    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        } // eslint-disable-next-line react-internal/safe-string-coercion

        var argsWithFormat = args.map(function (item) {
          return String(item);
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    /**
     * `ReactInstanceMap` maintains a mapping from a public facing stateful
     * instance (key) and the internal representation (value). This allows public
     * methods to accept the user facing instance as an argument and map them back
     * to internal methods.
     *
     * Note that this module is currently shared and assumed to be stateless.
     * If this becomes an actual Map, that will break.
     */
    function get(key) {
      return key._reactInternals;
    }
    var FunctionComponent = 0;
    var ClassComponent = 1;
    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.

    var HostComponent = 5;
    var HostText = 6;

    // Don't change these two values. They're used by React Dev Tools.
    var NoFlags = /*                      */
    0;
    var Placement = /*                    */
    2;
    var Hydrating = /*                    */
    4096;
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    function getNearestMountedFiber(fiber) {
      var node = fiber;
      var nearestMounted = fiber;
      if (!fiber.alternate) {
        // If there is no alternate, this might be a new tree that isn't inserted
        // yet. If it is, then it will have a pending insertion effect on it.
        var nextNode = node;
        do {
          node = nextNode;
          if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
            // This is an insertion or in-progress hydration. The nearest possible
            // mounted fiber is the parent but we need to continue to figure out
            // if that one is still mounted.
            nearestMounted = node.return;
          }
          nextNode = node.return;
        } while (nextNode);
      } else {
        while (node.return) {
          node = node.return;
        }
      }
      if (node.tag === HostRoot) {
        // TODO: Check if this was a nested HostRoot when used with
        // renderContainerIntoSubtree.
        return nearestMounted;
      } // If we didn't hit the root, that means that we're in an disconnected tree
      // that has been unmounted.

      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber) {
        throw new Error('Unable to find node on an unmounted component.');
      }
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        // If there is no alternate, then we only need to check if it is mounted.
        var nearestMounted = getNearestMountedFiber(fiber);
        if (nearestMounted === null) {
          throw new Error('Unable to find node on an unmounted component.');
        }
        if (nearestMounted !== fiber) {
          return null;
        }
        return fiber;
      } // If we have two possible branches, we'll walk backwards up to the root
      // to see what path the root points to. On the way we may hit one of the
      // special cases and we'll deal with them.

      var a = fiber;
      var b = alternate;
      while (true) {
        var parentA = a.return;
        if (parentA === null) {
          // We're at the root.
          break;
        }
        var parentB = parentA.alternate;
        if (parentB === null) {
          // There is no alternate. This is an unusual case. Currently, it only
          // happens when a Suspense component is hidden. An extra fragment fiber
          // is inserted in between the Suspense fiber and its children. Skip
          // over this extra fragment fiber and proceed to the next parent.
          var nextParent = parentA.return;
          if (nextParent !== null) {
            a = b = nextParent;
            continue;
          } // If there's no parent, we're at the root.

          break;
        } // If both copies of the parent fiber point to the same child, we can
        // assume that the child is current. This happens when we bailout on low
        // priority: the bailed out fiber's child reuses the current child.

        if (parentA.child === parentB.child) {
          var child = parentA.child;
          while (child) {
            if (child === a) {
              // We've determined that A is the current branch.
              assertIsMounted(parentA);
              return fiber;
            }
            if (child === b) {
              // We've determined that B is the current branch.
              assertIsMounted(parentA);
              return alternate;
            }
            child = child.sibling;
          } // We should never have an alternate for any mounting node. So the only
          // way this could possibly happen is if this was unmounted, if at all.

          throw new Error('Unable to find node on an unmounted component.');
        }
        if (a.return !== b.return) {
          // The return pointer of A and the return pointer of B point to different
          // fibers. We assume that return pointers never criss-cross, so A must
          // belong to the child set of A.return, and B must belong to the child
          // set of B.return.
          a = parentA;
          b = parentB;
        } else {
          // The return pointers point to the same fiber. We'll have to use the
          // default, slow path: scan the child sets of each parent alternate to see
          // which child belongs to which set.
          //
          // Search parent A's child set
          var didFindChild = false;
          var _child = parentA.child;
          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            // Search parent B's child set
            _child = parentB.child;
            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
            }
          }
        }
        if (a.alternate !== b) {
          throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
        }
      } // If the root is not a host container, we're in a disconnected tree. I.e.
      // unmounted.

      if (a.tag !== HostRoot) {
        throw new Error('Unable to find node on an unmounted component.');
      }
      if (a.stateNode.current === a) {
        // We've determined that A is the current branch.
        return fiber;
      } // Otherwise B has to be current branch.

      return alternate;
    }
    var assign = Object.assign;

    /**
     * `charCode` represents the actual "character code" and is safe to use with
     * `String.fromCharCode`. As such, only keys that correspond to printable
     * characters produce a valid `charCode`, the only exception to this is Enter.
     * The Tab-key is considered non-printable and does not have a `charCode`,
     * presumably because it does not produce a tab-character in browsers.
     *
     * @param {object} nativeEvent Native browser event.
     * @return {number} Normalized `charCode` property.
     */
    function getEventCharCode(nativeEvent) {
      var charCode;
      var keyCode = nativeEvent.keyCode;
      if ('charCode' in nativeEvent) {
        charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.

        if (charCode === 0 && keyCode === 13) {
          charCode = 13;
        }
      } else {
        // IE8 does not implement `charCode`, but `keyCode` has the correct value.
        charCode = keyCode;
      } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
      // report Enter as charCode 10 when ctrl is pressed.

      if (charCode === 10) {
        charCode = 13;
      } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
      // Must not discard the (non-)printable Enter-key.

      if (charCode >= 32 || charCode === 13) {
        return charCode;
      }
      return 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    } // This is intentionally a factory so that we have different returned constructors.
    // If we had a single constructor, it would be megamorphic and engines would deopt.

    function createSyntheticEvent(Interface) {
      /**
       * Synthetic events are dispatched by event plugins, typically in response to a
       * top-level event delegation handler.
       *
       * These systems should generally use pooling to reduce the frequency of garbage
       * collection. The system should check `isPersistent` to determine whether the
       * event should be released into the pool after being dispatched. Users that
       * need a persisted event should invoke `persist`.
       *
       * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
       * normalizing browser quirks. Subclasses do not necessarily have to implement a
       * DOM interface; custom application-specific events can also subclass this.
       */
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var _propName in Interface) {
          if (!Interface.hasOwnProperty(_propName)) {
            continue;
          }
          var normalize = Interface[_propName];
          if (normalize) {
            this[_propName] = normalize(nativeEvent);
          } else {
            this[_propName] = nativeEvent[_propName];
          }
        }
        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
        if (defaultPrevented) {
          this.isDefaultPrevented = functionThatReturnsTrue;
        } else {
          this.isDefaultPrevented = functionThatReturnsFalse;
        }
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          if (!event) {
            return;
          }
          if (event.preventDefault) {
            event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
          } else if (typeof event.returnValue !== 'unknown') {
            event.returnValue = false;
          }
          this.isDefaultPrevented = functionThatReturnsTrue;
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          if (!event) {
            return;
          }
          if (event.stopPropagation) {
            event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
          } else if (typeof event.cancelBubble !== 'unknown') {
            // The ChangeEventPlugin registers a "propertychange" event for
            // IE. This event does not support bubbling or cancelling, and
            // any references to cancelBubble throw "Member not found".  A
            // typeof check of "unknown" circumvents this issue (and is also
            // IE specific).
            event.cancelBubble = true;
          }
          this.isPropagationStopped = functionThatReturnsTrue;
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function () {// Modern event system doesn't use pooling.
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    /**
     * @interface Event
     * @see http://www.w3.org/TR/DOM-Level-3-Events/
     */

    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    };
    var SyntheticEvent = createSyntheticEvent(EventInterface);
    var UIEventInterface = assign({}, EventInterface, {
      view: 0,
      detail: 0
    });
    var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
    var lastMovementX;
    var lastMovementY;
    var lastMouseEvent;
    function updateMouseMovementPolyfillState(event) {
      if (event !== lastMouseEvent) {
        if (lastMouseEvent && event.type === 'mousemove') {
          lastMovementX = event.screenX - lastMouseEvent.screenX;
          lastMovementY = event.screenY - lastMouseEvent.screenY;
        } else {
          lastMovementX = 0;
          lastMovementY = 0;
        }
        lastMouseEvent = event;
      }
    }
    /**
     * @interface MouseEvent
     * @see http://www.w3.org/TR/DOM-Level-3-Events/
     */

    var MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function (event) {
        if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
        return event.relatedTarget;
      },
      movementX: function (event) {
        if ('movementX' in event) {
          return event.movementX;
        }
        updateMouseMovementPolyfillState(event);
        return lastMovementX;
      },
      movementY: function (event) {
        if ('movementY' in event) {
          return event.movementY;
        } // Don't need to call updateMouseMovementPolyfillState() here
        // because it's guaranteed to have already run when movementX
        // was copied.

        return lastMovementY;
      }
    });
    var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
    /**
     * @interface DragEvent
     * @see http://www.w3.org/TR/DOM-Level-3-Events/
     */

    var DragEventInterface = assign({}, MouseEventInterface, {
      dataTransfer: 0
    });
    var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
    /**
     * @interface FocusEvent
     * @see http://www.w3.org/TR/DOM-Level-3-Events/
     */

    var FocusEventInterface = assign({}, UIEventInterface, {
      relatedTarget: 0
    });
    var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
    /**
     * @interface Event
     * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
     */

    var AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    });
    var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
    /**
     * @interface Event
     * @see http://www.w3.org/TR/clipboard-apis/
     */

    var ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function (event) {
        return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
      }
    });
    var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
    /**
     * @interface Event
     * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
     */

    var CompositionEventInterface = assign({}, EventInterface, {
      data: 0
    });
    var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
    /**
     * Normalization of deprecated HTML5 `key` values
     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
     */

    var normalizeKey = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified'
    };
    /**
     * Translation from legacy `keyCode` to HTML5 `key`
     * Only special keys supported, all others depend on keyboard layout or browser
     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
     */

    var translateToKey = {
      '8': 'Backspace',
      '9': 'Tab',
      '12': 'Clear',
      '13': 'Enter',
      '16': 'Shift',
      '17': 'Control',
      '18': 'Alt',
      '19': 'Pause',
      '20': 'CapsLock',
      '27': 'Escape',
      '32': ' ',
      '33': 'PageUp',
      '34': 'PageDown',
      '35': 'End',
      '36': 'Home',
      '37': 'ArrowLeft',
      '38': 'ArrowUp',
      '39': 'ArrowRight',
      '40': 'ArrowDown',
      '45': 'Insert',
      '46': 'Delete',
      '112': 'F1',
      '113': 'F2',
      '114': 'F3',
      '115': 'F4',
      '116': 'F5',
      '117': 'F6',
      '118': 'F7',
      '119': 'F8',
      '120': 'F9',
      '121': 'F10',
      '122': 'F11',
      '123': 'F12',
      '144': 'NumLock',
      '145': 'ScrollLock',
      '224': 'Meta'
    };
    /**
     * @param {object} nativeEvent Native browser event.
     * @return {string} Normalized `key` property.
     */

    function getEventKey(nativeEvent) {
      if (nativeEvent.key) {
        // Normalize inconsistent values reported by browsers due to
        // implementations of a working draft specification.
        // FireFox implements `key` but returns `MozPrintableKey` for all
        // printable characters (normalized to `Unidentified`), ignore it.
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if (key !== 'Unidentified') {
          return key;
        }
      } // Browser does not implement `key`, polyfill as much of it as we can.

      if (nativeEvent.type === 'keypress') {
        var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
        // thus be captured by `keypress`, no other non-printable key should.

        return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
      }
      if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
        // While user keyboard layout determines the actual meaning of each
        // `keyCode` value, almost all function keys have a universal value.
        return translateToKey[nativeEvent.keyCode] || 'Unidentified';
      }
      return '';
    }
    /**
     * Translation from modifier key to the associated property in the event.
     * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
     */

    var modifierKeyToProp = {
      Alt: 'altKey',
      Control: 'ctrlKey',
      Meta: 'metaKey',
      Shift: 'shiftKey'
    }; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
    // getModifierState. If getModifierState is not supported, we map it to a set of
    // modifier keys exposed by the event. In this case, Lock-keys are not supported.

    function modifierStateGetter(keyArg) {
      var syntheticEvent = this;
      var nativeEvent = syntheticEvent.nativeEvent;
      if (nativeEvent.getModifierState) {
        return nativeEvent.getModifierState(keyArg);
      }
      var keyProp = modifierKeyToProp[keyArg];
      return keyProp ? !!nativeEvent[keyProp] : false;
    }
    function getEventModifierState(nativeEvent) {
      return modifierStateGetter;
    }
    /**
     * @interface KeyboardEvent
     * @see http://www.w3.org/TR/DOM-Level-3-Events/
     */

    var KeyboardEventInterface = assign({}, UIEventInterface, {
      key: getEventKey,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      // Legacy Interface
      charCode: function (event) {
        // `charCode` is the result of a KeyPress event and represents the value of
        // the actual printable character.
        // KeyPress is deprecated, but its replacement is not yet final and not
        // implemented in any major browser. Only KeyPress has charCode.
        if (event.type === 'keypress') {
          return getEventCharCode(event);
        }
        return 0;
      },
      keyCode: function (event) {
        // `keyCode` is the result of a KeyDown/Up event and represents the value of
        // physical keyboard key.
        // The actual meaning of the value depends on the users' keyboard layout
        // which cannot be detected. Assuming that it is a US keyboard layout
        // provides a surprisingly accurate mapping for US and European users.
        // Due to this, it is left to the user to implement at this time.
        if (event.type === 'keydown' || event.type === 'keyup') {
          return event.keyCode;
        }
        return 0;
      },
      which: function (event) {
        // `which` is an alias for either `keyCode` or `charCode` depending on the
        // type of the event.
        if (event.type === 'keypress') {
          return getEventCharCode(event);
        }
        if (event.type === 'keydown' || event.type === 'keyup') {
          return event.keyCode;
        }
        return 0;
      }
    });
    var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
    /**
     * @interface PointerEvent
     * @see http://www.w3.org/TR/pointerevents/
     */

    var PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    });
    var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
    /**
     * @interface TouchEvent
     * @see http://www.w3.org/TR/touch-events/
     */

    var TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    });
    var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
    /**
     * @interface Event
     * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
     * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
     */

    var TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    });
    var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
    /**
     * @interface WheelEvent
     * @see http://www.w3.org/TR/DOM-Level-3-Events/
     */

    var WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function (event) {
        return 'deltaX' in event ? event.deltaX :
        // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
        'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function (event) {
        return 'deltaY' in event ? event.deltaY :
        // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
        'wheelDeltaY' in event ? -event.wheelDeltaY :
        // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
        'wheelDelta' in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    });
    var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);

    /**
     * HTML nodeType values that represent the type of the node
     */
    var ELEMENT_NODE = 1;
    function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      try {
        func.apply(context, funcArgs);
      } catch (error) {
        this.onError(error);
      }
    }
    var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
    {
      // In DEV mode, we swap out invokeGuardedCallback for a special version
      // that plays more nicely with the browser's DevTools. The idea is to preserve
      // "Pause on exceptions" behavior. Because React wraps all user-provided
      // functions in invokeGuardedCallback, and the production version of
      // invokeGuardedCallback uses a try-catch, all user exceptions are treated
      // like caught exceptions, and the DevTools won't pause unless the developer
      // takes the extra step of enabling pause on caught exceptions. This is
      // unintuitive, though, because even though React has caught the error, from
      // the developer's perspective, the error is uncaught.
      //
      // To preserve the expected "Pause on exceptions" behavior, we don't use a
      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
      // DOM node, and call the user-provided callback from inside an event handler
      // for that fake event. If the callback throws, the error is "captured" using
      // a global event handler. But because the error happens in a different
      // event loop context, it does not interrupt the normal program flow.
      // Effectively, this gives us try-catch behavior without actually using
      // try-catch. Neat!
      // Check that the browser supports the APIs we need to implement our special
      // DEV version of invokeGuardedCallback
      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');
        invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
          // If document doesn't exist we know for sure we will crash in this method
          // when we call document.createEvent(). However this can cause confusing
          // errors: https://github.com/facebook/create-react-app/issues/3482
          // So we preemptively throw with a better message instead.
          if (typeof document === 'undefined' || document === null) {
            throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');
          }
          var evt = document.createEvent('Event');
          var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
          // set this to true at the beginning, then set it to false right after
          // calling the function. If the function errors, `didError` will never be
          // set to false. This strategy works even if the browser is flaky and
          // fails to call our global error handler, because it doesn't rely on
          // the error event at all.

          var didError = true; // Keeps track of the value of window.event so that we can reset it
          // during the callback to let user code access window.event in the
          // browsers that support it.

          var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
          // dispatching: https://github.com/facebook/react/issues/13688

          var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
          function restoreAfterDispatch() {
            // We immediately remove the callback from event listeners so that
            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
            // nested call would trigger the fake event handlers of any call higher
            // in the stack.
            fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
            // window.event assignment in both IE <= 10 as they throw an error
            // "Member not found" in strict mode, and in Firefox which does not
            // support window.event.

            if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
              window.event = windowEvent;
            }
          } // Create an event handler for our fake event. We will synchronously
          // dispatch our fake event using `dispatchEvent`. Inside the handler, we
          // call the user-provided callback.

          var funcArgs = Array.prototype.slice.call(arguments, 3);
          function callCallback() {
            didCall = true;
            restoreAfterDispatch();
            func.apply(context, funcArgs);
            didError = false;
          } // Create a global error event handler. We use this to capture the value
          // that was thrown. It's possible that this error handler will fire more
          // than once; for example, if non-React code also calls `dispatchEvent`
          // and a handler for that event throws. We should be resilient to most of
          // those cases. Even if our error event handler fires more than once, the
          // last error event is always used. If the callback actually does error,
          // we know that the last error event is the correct one, because it's not
          // possible for anything else to have happened in between our callback
          // erroring and the code that follows the `dispatchEvent` call below. If
          // the callback doesn't error, but the error event was fired, we know to
          // ignore it because `didError` will be false, as described above.

          var error; // Use this to track whether the error event is ever called.

          var didSetError = false;
          var isCrossOriginError = false;
          function handleWindowError(event) {
            error = event.error;
            didSetError = true;
            if (error === null && event.colno === 0 && event.lineno === 0) {
              isCrossOriginError = true;
            }
            if (event.defaultPrevented) {
              // Some other error handler has prevented default.
              // Browsers silence the error report if this happens.
              // We'll remember this to later decide whether to log it or not.
              if (error != null && typeof error === 'object') {
                try {
                  error._suppressLogging = true;
                } catch (inner) {// Ignore.
                }
              }
            }
          } // Create a fake event type.

          var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers

          window.addEventListener('error', handleWindowError);
          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
          // errors, it will trigger our global error handler.

          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);
          if (windowEventDescriptor) {
            Object.defineProperty(window, 'event', windowEventDescriptor);
          }
          if (didCall && didError) {
            if (!didSetError) {
              // The callback errored, but the error event never fired.
              // eslint-disable-next-line react-internal/prod-error-codes
              error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
            } else if (isCrossOriginError) {
              // eslint-disable-next-line react-internal/prod-error-codes
              error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
            }
            this.onError(error);
          } // Remove our event listeners

          window.removeEventListener('error', handleWindowError);
          if (!didCall) {
            // Something went really wrong, and our event was not dispatched.
            // https://github.com/facebook/react/issues/16734
            // https://github.com/facebook/react/issues/16585
            // Fall back to the production implementation.
            restoreAfterDispatch();
            return invokeGuardedCallbackProd.apply(this, arguments);
          }
        };
      }
    }
    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
    var hasError = false;
    var caughtError = null; // Used by event system to capture/rethrow the first error.

    var hasRethrowError = false;
    var rethrowError = null;
    var reporter = {
      onError: function (error) {
        hasError = true;
        caughtError = error;
      }
    };
    /**
     * Call a function while guarding against errors that happens within it.
     * Returns an error if it throws, otherwise null.
     *
     * In production, this is implemented using a try-catch. The reason we don't
     * use a try-catch directly is so that we can swap out a different
     * implementation in DEV mode.
     *
     * @param {String} name of the guard to use for logging or debugging
     * @param {Function} func The function to invoke
     * @param {*} context The context to use when calling the function
     * @param {...*} args Arguments for function
     */

    function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
      hasError = false;
      caughtError = null;
      invokeGuardedCallbackImpl$1.apply(reporter, arguments);
    }
    /**
     * Same as invokeGuardedCallback, but instead of returning an error, it stores
     * it in a global so it can be rethrown by `rethrowCaughtError` later.
     * TODO: See if caughtError and rethrowError can be unified.
     *
     * @param {String} name of the guard to use for logging or debugging
     * @param {Function} func The function to invoke
     * @param {*} context The context to use when calling the function
     * @param {...*} args Arguments for function
     */

    function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
      invokeGuardedCallback.apply(this, arguments);
      if (hasError) {
        var error = clearCaughtError();
        if (!hasRethrowError) {
          hasRethrowError = true;
          rethrowError = error;
        }
      }
    }
    /**
     * During execution of guarded functions we will capture the first error which
     * we will rethrow to be handled by the top level error handler.
     */

    function rethrowCaughtError() {
      if (hasRethrowError) {
        var error = rethrowError;
        hasRethrowError = false;
        rethrowError = null;
        throw error;
      }
    }
    function clearCaughtError() {
      if (hasError) {
        var error = caughtError;
        hasError = false;
        caughtError = null;
        return error;
      } else {
        throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');
      }
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

    function isArray(a) {
      return isArrayImpl(a);
    }
    var SecretInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var EventInternals = SecretInternals.Events;
    var getInstanceFromNode = EventInternals[0];
    var getNodeFromInstance = EventInternals[1];
    var getFiberCurrentPropsFromNode = EventInternals[2];
    var enqueueStateRestore = EventInternals[3];
    var restoreStateIfNeeded = EventInternals[4];
    var reactAct = React.unstable_act;
    function Event(suffix) {}
    var hasWarnedAboutDeprecatedMockComponent = false;
    /**
     * @class ReactTestUtils
     */

    function findAllInRenderedFiberTreeInternal(fiber, test) {
      if (!fiber) {
        return [];
      }
      var currentParent = findCurrentFiberUsingSlowPath(fiber);
      if (!currentParent) {
        return [];
      }
      var node = currentParent;
      var ret = [];
      while (true) {
        if (node.tag === HostComponent || node.tag === HostText || node.tag === ClassComponent || node.tag === FunctionComponent) {
          var publicInst = node.stateNode;
          if (test(publicInst)) {
            ret.push(publicInst);
          }
        }
        if (node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === currentParent) {
          return ret;
        }
        while (!node.sibling) {
          if (!node.return || node.return === currentParent) {
            return ret;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    function validateClassInstance(inst, methodName) {
      if (!inst) {
        // This is probably too relaxed but it's existing behavior.
        return;
      }
      if (get(inst)) {
        // This is a public instance indeed.
        return;
      }
      var received;
      var stringified = String(inst);
      if (isArray(inst)) {
        received = 'an array';
      } else if (inst && inst.nodeType === ELEMENT_NODE && inst.tagName) {
        received = 'a DOM node';
      } else if (stringified === '[object Object]') {
        received = 'object with keys {' + Object.keys(inst).join(', ') + '}';
      } else {
        received = stringified;
      }
      throw new Error(methodName + "(...): the first argument must be a React class instance. " + ("Instead received: " + received + "."));
    }
    /**
     * Utilities for making it easy to test React components.
     *
     * See https://reactjs.org/docs/test-utils.html
     *
     * Todo: Support the entire DOM.scry query syntax. For now, these simple
     * utilities will suffice for testing purposes.
     * @lends ReactTestUtils
     */

    var didWarnAboutReactTestUtilsDeprecation = false;
    function renderIntoDocument(element) {
      {
        if (!didWarnAboutReactTestUtilsDeprecation) {
          didWarnAboutReactTestUtilsDeprecation = true;
          error('ReactDOMTestUtils is deprecated and will be removed in a future ' + 'major release, because it exposes internal implementation details ' + 'that are highly likely to change between releases. Upgrade to a ' + 'modern testing library, such as @testing-library/react. See ' + 'https://react.dev/warnings/react-dom-test-utils for more info.');
        }
      }
      var div = document.createElement('div'); // None of our tests actually require attaching the container to the
      // DOM, and doing so creates a mess that we rely on test isolation to
      // clean up, so we're going to stop honoring the name of this method
      // (and probably rename it eventually) if no problems arise.
      // document.documentElement.appendChild(div);

      return ReactDOM.render(element, div);
    }
    function isElement(element) {
      return React.isValidElement(element);
    }
    function isElementOfType(inst, convenienceConstructor) {
      return React.isValidElement(inst) && inst.type === convenienceConstructor;
    }
    function isDOMComponent(inst) {
      return !!(inst && inst.nodeType === ELEMENT_NODE && inst.tagName);
    }
    function isDOMComponentElement(inst) {
      return !!(inst && React.isValidElement(inst) && !!inst.tagName);
    }
    function isCompositeComponent(inst) {
      if (isDOMComponent(inst)) {
        // Accessing inst.setState warns; just return false as that'll be what
        // this returns when we have DOM nodes as refs directly
        return false;
      }
      return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
    }
    function isCompositeComponentWithType(inst, type) {
      if (!isCompositeComponent(inst)) {
        return false;
      }
      var internalInstance = get(inst);
      var constructor = internalInstance.type;
      return constructor === type;
    }
    function findAllInRenderedTree(inst, test) {
      validateClassInstance(inst, 'findAllInRenderedTree');
      if (!inst) {
        return [];
      }
      var internalInstance = get(inst);
      return findAllInRenderedFiberTreeInternal(internalInstance, test);
    }
    /**
     * Finds all instances of components in the rendered tree that are DOM
     * components with the class name matching `className`.
     * @return {array} an array of all the matches.
     */

    function scryRenderedDOMComponentsWithClass(root, classNames) {
      validateClassInstance(root, 'scryRenderedDOMComponentsWithClass');
      return findAllInRenderedTree(root, function (inst) {
        if (isDOMComponent(inst)) {
          var className = inst.className;
          if (typeof className !== 'string') {
            // SVG, probably.
            className = inst.getAttribute('class') || '';
          }
          var classList = className.split(/\s+/);
          if (!isArray(classNames)) {
            if (classNames === undefined) {
              throw new Error('TestUtils.scryRenderedDOMComponentsWithClass expects a ' + 'className as a second argument.');
            }
            classNames = classNames.split(/\s+/);
          }
          return classNames.every(function (name) {
            return classList.indexOf(name) !== -1;
          });
        }
        return false;
      });
    }
    /**
     * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
     * and returns that one result, or throws exception if there is any other
     * number of matches besides one.
     * @return {!ReactDOMComponent} The one match.
     */

    function findRenderedDOMComponentWithClass(root, className) {
      validateClassInstance(root, 'findRenderedDOMComponentWithClass');
      var all = scryRenderedDOMComponentsWithClass(root, className);
      if (all.length !== 1) {
        throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);
      }
      return all[0];
    }
    /**
     * Finds all instances of components in the rendered tree that are DOM
     * components with the tag name matching `tagName`.
     * @return {array} an array of all the matches.
     */

    function scryRenderedDOMComponentsWithTag(root, tagName) {
      validateClassInstance(root, 'scryRenderedDOMComponentsWithTag');
      return findAllInRenderedTree(root, function (inst) {
        return isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
      });
    }
    /**
     * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
     * and returns that one result, or throws exception if there is any other
     * number of matches besides one.
     * @return {!ReactDOMComponent} The one match.
     */

    function findRenderedDOMComponentWithTag(root, tagName) {
      validateClassInstance(root, 'findRenderedDOMComponentWithTag');
      var all = scryRenderedDOMComponentsWithTag(root, tagName);
      if (all.length !== 1) {
        throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);
      }
      return all[0];
    }
    /**
     * Finds all instances of components with type equal to `componentType`.
     * @return {array} an array of all the matches.
     */

    function scryRenderedComponentsWithType(root, componentType) {
      validateClassInstance(root, 'scryRenderedComponentsWithType');
      return findAllInRenderedTree(root, function (inst) {
        return isCompositeComponentWithType(inst, componentType);
      });
    }
    /**
     * Same as `scryRenderedComponentsWithType` but expects there to be one result
     * and returns that one result, or throws exception if there is any other
     * number of matches besides one.
     * @return {!ReactComponent} The one match.
     */

    function findRenderedComponentWithType(root, componentType) {
      validateClassInstance(root, 'findRenderedComponentWithType');
      var all = scryRenderedComponentsWithType(root, componentType);
      if (all.length !== 1) {
        throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);
      }
      return all[0];
    }
    /**
     * Pass a mocked component module to this method to augment it with
     * useful methods that allow it to be used as a dummy React component.
     * Instead of rendering as usual, the component will become a simple
     * <div> containing any provided children.
     *
     * @param {object} module the mock function object exported from a
     *                        module that defines the component to be mocked
     * @param {?string} mockTagName optional dummy root tag name to return
     *                              from render method (overrides
     *                              module.mockTagName if provided)
     * @return {object} the ReactTestUtils object (for chaining)
     */

    function mockComponent(module, mockTagName) {
      {
        if (!hasWarnedAboutDeprecatedMockComponent) {
          hasWarnedAboutDeprecatedMockComponent = true;
          warn('ReactTestUtils.mockComponent() is deprecated. ' + 'Use shallow rendering or jest.mock() instead.\n\n' + 'See https://reactjs.org/link/test-utils-mock-component for more information.');
        }
      }
      mockTagName = mockTagName || module.mockTagName || 'div';
      module.prototype.render.mockImplementation(function () {
        return React.createElement(mockTagName, null, this.props.children);
      });
      return this;
    }
    function nativeTouchData(x, y) {
      return {
        touches: [{
          pageX: x,
          pageY: y
        }]
      };
    } // Start of inline: the below functions were inlined from
    // EventPropagator.js, as they deviated from ReactDOM's newer
    // implementations.

    /**
     * Dispatch the event to the listener.
     * @param {SyntheticEvent} event SyntheticEvent to handle
     * @param {function} listener Application-level callback
     * @param {*} inst Internal component instance
     */

    function executeDispatch(event, listener, inst) {
      var type = event.type || 'unknown-event';
      event.currentTarget = getNodeFromInstance(inst);
      invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
      event.currentTarget = null;
    }
    /**
     * Standard/simple iteration through an event's collected dispatches.
     */

    function executeDispatchesInOrder(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if (isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          } // Listeners and Instances are two parallel arrays that are always in sync.

          executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
        }
      } else if (dispatchListeners) {
        executeDispatch(event, dispatchListeners, dispatchInstances);
      }
      event._dispatchListeners = null;
      event._dispatchInstances = null;
    }
    /**
     * Dispatches an event and releases it back into the pool, unless persistent.
     *
     * @param {?object} event Synthetic event to be dispatched.
     * @private
     */

    var executeDispatchesAndRelease = function (event) {
      if (event) {
        executeDispatchesInOrder(event);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    function isInteractive(tag) {
      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    function getParent(inst) {
      do {
        inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
        // That is depending on if we want nested subtrees (layers) to bubble
        // events to their parent. We could also go through parentNode on the
        // host node but that wouldn't work for React Native and doesn't let us
        // do the portal feature.
      } while (inst && inst.tag !== HostComponent);
      if (inst) {
        return inst;
      }
      return null;
    }
    /**
     * Simulates the traversal of a two-phase, capture/bubble event dispatch.
     */

    function traverseTwoPhase(inst, fn, arg) {
      var path = [];
      while (inst) {
        path.push(inst);
        inst = getParent(inst);
      }
      var i;
      for (i = path.length; i-- > 0;) {
        fn(path[i], 'captured', arg);
      }
      for (i = 0; i < path.length; i++) {
        fn(path[i], 'bubbled', arg);
      }
    }
    function shouldPreventMouseEvent(name, type, props) {
      switch (name) {
        case 'onClick':
        case 'onClickCapture':
        case 'onDoubleClick':
        case 'onDoubleClickCapture':
        case 'onMouseDown':
        case 'onMouseDownCapture':
        case 'onMouseMove':
        case 'onMouseMoveCapture':
        case 'onMouseUp':
        case 'onMouseUpCapture':
        case 'onMouseEnter':
          return !!(props.disabled && isInteractive(type));
        default:
          return false;
      }
    }
    /**
     * @param {object} inst The instance, which is the source of events.
     * @param {string} registrationName Name of listener (e.g. `onClick`).
     * @return {?function} The stored callback.
     */

    function getListener(inst, registrationName) {
      // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
      // live here; needs to be moved to a better place soon
      var stateNode = inst.stateNode;
      if (!stateNode) {
        // Work in progress (ex: onload events in incremental mode).
        return null;
      }
      var props = getFiberCurrentPropsFromNode(stateNode);
      if (!props) {
        // Work in progress.
        return null;
      }
      var listener = props[registrationName];
      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
        return null;
      }
      if (listener && typeof listener !== 'function') {
        throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
      }
      return listener;
    }
    function listenerAtPhase(inst, event, propagationPhase) {
      var registrationName = event._reactName;
      if (propagationPhase === 'captured') {
        registrationName += 'Capture';
      }
      return getListener(inst, registrationName);
    }
    function accumulateDispatches(inst, ignoredDirection, event) {
      if (inst && event && event._reactName) {
        var registrationName = event._reactName;
        var listener = getListener(inst, registrationName);
        if (listener) {
          if (event._dispatchListeners == null) {
            event._dispatchListeners = [];
          }
          if (event._dispatchInstances == null) {
            event._dispatchInstances = [];
          }
          event._dispatchListeners.push(listener);
          event._dispatchInstances.push(inst);
        }
      }
    }
    function accumulateDirectionalDispatches(inst, phase, event) {
      {
        if (!inst) {
          error('Dispatching inst must not be null');
        }
      }
      var listener = listenerAtPhase(inst, event, phase);
      if (listener) {
        if (event._dispatchListeners == null) {
          event._dispatchListeners = [];
        }
        if (event._dispatchInstances == null) {
          event._dispatchInstances = [];
        }
        event._dispatchListeners.push(listener);
        event._dispatchInstances.push(inst);
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event._reactName) {
        accumulateDispatches(event._targetInst, null, event);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event._reactName) {
        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
      }
    } // End of inline

    var Simulate = {};
    var directDispatchEventTypes = new Set(['mouseEnter', 'mouseLeave', 'pointerEnter', 'pointerLeave']);
    /**
     * Exports:
     *
     * - `Simulate.click(Element)`
     * - `Simulate.mouseMove(Element)`
     * - `Simulate.change(Element)`
     * - ... (All keys from event plugin `eventTypes` objects)
     */

    function makeSimulator(eventType) {
      return function (domNode, eventData) {
        if (React.isValidElement(domNode)) {
          throw new Error('TestUtils.Simulate expected a DOM node as the first argument but received ' + 'a React element. Pass the DOM node you wish to simulate the event on instead. ' + 'Note that TestUtils.Simulate will not work if you are using shallow rendering.');
        }
        if (isCompositeComponent(domNode)) {
          throw new Error('TestUtils.Simulate expected a DOM node as the first argument but received ' + 'a component instance. Pass the DOM node you wish to simulate the event on instead.');
        }
        var reactName = 'on' + eventType[0].toUpperCase() + eventType.slice(1);
        var fakeNativeEvent = new Event();
        fakeNativeEvent.target = domNode;
        fakeNativeEvent.type = eventType.toLowerCase();
        var targetInst = getInstanceFromNode(domNode);
        var event = new SyntheticEvent(reactName, fakeNativeEvent.type, targetInst, fakeNativeEvent, domNode); // Since we aren't using pooling, always persist the event. This will make
        // sure it's marked and won't warn when setting additional properties.

        event.persist();
        assign(event, eventData);
        if (directDispatchEventTypes.has(eventType)) {
          accumulateDirectDispatchesSingle(event);
        } else {
          accumulateTwoPhaseDispatchesSingle(event);
        }
        ReactDOM.unstable_batchedUpdates(function () {
          // Normally extractEvent enqueues a state restore, but we'll just always
          // do that since we're by-passing it here.
          enqueueStateRestore(domNode);
          executeDispatchesAndRelease(event);
          rethrowCaughtError();
        });
        restoreStateIfNeeded();
      };
    } // A one-time snapshot with no plans to update. We'll probably want to deprecate Simulate API.

    var simulatedEventTypes = ['blur', 'cancel', 'click', 'close', 'contextMenu', 'copy', 'cut', 'auxClick', 'doubleClick', 'dragEnd', 'dragStart', 'drop', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'mouseDown', 'mouseUp', 'paste', 'pause', 'play', 'pointerCancel', 'pointerDown', 'pointerUp', 'rateChange', 'reset', 'resize', 'seeked', 'submit', 'touchCancel', 'touchEnd', 'touchStart', 'volumeChange', 'drag', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'mouseMove', 'mouseOut', 'mouseOver', 'pointerMove', 'pointerOut', 'pointerOver', 'scroll', 'toggle', 'touchMove', 'wheel', 'abort', 'animationEnd', 'animationIteration', 'animationStart', 'canPlay', 'canPlayThrough', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'gotPointerCapture', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'lostPointerCapture', 'playing', 'progress', 'seeking', 'stalled', 'suspend', 'timeUpdate', 'transitionEnd', 'waiting', 'mouseEnter', 'mouseLeave', 'pointerEnter', 'pointerLeave', 'change', 'select', 'beforeInput', 'compositionEnd', 'compositionStart', 'compositionUpdate'];
    function buildSimulators() {
      simulatedEventTypes.forEach(function (eventType) {
        Simulate[eventType] = makeSimulator(eventType);
      });
    }
    buildSimulators();
    var didWarnAboutUsingAct = false;
    var act = function actWithWarning(callback) {
      {
        if (!didWarnAboutUsingAct) {
          didWarnAboutUsingAct = true;
          error('`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. ' + 'Import `act` from `react` instead of `react-dom/test-utils`. ' + 'See https://react.dev/warnings/react-dom-test-utils for more info.');
        }
      }
      return reactAct(callback);
    };
    exports.Simulate = Simulate;
    exports.act = act;
    exports.findAllInRenderedTree = findAllInRenderedTree;
    exports.findRenderedComponentWithType = findRenderedComponentWithType;
    exports.findRenderedDOMComponentWithClass = findRenderedDOMComponentWithClass;
    exports.findRenderedDOMComponentWithTag = findRenderedDOMComponentWithTag;
    exports.isCompositeComponent = isCompositeComponent;
    exports.isCompositeComponentWithType = isCompositeComponentWithType;
    exports.isDOMComponent = isDOMComponent;
    exports.isDOMComponentElement = isDOMComponentElement;
    exports.isElement = isElement;
    exports.isElementOfType = isElementOfType;
    exports.mockComponent = mockComponent;
    exports.nativeTouchData = nativeTouchData;
    exports.renderIntoDocument = renderIntoDocument;
    exports.scryRenderedComponentsWithType = scryRenderedComponentsWithType;
    exports.scryRenderedDOMComponentsWithClass = scryRenderedDOMComponentsWithClass;
    exports.scryRenderedDOMComponentsWithTag = scryRenderedDOMComponentsWithTag;
    exports.traverseTwoPhase = traverseTwoPhase;
  })();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwiRnVuY3Rpb25Db21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiTm9GbGFncyIsIlBsYWNlbWVudCIsIkh5ZHJhdGluZyIsIlJlYWN0Q3VycmVudE93bmVyIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsImZpYmVyIiwibm9kZSIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwibmV4dE5vZGUiLCJmbGFncyIsInJldHVybiIsInRhZyIsImFzc2VydElzTW91bnRlZCIsIkVycm9yIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsInN0YXRlTm9kZSIsImN1cnJlbnQiLCJhc3NpZ24iLCJPYmplY3QiLCJnZXRFdmVudENoYXJDb2RlIiwibmF0aXZlRXZlbnQiLCJjaGFyQ29kZSIsImtleUNvZGUiLCJmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSIsImZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSIsImNyZWF0ZVN5bnRoZXRpY0V2ZW50IiwiSW50ZXJmYWNlIiwiU3ludGhldGljQmFzZUV2ZW50IiwicmVhY3ROYW1lIiwicmVhY3RFdmVudFR5cGUiLCJ0YXJnZXRJbnN0IiwibmF0aXZlRXZlbnRUYXJnZXQiLCJfcmVhY3ROYW1lIiwiX3RhcmdldEluc3QiLCJ0eXBlIiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIl9wcm9wTmFtZSIsImhhc093blByb3BlcnR5Iiwibm9ybWFsaXplIiwiZGVmYXVsdFByZXZlbnRlZCIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImlzUGVyc2lzdGVudCIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImlzVHJ1c3RlZCIsIlN5bnRoZXRpY0V2ZW50IiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJkZXRhaWwiLCJTeW50aGV0aWNVSUV2ZW50IiwibGFzdE1vdmVtZW50WCIsImxhc3RNb3ZlbWVudFkiLCJsYXN0TW91c2VFdmVudCIsInVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlIiwic2NyZWVuWCIsInNjcmVlblkiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWdlWCIsInBhZ2VZIiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibWV0YUtleSIsImdldE1vZGlmaWVyU3RhdGUiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJidXR0b24iLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsInVuZGVmaW5lZCIsImZyb21FbGVtZW50Iiwic3JjRWxlbWVudCIsInRvRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwid2luZG93IiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiZGF0YSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsImZyb21DaGFyQ29kZSIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiY29kZSIsImxvY2F0aW9uIiwicmVwZWF0IiwibG9jYWxlIiwid2hpY2giLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiUG9pbnRlckV2ZW50SW50ZXJmYWNlIiwicG9pbnRlcklkIiwid2lkdGgiLCJoZWlnaHQiLCJwcmVzc3VyZSIsInRhbmdlbnRpYWxQcmVzc3VyZSIsInRpbHRYIiwidGlsdFkiLCJ0d2lzdCIsInBvaW50ZXJUeXBlIiwiaXNQcmltYXJ5IiwiU3ludGhldGljUG9pbnRlckV2ZW50IiwiVG91Y2hFdmVudEludGVyZmFjZSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwicHJvcGVydHlOYW1lIiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiV2hlZWxFdmVudEludGVyZmFjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwiU3ludGhldGljV2hlZWxFdmVudCIsIkVMRU1FTlRfTk9ERSIsImludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QiLCJuYW1lIiwiZnVuYyIsImNvbnRleHQiLCJjIiwiZCIsImUiLCJmIiwiZnVuY0FyZ3MiLCJzbGljZSIsIm9uRXJyb3IiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsIiwiZGlzcGF0Y2hFdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJldnQiLCJkaWRDYWxsIiwiZGlkRXJyb3IiLCJ3aW5kb3dFdmVudCIsIndpbmRvd0V2ZW50RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInJlc3RvcmVBZnRlckRpc3BhdGNoIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2dFR5cGUiLCJjYWxsQ2FsbGJhY2siLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJfc3VwcHJlc3NMb2dnaW5nIiwiaW5uZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdEV2ZW50IiwiZGVmaW5lUHJvcGVydHkiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwiaGFzUmV0aHJvd0Vycm9yIiwicmV0aHJvd0Vycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiU2VjcmV0SW50ZXJuYWxzIiwiRXZlbnRJbnRlcm5hbHMiLCJFdmVudHMiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUiLCJlbnF1ZXVlU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJyZWFjdEFjdCIsInVuc3RhYmxlX2FjdCIsIkV2ZW50Iiwic3VmZml4IiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCIsImZpbmRBbGxJblJlbmRlcmVkRmliZXJUcmVlSW50ZXJuYWwiLCJ0ZXN0IiwiY3VycmVudFBhcmVudCIsInJldCIsInB1YmxpY0luc3QiLCJwdXNoIiwidmFsaWRhdGVDbGFzc0luc3RhbmNlIiwiaW5zdCIsIm1ldGhvZE5hbWUiLCJyZWNlaXZlZCIsInN0cmluZ2lmaWVkIiwibm9kZVR5cGUiLCJ0YWdOYW1lIiwia2V5cyIsImpvaW4iLCJkaWRXYXJuQWJvdXRSZWFjdFRlc3RVdGlsc0RlcHJlY2F0aW9uIiwicmVuZGVySW50b0RvY3VtZW50IiwiZWxlbWVudCIsImRpdiIsInJlbmRlciIsImlzRWxlbWVudCIsImlzVmFsaWRFbGVtZW50IiwiaXNFbGVtZW50T2ZUeXBlIiwiY29udmVuaWVuY2VDb25zdHJ1Y3RvciIsImlzRE9NQ29tcG9uZW50IiwiaXNET01Db21wb25lbnRFbGVtZW50IiwiaXNDb21wb3NpdGVDb21wb25lbnQiLCJzZXRTdGF0ZSIsImlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUiLCJpbnRlcm5hbEluc3RhbmNlIiwiY29uc3RydWN0b3IiLCJmaW5kQWxsSW5SZW5kZXJlZFRyZWUiLCJzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzIiwicm9vdCIsImNsYXNzTmFtZXMiLCJjbGFzc05hbWUiLCJnZXRBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJzcGxpdCIsImV2ZXJ5IiwiaW5kZXhPZiIsImZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcyIsImFsbCIsInNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIiwidG9VcHBlckNhc2UiLCJmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoVGFnIiwic2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlIiwiY29tcG9uZW50VHlwZSIsImZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlIiwibW9ja0NvbXBvbmVudCIsIm1vZHVsZSIsIm1vY2tUYWdOYW1lIiwibW9ja0ltcGxlbWVudGF0aW9uIiwicHJvcHMiLCJjaGlsZHJlbiIsIm5hdGl2ZVRvdWNoRGF0YSIsIngiLCJ5IiwiZXhlY3V0ZURpc3BhdGNoIiwibGlzdGVuZXIiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJkaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSW5zdGFuY2VzIiwiX2Rpc3BhdGNoSW5zdGFuY2VzIiwiaSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSIsInJlbGVhc2UiLCJpc0ludGVyYWN0aXZlIiwiZ2V0UGFyZW50IiwidHJhdmVyc2VUd29QaGFzZSIsImZuIiwiYXJnIiwicGF0aCIsInNob3VsZFByZXZlbnRNb3VzZUV2ZW50IiwiZGlzYWJsZWQiLCJnZXRMaXN0ZW5lciIsInJlZ2lzdHJhdGlvbk5hbWUiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwiU2ltdWxhdGUiLCJkaXJlY3REaXNwYXRjaEV2ZW50VHlwZXMiLCJTZXQiLCJtYWtlU2ltdWxhdG9yIiwiZXZlbnRUeXBlIiwiZG9tTm9kZSIsImV2ZW50RGF0YSIsImZha2VOYXRpdmVFdmVudCIsInRvTG93ZXJDYXNlIiwiaGFzIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJzaW11bGF0ZWRFdmVudFR5cGVzIiwiYnVpbGRTaW11bGF0b3JzIiwiZm9yRWFjaCIsImRpZFdhcm5BYm91dFVzaW5nQWN0IiwiYWN0IiwiYWN0V2l0aFdhcm5pbmciLCJjYWxsYmFjayIsImV4cG9ydHMiXSwic291cmNlcyI6WyJyZWFjdC1kb20tdGVzdC11dGlscy5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tdGVzdC11dGlscy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cblxudmFyIEZ1bmN0aW9uQ29tcG9uZW50ID0gMDtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDE7XG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlcy4gVGhleSdyZSB1c2VkIGJ5IFJlYWN0IERldiBUb29scy5cbnZhciBOb0ZsYWdzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xuXG52YXIgUGxhY2VtZW50ID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBIeWRyYXRpbmcgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG40MDk2O1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuXG5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudEEgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcblxuICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBhbHRlcm5hdGUuIFRoaXMgaXMgYW4gdW51c3VhbCBjYXNlLiBDdXJyZW50bHksIGl0IG9ubHlcbiAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4gICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAvLyBvdmVyIHRoaXMgZXh0cmEgZnJhZ21lbnQgZmliZXIgYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgcGFyZW50LlxuICAgICAgdmFyIG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcblxuICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYSA9IGIgPSBuZXh0UGFyZW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuXG5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfSAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7IC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH0gLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5cblxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfSAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cblxuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKSB7XG4gIC8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtfcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW19wcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICovXG4gICAgcGVyc2lzdDogZnVuY3Rpb24gKCkgey8vIE1vZGVybiBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICB9KTtcbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGV2ZW50UGhhc2U6IDAsXG4gIGJ1YmJsZXM6IDAsXG4gIGNhbmNlbGFibGU6IDAsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICBpc1RydXN0ZWQ6IDBcbn07XG52YXIgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7XG5cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICB2aWV3OiAwLFxuICBkZXRhaWw6IDBcbn0pO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFVJRXZlbnRJbnRlcmZhY2UpO1xudmFyIGxhc3RNb3ZlbWVudFg7XG52YXIgbGFzdE1vdmVtZW50WTtcbnZhciBsYXN0TW91c2VFdmVudDtcblxuZnVuY3Rpb24gdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICE9PSBsYXN0TW91c2VFdmVudCkge1xuICAgIGlmIChsYXN0TW91c2VFdmVudCAmJiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IGV2ZW50LnNjcmVlblggLSBsYXN0TW91c2VFdmVudC5zY3JlZW5YO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IGV2ZW50LnNjcmVlblkgLSBsYXN0TW91c2VFdmVudC5zY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gMDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSAwO1xuICAgIH1cblxuICAgIGxhc3RNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHNjcmVlblg6IDAsXG4gIHNjcmVlblk6IDAsXG4gIGNsaWVudFg6IDAsXG4gIGNsaWVudFk6IDAsXG4gIHBhZ2VYOiAwLFxuICBwYWdlWTogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IDAsXG4gIGJ1dHRvbnM6IDAsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ID09PSB1bmRlZmluZWQpIHJldHVybiBldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICB9LFxuICBtb3ZlbWVudFg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICgnbW92ZW1lbnRYJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50Lm1vdmVtZW50WDtcbiAgICB9XG5cbiAgICB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZShldmVudCk7XG4gICAgcmV0dXJuIGxhc3RNb3ZlbWVudFg7XG4gIH0sXG4gIG1vdmVtZW50WTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFknIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gLy8gRG9uJ3QgbmVlZCB0byBjYWxsIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKCkgaGVyZVxuICAgIC8vIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIHRvIGhhdmUgYWxyZWFkeSBydW4gd2hlbiBtb3ZlbWVudFhcbiAgICAvLyB3YXMgY29waWVkLlxuXG5cbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WTtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoTW91c2VFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGFUcmFuc2ZlcjogMFxufSk7XG5cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChEcmFnRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHJlbGF0ZWRUYXJnZXQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG5cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgYW5pbWF0aW9uTmFtZTogMCxcbiAgZWxhcHNlZFRpbWU6IDAsXG4gIHBzZXVkb0VsZW1lbnQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cblxudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cblxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGE6IDBcbn0pO1xuXG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9IC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cblxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7IC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTsgLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcblxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cblxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBjb2RlOiAwLFxuICBsb2NhdGlvbjogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgcmVwZWF0OiAwLFxuICBsb2NhbGU6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xuXG52YXIgUG9pbnRlckV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIHBvaW50ZXJJZDogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgcHJlc3N1cmU6IDAsXG4gIHRhbmdlbnRpYWxQcmVzc3VyZTogMCxcbiAgdGlsdFg6IDAsXG4gIHRpbHRZOiAwLFxuICB0d2lzdDogMCxcbiAgcG9pbnRlclR5cGU6IDAsXG4gIGlzUHJpbWFyeTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNQb2ludGVyRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChQb2ludGVyRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG5cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHRvdWNoZXM6IDAsXG4gIHRhcmdldFRvdWNoZXM6IDAsXG4gIGNoYW5nZWRUb3VjaGVzOiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBwcm9wZXJ0eU5hbWU6IDAsXG4gIGVsYXBzZWRUaW1lOiAwLFxuICBwc2V1ZG9FbGVtZW50OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiAwLFxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2Q7XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgJyArICdkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJyArICdzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJyArICdmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgJyArICd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJyArICdjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcgKyAndG8gYmUgYXN5bmNocm9ub3VzLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICB2YXIgZGlkQ2FsbCA9IGZhbHNlOyAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVzZXQgaXRcbiAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2sgdG8gbGV0IHVzZXIgY29kZSBhY2Nlc3Mgd2luZG93LmV2ZW50IGluIHRoZVxuICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuXG4gICAgICB2YXIgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4gICAgICAvLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxuXG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG4gICAgICBmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFdlIGNoZWNrIGZvciB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykgdG8gcHJldmVudCB0aGVcbiAgICAgICAgLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4gICAgICAgIC8vIFwiTWVtYmVyIG5vdCBmb3VuZFwiIGluIHN0cmljdCBtb2RlLCBhbmQgaW4gRmlyZWZveCB3aGljaCBkb2VzIG5vdFxuICAgICAgICAvLyBzdXBwb3J0IHdpbmRvdy5ldmVudC5cblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cblxuXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cblxuXG4gICAgICB2YXIgZXJyb3I7IC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHsvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cblxuXG4gICAgICB2YXIgZXZ0VHlwZSA9IFwicmVhY3QtXCIgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7IC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cblxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRDYWxsICYmIGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxuXG52YXIgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG52YXIgcmV0aHJvd0Vycm9yID0gbnVsbDtcbnZhciByZXBvcnRlciA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICpcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGhhc0Vycm9yID0gZmFsc2U7XG4gIGNhdWdodEVycm9yID0gbnVsbDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAqIFRPRE86IFNlZSBpZiBjYXVnaHRFcnJvciBhbmQgcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICBpZiAoIWhhc1JldGhyb3dFcnJvcikge1xuICAgICAgaGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgIHJldGhyb3dFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuXG5mdW5jdGlvbiByZXRocm93Q2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNSZXRocm93RXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSByZXRocm93RXJyb3I7XG4gICAgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbnZhciBTZWNyZXRJbnRlcm5hbHMgPSBSZWFjdERPTS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbnZhciBFdmVudEludGVybmFscyA9IFNlY3JldEludGVybmFscy5FdmVudHM7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEV2ZW50SW50ZXJuYWxzWzBdO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBFdmVudEludGVybmFsc1sxXTtcbnZhciBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gRXZlbnRJbnRlcm5hbHNbMl07XG52YXIgZW5xdWV1ZVN0YXRlUmVzdG9yZSA9IEV2ZW50SW50ZXJuYWxzWzNdO1xudmFyIHJlc3RvcmVTdGF0ZUlmTmVlZGVkID0gRXZlbnRJbnRlcm5hbHNbNF07XG52YXIgcmVhY3RBY3QgPSBSZWFjdC51bnN0YWJsZV9hY3Q7XG5cbmZ1bmN0aW9uIEV2ZW50KHN1ZmZpeCkge31cblxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZE1vY2tDb21wb25lbnQgPSBmYWxzZTtcbi8qKlxuICogQGNsYXNzIFJlYWN0VGVzdFV0aWxzXG4gKi9cblxuZnVuY3Rpb24gZmluZEFsbEluUmVuZGVyZWRGaWJlclRyZWVJbnRlcm5hbChmaWJlciwgdGVzdCkge1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcik7XG5cbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB2YXIgcmV0ID0gW107XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0IHx8IG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0ID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0ZXN0KHB1YmxpY0luc3QpKSB7XG4gICAgICAgIHJldC5wdXNoKHB1YmxpY0luc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsYXNzSW5zdGFuY2UoaW5zdCwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWluc3QpIHtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IHRvbyByZWxheGVkIGJ1dCBpdCdzIGV4aXN0aW5nIGJlaGF2aW9yLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnZXQoaW5zdCkpIHtcbiAgICAvLyBUaGlzIGlzIGEgcHVibGljIGluc3RhbmNlIGluZGVlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVjZWl2ZWQ7XG4gIHZhciBzdHJpbmdpZmllZCA9IFN0cmluZyhpbnN0KTtcblxuICBpZiAoaXNBcnJheShpbnN0KSkge1xuICAgIHJlY2VpdmVkID0gJ2FuIGFycmF5JztcbiAgfSBlbHNlIGlmIChpbnN0ICYmIGluc3Qubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBpbnN0LnRhZ05hbWUpIHtcbiAgICByZWNlaXZlZCA9ICdhIERPTSBub2RlJztcbiAgfSBlbHNlIGlmIChzdHJpbmdpZmllZCA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZWNlaXZlZCA9ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoaW5zdCkuam9pbignLCAnKSArICd9JztcbiAgfSBlbHNlIHtcbiAgICByZWNlaXZlZCA9IHN0cmluZ2lmaWVkO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZE5hbWUgKyBcIiguLi4pOiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGNsYXNzIGluc3RhbmNlLiBcIiArIChcIkluc3RlYWQgcmVjZWl2ZWQ6IFwiICsgcmVjZWl2ZWQgKyBcIi5cIikpO1xufVxuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1ha2luZyBpdCBlYXN5IHRvIHRlc3QgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3Rlc3QtdXRpbHMuaHRtbFxuICpcbiAqIFRvZG86IFN1cHBvcnQgdGhlIGVudGlyZSBET00uc2NyeSBxdWVyeSBzeW50YXguIEZvciBub3csIHRoZXNlIHNpbXBsZVxuICogdXRpbGl0aWVzIHdpbGwgc3VmZmljZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqIEBsZW5kcyBSZWFjdFRlc3RVdGlsc1xuICovXG5cblxudmFyIGRpZFdhcm5BYm91dFJlYWN0VGVzdFV0aWxzRGVwcmVjYXRpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVySW50b0RvY3VtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0UmVhY3RUZXN0VXRpbHNEZXByZWNhdGlvbikge1xuICAgICAgZGlkV2FybkFib3V0UmVhY3RUZXN0VXRpbHNEZXByZWNhdGlvbiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdSZWFjdERPTVRlc3RVdGlscyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgJyArICdtYWpvciByZWxlYXNlLCBiZWNhdXNlIGl0IGV4cG9zZXMgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlscyAnICsgJ3RoYXQgYXJlIGhpZ2hseSBsaWtlbHkgdG8gY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuIFVwZ3JhZGUgdG8gYSAnICsgJ21vZGVybiB0ZXN0aW5nIGxpYnJhcnksIHN1Y2ggYXMgQHRlc3RpbmctbGlicmFyeS9yZWFjdC4gU2VlICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvd2FybmluZ3MvcmVhY3QtZG9tLXRlc3QtdXRpbHMgZm9yIG1vcmUgaW5mby4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIE5vbmUgb2Ygb3VyIHRlc3RzIGFjdHVhbGx5IHJlcXVpcmUgYXR0YWNoaW5nIHRoZSBjb250YWluZXIgdG8gdGhlXG4gIC8vIERPTSwgYW5kIGRvaW5nIHNvIGNyZWF0ZXMgYSBtZXNzIHRoYXQgd2UgcmVseSBvbiB0ZXN0IGlzb2xhdGlvbiB0b1xuICAvLyBjbGVhbiB1cCwgc28gd2UncmUgZ29pbmcgdG8gc3RvcCBob25vcmluZyB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZFxuICAvLyAoYW5kIHByb2JhYmx5IHJlbmFtZSBpdCBldmVudHVhbGx5KSBpZiBubyBwcm9ibGVtcyBhcmlzZS5cbiAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgcmV0dXJuIFJlYWN0RE9NLnJlbmRlcihlbGVtZW50LCBkaXYpO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudE9mVHlwZShpbnN0LCBjb252ZW5pZW5jZUNvbnN0cnVjdG9yKSB7XG4gIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChpbnN0KSAmJiBpbnN0LnR5cGUgPT09IGNvbnZlbmllbmNlQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGlzRE9NQ29tcG9uZW50KGluc3QpIHtcbiAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGluc3QudGFnTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGlzRE9NQ29tcG9uZW50RWxlbWVudChpbnN0KSB7XG4gIHJldHVybiAhIShpbnN0ICYmIFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpICYmICEhaW5zdC50YWdOYW1lKTtcbn1cblxuZnVuY3Rpb24gaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkge1xuICBpZiAoaXNET01Db21wb25lbnQoaW5zdCkpIHtcbiAgICAvLyBBY2Nlc3NpbmcgaW5zdC5zZXRTdGF0ZSB3YXJuczsganVzdCByZXR1cm4gZmFsc2UgYXMgdGhhdCdsbCBiZSB3aGF0XG4gICAgLy8gdGhpcyByZXR1cm5zIHdoZW4gd2UgaGF2ZSBET00gbm9kZXMgYXMgcmVmcyBkaXJlY3RseVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbnN0ICE9IG51bGwgJiYgdHlwZW9mIGluc3QucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0LnNldFN0YXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlKGluc3QsIHR5cGUpIHtcbiAgaWYgKCFpc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0KGluc3QpO1xuICB2YXIgY29uc3RydWN0b3IgPSBpbnRlcm5hbEluc3RhbmNlLnR5cGU7XG4gIHJldHVybiBjb25zdHJ1Y3RvciA9PT0gdHlwZTtcbn1cblxuZnVuY3Rpb24gZmluZEFsbEluUmVuZGVyZWRUcmVlKGluc3QsIHRlc3QpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKGluc3QsICdmaW5kQWxsSW5SZW5kZXJlZFRyZWUnKTtcblxuICBpZiAoIWluc3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldChpbnN0KTtcbiAgcmV0dXJuIGZpbmRBbGxJblJlbmRlcmVkRmliZXJUcmVlSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgdGVzdCk7XG59XG4vKipcbiAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAqIGNvbXBvbmVudHMgd2l0aCB0aGUgY2xhc3MgbmFtZSBtYXRjaGluZyBgY2xhc3NOYW1lYC5cbiAqIEByZXR1cm4ge2FycmF5fSBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzKHJvb3QsIGNsYXNzTmFtZXMpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKHJvb3QsICdzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzJyk7XG4gIHJldHVybiBmaW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoaXNET01Db21wb25lbnQoaW5zdCkpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBpbnN0LmNsYXNzTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFNWRywgcHJvYmFibHkuXG4gICAgICAgIGNsYXNzTmFtZSA9IGluc3QuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgIGlmICghaXNBcnJheShjbGFzc05hbWVzKSkge1xuICAgICAgICBpZiAoY2xhc3NOYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0VXRpbHMuc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyBleHBlY3RzIGEgJyArICdjbGFzc05hbWUgYXMgYSBzZWNvbmQgYXJndW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3NOYW1lcy5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cbi8qKlxuICogTGlrZSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcyhyb290LCBjbGFzc05hbWUpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKHJvb3QsICdmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3MnKTtcbiAgdmFyIGFsbCA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3Mocm9vdCwgY2xhc3NOYW1lKTtcblxuICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGV4YWN0bHkgb25lIG1hdGNoIChmb3VuZDogJyArIGFsbC5sZW5ndGggKyAnKSAnICsgJ2ZvciBjbGFzczonICsgY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBhbGxbMF07XG59XG4vKipcbiAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAqIGNvbXBvbmVudHMgd2l0aCB0aGUgdGFnIG5hbWUgbWF0Y2hpbmcgYHRhZ05hbWVgLlxuICogQHJldHVybiB7YXJyYXl9IGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKHJvb3QsICdzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZycpO1xuICByZXR1cm4gZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGlzRE9NQ29tcG9uZW50KGluc3QpICYmIGluc3QudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSB0YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWcocm9vdCwgdGFnTmFtZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ2ZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWcnKTtcbiAgdmFyIGFsbCA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpO1xuXG4gIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggKGZvdW5kOiAnICsgYWxsLmxlbmd0aCArICcpICcgKyAnZm9yIHRhZzonICsgdGFnTmFtZSk7XG4gIH1cblxuICByZXR1cm4gYWxsWzBdO1xufVxuLyoqXG4gKiBGaW5kcyBhbGwgaW5zdGFuY2VzIG9mIGNvbXBvbmVudHMgd2l0aCB0eXBlIGVxdWFsIHRvIGBjb21wb25lbnRUeXBlYC5cbiAqIEByZXR1cm4ge2FycmF5fSBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ3NjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZScpO1xuICByZXR1cm4gZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUoaW5zdCwgY29tcG9uZW50VHlwZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBTYW1lIGFzIGBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGVgIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHRcbiAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICogQHJldHVybiB7IVJlYWN0Q29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICovXG5cblxuZnVuY3Rpb24gZmluZFJlbmRlcmVkQ29tcG9uZW50V2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ2ZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlJyk7XG4gIHZhciBhbGwgPSBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSk7XG5cbiAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCAoZm91bmQ6ICcgKyBhbGwubGVuZ3RoICsgJykgJyArICdmb3IgY29tcG9uZW50VHlwZTonICsgY29tcG9uZW50VHlwZSk7XG4gIH1cblxuICByZXR1cm4gYWxsWzBdO1xufVxuLyoqXG4gKiBQYXNzIGEgbW9ja2VkIGNvbXBvbmVudCBtb2R1bGUgdG8gdGhpcyBtZXRob2QgdG8gYXVnbWVudCBpdCB3aXRoXG4gKiB1c2VmdWwgbWV0aG9kcyB0aGF0IGFsbG93IGl0IHRvIGJlIHVzZWQgYXMgYSBkdW1teSBSZWFjdCBjb21wb25lbnQuXG4gKiBJbnN0ZWFkIG9mIHJlbmRlcmluZyBhcyB1c3VhbCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlY29tZSBhIHNpbXBsZVxuICogPGRpdj4gY29udGFpbmluZyBhbnkgcHJvdmlkZWQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZSB0aGUgbW9jayBmdW5jdGlvbiBvYmplY3QgZXhwb3J0ZWQgZnJvbSBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0aGF0IGRlZmluZXMgdGhlIGNvbXBvbmVudCB0byBiZSBtb2NrZWRcbiAqIEBwYXJhbSB7P3N0cmluZ30gbW9ja1RhZ05hbWUgb3B0aW9uYWwgZHVtbXkgcm9vdCB0YWcgbmFtZSB0byByZXR1cm5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSByZW5kZXIgbWV0aG9kIChvdmVycmlkZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLm1vY2tUYWdOYW1lIGlmIHByb3ZpZGVkKVxuICogQHJldHVybiB7b2JqZWN0fSB0aGUgUmVhY3RUZXN0VXRpbHMgb2JqZWN0IChmb3IgY2hhaW5pbmcpXG4gKi9cblxuXG5mdW5jdGlvbiBtb2NrQ29tcG9uZW50KG1vZHVsZSwgbW9ja1RhZ05hbWUpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0VGVzdFV0aWxzLm1vY2tDb21wb25lbnQoKSBpcyBkZXByZWNhdGVkLiAnICsgJ1VzZSBzaGFsbG93IHJlbmRlcmluZyBvciBqZXN0Lm1vY2soKSBpbnN0ZWFkLlxcblxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay90ZXN0LXV0aWxzLW1vY2stY29tcG9uZW50IGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgIH1cbiAgfVxuXG4gIG1vY2tUYWdOYW1lID0gbW9ja1RhZ05hbWUgfHwgbW9kdWxlLm1vY2tUYWdOYW1lIHx8ICdkaXYnO1xuICBtb2R1bGUucHJvdG90eXBlLnJlbmRlci5tb2NrSW1wbGVtZW50YXRpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KG1vY2tUYWdOYW1lLCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBuYXRpdmVUb3VjaERhdGEoeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHRvdWNoZXM6IFt7XG4gICAgICBwYWdlWDogeCxcbiAgICAgIHBhZ2VZOiB5XG4gICAgfV1cbiAgfTtcbn0gLy8gU3RhcnQgb2YgaW5saW5lOiB0aGUgYmVsb3cgZnVuY3Rpb25zIHdlcmUgaW5saW5lZCBmcm9tXG4vLyBFdmVudFByb3BhZ2F0b3IuanMsIGFzIHRoZXkgZGV2aWF0ZWQgZnJvbSBSZWFjdERPTSdzIG5ld2VyXG4vLyBpbXBsZW1lbnRhdGlvbnMuXG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICBpZiAoaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG5cblxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuXG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjsgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5cblxuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG5cbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuXG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcblxuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuXG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiICsgcmVnaXN0cmF0aW9uTmFtZSArIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArIHR5cGVvZiBsaXN0ZW5lciArIFwiYCB0eXBlLlwiKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZTtcblxuICBpZiAocHJvcGFnYXRpb25QaGFzZSA9PT0gJ2NhcHR1cmVkJykge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWUgKz0gJ0NhcHR1cmUnO1xuICB9XG5cbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5fcmVhY3ROYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5fcmVhY3ROYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBpZiAoZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPT0gbnVsbCkge1xuICAgICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMucHVzaChpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIGlmICghaW5zdCkge1xuICAgICAgZXJyb3IoJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuXG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGlmIChldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9PSBudWxsKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBbXTtcbiAgICB9XG5cbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMucHVzaChpbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuX3JlYWN0TmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuX3JlYWN0TmFtZSkge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufSAvLyBFbmQgb2YgaW5saW5lXG5cblxudmFyIFNpbXVsYXRlID0ge307XG52YXIgZGlyZWN0RGlzcGF0Y2hFdmVudFR5cGVzID0gbmV3IFNldChbJ21vdXNlRW50ZXInLCAnbW91c2VMZWF2ZScsICdwb2ludGVyRW50ZXInLCAncG9pbnRlckxlYXZlJ10pO1xuLyoqXG4gKiBFeHBvcnRzOlxuICpcbiAqIC0gYFNpbXVsYXRlLmNsaWNrKEVsZW1lbnQpYFxuICogLSBgU2ltdWxhdGUubW91c2VNb3ZlKEVsZW1lbnQpYFxuICogLSBgU2ltdWxhdGUuY2hhbmdlKEVsZW1lbnQpYFxuICogLSAuLi4gKEFsbCBrZXlzIGZyb20gZXZlbnQgcGx1Z2luIGBldmVudFR5cGVzYCBvYmplY3RzKVxuICovXG5cbmZ1bmN0aW9uIG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9tTm9kZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3RVdGlscy5TaW11bGF0ZSBleHBlY3RlZCBhIERPTSBub2RlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBidXQgcmVjZWl2ZWQgJyArICdhIFJlYWN0IGVsZW1lbnQuIFBhc3MgdGhlIERPTSBub2RlIHlvdSB3aXNoIHRvIHNpbXVsYXRlIHRoZSBldmVudCBvbiBpbnN0ZWFkLiAnICsgJ05vdGUgdGhhdCBUZXN0VXRpbHMuU2ltdWxhdGUgd2lsbCBub3Qgd29yayBpZiB5b3UgYXJlIHVzaW5nIHNoYWxsb3cgcmVuZGVyaW5nLicpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBvc2l0ZUNvbXBvbmVudChkb21Ob2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0VXRpbHMuU2ltdWxhdGUgZXhwZWN0ZWQgYSBET00gbm9kZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYnV0IHJlY2VpdmVkICcgKyAnYSBjb21wb25lbnQgaW5zdGFuY2UuIFBhc3MgdGhlIERPTSBub2RlIHlvdSB3aXNoIHRvIHNpbXVsYXRlIHRoZSBldmVudCBvbiBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHZhciByZWFjdE5hbWUgPSAnb24nICsgZXZlbnRUeXBlWzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudFR5cGUuc2xpY2UoMSk7XG4gICAgdmFyIGZha2VOYXRpdmVFdmVudCA9IG5ldyBFdmVudCgpO1xuICAgIGZha2VOYXRpdmVFdmVudC50YXJnZXQgPSBkb21Ob2RlO1xuICAgIGZha2VOYXRpdmVFdmVudC50eXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHRhcmdldEluc3QgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGRvbU5vZGUpO1xuICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudChyZWFjdE5hbWUsIGZha2VOYXRpdmVFdmVudC50eXBlLCB0YXJnZXRJbnN0LCBmYWtlTmF0aXZlRXZlbnQsIGRvbU5vZGUpOyAvLyBTaW5jZSB3ZSBhcmVuJ3QgdXNpbmcgcG9vbGluZywgYWx3YXlzIHBlcnNpc3QgdGhlIGV2ZW50LiBUaGlzIHdpbGwgbWFrZVxuICAgIC8vIHN1cmUgaXQncyBtYXJrZWQgYW5kIHdvbid0IHdhcm4gd2hlbiBzZXR0aW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cblxuICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICBhc3NpZ24oZXZlbnQsIGV2ZW50RGF0YSk7XG5cbiAgICBpZiAoZGlyZWN0RGlzcGF0Y2hFdmVudFR5cGVzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpO1xuICAgIH1cblxuICAgIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIE5vcm1hbGx5IGV4dHJhY3RFdmVudCBlbnF1ZXVlcyBhIHN0YXRlIHJlc3RvcmUsIGJ1dCB3ZSdsbCBqdXN0IGFsd2F5c1xuICAgICAgLy8gZG8gdGhhdCBzaW5jZSB3ZSdyZSBieS1wYXNzaW5nIGl0IGhlcmUuXG4gICAgICBlbnF1ZXVlU3RhdGVSZXN0b3JlKGRvbU5vZGUpO1xuICAgICAgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGV2ZW50KTtcbiAgICAgIHJldGhyb3dDYXVnaHRFcnJvcigpO1xuICAgIH0pO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH07XG59IC8vIEEgb25lLXRpbWUgc25hcHNob3Qgd2l0aCBubyBwbGFucyB0byB1cGRhdGUuIFdlJ2xsIHByb2JhYmx5IHdhbnQgdG8gZGVwcmVjYXRlIFNpbXVsYXRlIEFQSS5cblxuXG52YXIgc2ltdWxhdGVkRXZlbnRUeXBlcyA9IFsnYmx1cicsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnYXV4Q2xpY2snLCAnZG91YmxlQ2xpY2snLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbW91c2VEb3duJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwb2ludGVyQ2FuY2VsJywgJ3BvaW50ZXJEb3duJywgJ3BvaW50ZXJVcCcsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3Jlc2l6ZScsICdzZWVrZWQnLCAnc3VibWl0JywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoU3RhcnQnLCAndm9sdW1lQ2hhbmdlJywgJ2RyYWcnLCAnZHJhZ0VudGVyJywgJ2RyYWdFeGl0JywgJ2RyYWdMZWF2ZScsICdkcmFnT3ZlcicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ3BvaW50ZXJNb3ZlJywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlck92ZXInLCAnc2Nyb2xsJywgJ3RvZ2dsZScsICd0b3VjaE1vdmUnLCAnd2hlZWwnLCAnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2dvdFBvaW50ZXJDYXB0dXJlJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbG9zdFBvaW50ZXJDYXB0dXJlJywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0cmFuc2l0aW9uRW5kJywgJ3dhaXRpbmcnLCAnbW91c2VFbnRlcicsICdtb3VzZUxlYXZlJywgJ3BvaW50ZXJFbnRlcicsICdwb2ludGVyTGVhdmUnLCAnY2hhbmdlJywgJ3NlbGVjdCcsICdiZWZvcmVJbnB1dCcsICdjb21wb3NpdGlvbkVuZCcsICdjb21wb3NpdGlvblN0YXJ0JywgJ2NvbXBvc2l0aW9uVXBkYXRlJ107XG5cbmZ1bmN0aW9uIGJ1aWxkU2ltdWxhdG9ycygpIHtcbiAgc2ltdWxhdGVkRXZlbnRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICBTaW11bGF0ZVtldmVudFR5cGVdID0gbWFrZVNpbXVsYXRvcihldmVudFR5cGUpO1xuICB9KTtcbn1cblxuYnVpbGRTaW11bGF0b3JzKCk7XG52YXIgZGlkV2FybkFib3V0VXNpbmdBY3QgPSBmYWxzZTtcbnZhciBhY3QgPSAgZnVuY3Rpb24gYWN0V2l0aFdhcm5pbmcoY2FsbGJhY2spIHtcbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0VXNpbmdBY3QpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVzaW5nQWN0ID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ2BSZWFjdERPTVRlc3RVdGlscy5hY3RgIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYFJlYWN0LmFjdGAuICcgKyAnSW1wb3J0IGBhY3RgIGZyb20gYHJlYWN0YCBpbnN0ZWFkIG9mIGByZWFjdC1kb20vdGVzdC11dGlsc2AuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L3dhcm5pbmdzL3JlYWN0LWRvbS10ZXN0LXV0aWxzIGZvciBtb3JlIGluZm8uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWN0QWN0KGNhbGxiYWNrKTtcbn0gO1xuXG5leHBvcnRzLlNpbXVsYXRlID0gU2ltdWxhdGU7XG5leHBvcnRzLmFjdCA9IGFjdDtcbmV4cG9ydHMuZmluZEFsbEluUmVuZGVyZWRUcmVlID0gZmluZEFsbEluUmVuZGVyZWRUcmVlO1xuZXhwb3J0cy5maW5kUmVuZGVyZWRDb21wb25lbnRXaXRoVHlwZSA9IGZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlO1xuZXhwb3J0cy5maW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3MgPSBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3M7XG5leHBvcnRzLmZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWcgPSBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoVGFnO1xuZXhwb3J0cy5pc0NvbXBvc2l0ZUNvbXBvbmVudCA9IGlzQ29tcG9zaXRlQ29tcG9uZW50O1xuZXhwb3J0cy5pc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlID0gaXNDb21wb3NpdGVDb21wb25lbnRXaXRoVHlwZTtcbmV4cG9ydHMuaXNET01Db21wb25lbnQgPSBpc0RPTUNvbXBvbmVudDtcbmV4cG9ydHMuaXNET01Db21wb25lbnRFbGVtZW50ID0gaXNET01Db21wb25lbnRFbGVtZW50O1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRWxlbWVudE9mVHlwZSA9IGlzRWxlbWVudE9mVHlwZTtcbmV4cG9ydHMubW9ja0NvbXBvbmVudCA9IG1vY2tDb21wb25lbnQ7XG5leHBvcnRzLm5hdGl2ZVRvdWNoRGF0YSA9IG5hdGl2ZVRvdWNoRGF0YTtcbmV4cG9ydHMucmVuZGVySW50b0RvY3VtZW50ID0gcmVuZGVySW50b0RvY3VtZW50O1xuZXhwb3J0cy5zY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUgPSBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGU7XG5leHBvcnRzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3MgPSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzO1xuZXhwb3J0cy5zY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZyA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnO1xuZXhwb3J0cy50cmF2ZXJzZVR3b1BoYXNlID0gdHJhdmVyc2VUd29QaGFzZTtcbiAgfSkoKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVosSUFBSUEsT0FBTyxDQUFDQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxZQUFZLEVBQUU7RUFDekMsQ0FBQyxZQUFXO0lBQ2QsWUFBWTs7SUFFWixJQUFJQyxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDNUIsSUFBSUMsUUFBUSxHQUFHRCxPQUFPLENB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